<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>线段树</title>
    <link href="undefined2019/12/26/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>2019/12/26/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>线段树节点数据结构：</p><pre><code class="java">class SegmentTree{    int l,r;   //每个区间的左右端点    int sum;   //区间数据    //其他附加信息}</code></pre><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><p>以完全二叉树建树，可以使用父子二倍标记法，子节点下标为父节点下标值的两倍。</p><pre><code class="java">//递归建树//p:当前父节点，sak为节点数组void build(int p,int l,int r){    sak[p].l=l;sak[p].r=r;    if(l==r){        sak[p].sum=a[l];        return;    }    int mid = (l+r)/2;    //依次建立左右子树    build(2*p,l,mid);    build(2*p+1,mid+1,r);    sak[p].sum = sak[2*p].sum+sak[2*p+1].sum;}</code></pre><h3 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h3><p>每次操作都是从根节点开始遍历，递归找到需要修改的节点。</p><pre><code class="java">//p:当前节点    x:目标节点      val:修改值    void change(int p,int x,int val){    if(sak[p].l==sak[p].r){        sak[p].sum = val;        return;    }    int mid = (l+r)/2;    if(x &lt;= mid) change(p*2,x,val);    else change(p*2+1,x,val);    sak[p].sum = sak[p*2].sum + sak[p*2+1].sum;}</code></pre><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><ol><li>若当前节点所表示的区间已经被询问区间所完全覆盖，则立即回溯，并传回该点的信息。</li><li>若当前节点的左儿子所表示的区间已经被询问区间所完全覆盖，就递归访问它的左儿子。</li><li>若当前节点的右儿子所表示的区间已经被询问区间所完全覆盖，就递归访问它的右儿子。</li></ol><pre><code class="java">int ask(int p,int l,int r){    if(l &lt;= sak[p].l &amp;&amp; r &gt;= sak[p].r) return sak[p].sum;    int val = 0 ;    int mid = (sak[p].l + sak[p].r)/2;    if(l&lt;=mid) val+=ask(2*p,l,r);    if(r&gt;mid) val+=ask(2*p+1,l,r);    return val;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="undefined2019/12/05/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>2019/12/05/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。可以求解一些图相关的问题（连通分量）。</p><p><strong>并查集森林</strong>是一种将每一个集合以树的形式表示的数据结构，其中每个结点都保存着到他父节点的引用。在并查集森林中，每个集合的代表即是集合的根节点。“查找”根据其父节点的引用向根行进直到到底树根。“联合”将两棵树合并到一起，这通过将一棵树的根连接到另一棵树的根。</p><pre><code class="java">class UnionSet{    int[] parent;    //初始化并查集,每个结点自成一个集合    void UnionSet(int n){        parent=new int[n];        for(int i=0;i&lt;n;i++){            parent[i]=i;        }    }    //递归查找根节点    int find(int x){        if(parent[x]==x) return x;        else return find(parent[x]);    }    //将x,y所在集合合并    void union(int x,int y){        int xRoot = find(x);        int yRoot = find(y);        parent[xRoot] = yRoot;    }}</code></pre><p>上述方法可能会导致严重的不平衡，下面介绍优化的方法。</p><h3 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h3><p>按秩合并总是将更小的树连接到更大的树上，秩代表树的深度，单元素的树秩为0，当两颗秩为r的树合并时秩为r+1.</p><pre><code class="java">class UnionSet{    int[] parent;    int[] rank;    void UnionSet(int n){        parent=new int[n];        rank=new int[n];        for(int i=0;i&lt;n;i++){            parent[i]=i;        }    }    int find(int x){        //操作相同    }    void union(int x,int y){        int xRoot = find(x);        int yRoot = find(y);        if(rank[xRoot] &gt; rank[yRoot]){            parent[yRoot] = xRoot;        }else if(rank[xRoot] &lt; rank[yRoot]){            parent[xRoot] = yRoot;        }else{            parent[xRoot] = yRoot;            rank[yRoot] += 1;         }    }}</code></pre><h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>将每个结点直接连接到根节点上</p><pre><code class="java">int find(int x){    if(parent[x]!=x){        parent[x]=find(parent[x]);    }    return parent[x];}</code></pre>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成随机字符串</title>
    <link href="undefined2019/12/05/%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>2019/12/05/%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>11月一直在准备考试和各种结课作业，停滞了很长时间没有学习新技术了。最近在stackoverflow上看到一些有趣的问题，就自己做了相关总结。</p><p><a href="https://stackoverflow.com/questions/41107/how-to-generate-a-random-alpha-numeric-string" target="_blank" rel="noopener">https://stackoverflow.com/questions/41107/how-to-generate-a-random-alpha-numeric-string</a></p><p>问题：生成伪随机的字母-数字字符串。For example, a generated string of length 12 might look something like <code>&quot;AEYGF7K0DM1X&quot;</code>.</p><p>类的逻辑较为简单，不过使用了一些之前没接触过的库函数。</p><p>1、java.util.concurrent.ThreadLocalRandom</p><p>Random虽然是线程安全的，但是在多线程环境下效率很低，而且Random产生的随机数序列可以预测，顾不适合作为验证码类随机数产生。（思考：图片验证码产生是不是根据产生的随机数从数据库中选出相应的图片作为验证码？）</p><pre><code class="java">System.out.println(&quot;-----------产生1到10之间的随机数----------------&quot;);// 返回当前线程的 ThreadLocalRandom// 每个线程都有一个独立的生成器ThreadLocalRandom threadRandom = ThreadLocalRandom.current();System.out.println(threadRandom.nextInt(10));System.out.println(&quot;-----------产生两个数之间的随机数----------------&quot;);System.out.println(threadRandom.nextInt(10,100));</code></pre><p>2、Random类默认使用当前系统时钟作为种子，种子相同生成的随机数序列也相同，所以不安全。操作系统收集了一些随机事件，比如鼠标点击，键盘点击等等，SecureRandom 使用这些随机事件作为种子。安全性很高。具体原理感兴趣可以研究。</p><pre><code class="java">import java.security.SecureRandom;import java.util.Locale;import java.util.Objects;import java.util.Random;import java.util.concurrent.ThreadLocalRandom;public class RandomString {    /**     * Generate a random string.     */    public String nextString() {        for (int idx = 0; idx &lt; buf.length; ++idx)            buf[idx] = symbols[random.nextInt(symbols.length)];        return new String(buf);    }    public static final String upper = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;    // Local.ROOT 获取系统的语言环境    public static final String lower = upper.toLowerCase(Locale.ROOT);    public static final String digits = &quot;0123456789&quot;;    public static final String alphanum = upper + lower + digits;    private final Random random;    private final char[] symbols;    private final char[] buf;    // length 生成随机字符串长度    // symbols 用于生成随机字符串的字符列表    public RandomString(int length, Random random, String symbols) {        if (length &lt; 1) throw new IllegalArgumentException();        if (symbols.length() &lt; 2) throw new IllegalArgumentException();        this.random = Objects.requireNonNull(random);        this.symbols = symbols.toCharArray();        this.buf = new char[length];    }    /**     * Create an alphanumeric string generator.     */    public RandomString(int length, Random random) {        //该this方法是调用上面的RandomString构造方法        this(length, random, alphanum);    }    /**     * Create an alphanumeric strings from a secure generator.     */    public RandomString(int length) {        this(length, new SecureRandom());    }    /**     * Create session identifiers.     */    public RandomString() {        this(21);    }}</code></pre><p>补充：java提供了一个生成随机文件名的包(java.util.UUID)，主要用于web中产生的一些文件。</p><pre><code class="java">import java.util.UUID;public class randomStringGenerator {    public static void main(String[] args) {        System.out.println(generateString());    }    public static String generateString() {        String uuid = UUID.randomUUID().toString();        return &quot;uuid = &quot; + uuid;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>StackOverflow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java随笔--断言、日志</title>
    <link href="undefined2019/11/06/java%E9%9A%8F%E7%AC%94-%E6%96%AD%E8%A8%80%E3%80%81%E6%97%A5%E5%BF%97/"/>
    <url>2019/11/06/java%E9%9A%8F%E7%AC%94-%E6%96%AD%E8%A8%80%E3%80%81%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>断言机制允许在测试期间向代码中插入一些检查语句，当代码发布时，这些插入的检测语句会被自动地移走。Java语言引入了关键字assert，有两种形式：</p><pre><code class="java">assert 条件;assert 条件:表达式;</code></pre><p>这两种形式都会对条件进行检测， 如果结果为false, 则抛出一个AssertionError 异常。在第二种形式中，表达式将被传人AssertionError 的构造器， 并转换成一个消息字符串。</p><p>在默认情况下， 断言被禁用。可以在运行程序时启用断言，断言的启用和禁用不必重新编译程序。启用或禁用断言是类加载器( class loader ) 的功能。当断言被禁用时， 类加载器将跳过断言代码， 因此，不会降低程序运<br>行的速度。</p><pre><code>java -enableassertions MyApp</code></pre><p>不应该使用断言向程序的其他部分通告发生了可恢复性的错误， 或者，不应该作为程序向用户通告问题的手段。断言只应该用于在<strong>测试阶段</strong>确定程序内部的错误位置。</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>日志可以替换测试代码中使用的<code>System.out.println()</code>，不像输出语句测试完还需要删除。</p><pre><code class="java">//基本日志Logger.getGlobal().info(&quot;File-&gt;OPen menu item selected&quot;);//如果在适当的地方（如main开始）调用，会取消所有日志Logger.getGlobal().setLevel(Level.OFF);//高级日志（目前学习阶段用不到，以后需要再进行补充）</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java随笔--lambda表达式</title>
    <link href="undefined2019/11/06/java%E9%9A%8F%E7%AC%94-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>2019/11/06/java%E9%9A%8F%E7%AC%94-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>lambda表达式形式：参数，箭头(-&gt;)以及一个表达式，也可以将操作放在代码块{}中。</p><pre><code class="java">(String first,String second)-&gt;{    if(first.length()&gt;second.length()) return 1;    else if(first.length()&lt;second.length()) return -1;    else return 0;}() -&gt; System.out.pringln(&quot;i&quot;);</code></pre><p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口。Comparator 就是只有一个方法的接口， 所以可以提供一个lambda 表达式：</p><p>函数式接口中可以包含静态方法（已经实现了的方法），默认方法（default），java.lang.Object里的public方法。</p><pre><code class="java">Arrays.sort (words ,    (first , second) -&gt; first.length() - second.length()) ;</code></pre><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><pre><code class="java">Timer t = new Timer(1000, event -&gt; System.out.println(event))；//等价于Timer t = new Timer(1000, System.out::println);</code></pre><p>表达式System.out::println是一个方法引用，等价于前面的lambda表达式。主要有3中形式：</p><pre><code>//System.out.println == x-&gt;System.out.println(x)object::instanceMethod//Math.pow(x,y) == (x,y)-&gt;Math.pow(x,y)Class::staticMethod//String::compareToIgnoreCase == (x,y)-&gt;x.compareToIgnoreCase(y)Class::instanceMethod</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java随笔--一些注意点和tricks</title>
    <link href="undefined2019/11/05/java%E9%9A%8F%E7%AC%94-%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9%E5%92%8Ctricks/"/>
    <url>2019/11/05/java%E9%9A%8F%E7%AC%94-%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9%E5%92%8Ctricks/</url>
    
    <content type="html"><![CDATA[<h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>String类下的split()方法在根据正则表达式对字符串进行分割时会产生空字符串，在处理时需要进行判断。</p><pre><code class="java">//1、空字符串不会被解析public class test {    public static void main(String[] args) {        String str = &quot;1,2,3,4,,,&quot;;        String[] arr = str.split(&quot;,&quot;);        for (String string : arr) {            System.out.println(&quot;str&quot;+string);        }        System.out.println(arr.length);    }}//输出：str1,str2,str3,str4    4//2、最后一个分隔符被分的字符串不为空时，其余空字符串可被解析。public class test {    public static void main(String[] args) {        String str = &quot;1,2,3,4,,,5&quot;;        String[] arr = str.split(&quot;,&quot;);        for (String string : arr) {            System.out.println(&quot;str&quot;+string);        }        System.out.println(arr.length);    }}//输出：str1,str2……str4,str,str,str5     7//3、limit参数为整数时，只会截取前几个；为0时，正常截取；//     为负数时，即使是第一种情况，也会输出空字符串String[] s = str.split(&quot;,&quot;,-1);</code></pre><h3 id="s-equals-s1"><a href="#s-equals-s1" class="headerlink" title="s.equals(s1)"></a>s.equals(s1)</h3><p>判断字符串s是否等于s1，应该使用equals方法，不可以通过“==”进行判断。</p><h3 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h3><p>当你把对象加入<code>HashSet</code>时，HashSet会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用<code>equals()</code>方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。</p><p>所以Set中存储自己定义的对象时，需要重写hashCode()和equals()方法。</p><pre><code class="java">//Person类(name,age两个属性)//重写hashCodepublic int hashCode(){        final int prime = 31;        int result = 1;        result = prime * result + ((age == null) ? 0 : age.hashCode());        result = prime * result + ((name == null) ? 0 : name.hashCode());        return result;    }//重写equalspublic boolean equals(Person obj){}</code></pre><h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><p>如果重写equals()方法，就必须重新定义hashCode方法，以便用户可以将对象插入到散列表(自定义对象的HashMap)。hashCode 方法应该返回一个整型数值（也可以是负数)，并合理地组合实例域的散列码,以便能够让各个不同的对象产生的散列码更加均匀。下面是一个重写hashCode的例子。</p><pre><code class="java">public class Employee{    public int hashCode(){        return 7*name.hashCode()            + 11*new Double(salary).hashCode()            + 13*hireDay.hashCode();    }}//如果参数为null,安全起见使用下面的方法public int hashCode(){    return 7*Objects.hashCode(name)        + 11*Double.hashCode(salary)        + 13*Objects.hashCode(hireDay);}//组合多个散列值时可以采用更好的方法public int hashCode(){    return Objects.hash(name,salary,hireDay);}</code></pre><p>Equals与hashCode的定义必须一致：如果x.equals(y) 返回true, 那么x.hashCode( ) 就必<br>须与y.hashCode( ) 具有相同的值。例如， 如果用定义的Employee.equals 比较雇员的ID， 那<br>么hashCode 方法就需要散列ID，而不是雇员的姓名或存储地址。</p><h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h3><p>import语句不仅可以导入类，还可以导入静态方法和静态域，如：</p><pre><code class="java">import static java.lang.System.*//可以使用System类的静态方法和静态域，而不必加类名前缀out.println(&quot;hello&quot;);  //省略了System.outexit(0);</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java随笔--PriorityQueue</title>
    <link href="undefined2019/10/30/java%E9%9A%8F%E7%AC%94-PriorityQueue/"/>
    <url>2019/10/30/java%E9%9A%8F%E7%AC%94-PriorityQueue/</url>
    
    <content type="html"><![CDATA[<p>java的PriorityQueue是基于堆的优先队列。下面是其构造方法：</p><pre><code class="java">//如果Collection已排序，则根据它的顺序进行排序PriorityQueue(Collection&lt;? extends E&gt; c)//自定义一个比较器，根据比较器进行优先级判断PriorityQueue(Comparator&lt;? super E&gt; comparator)</code></pre><p>第二种构造方法使用的较多，比较器的创建可以使用<strong>匿名内部类</strong>的方法指定。通过重写Comparator的compare方法来实现。下面通过例子来解释：</p><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/top-k-frequent-elements/</a></p><pre><code class="java">public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {        List&lt;Integer&gt; list=new ArrayList&lt;&gt;();        if(nums.length==1){            list.add(nums[0]);            return list;        }        Map&lt;Integer,Integer&gt; hashmap=new HashMap&lt;Integer,Integer&gt;();        for(int i:nums){            if(!hashmap.containsKey(i)){                hashmap.put(i,1);            }else{                int k1=hashmap.get(i)+1;                hashmap.replace(i,k1);            }        }        //new Comparator&lt;T&gt;() 实现接口的匿名内部类        //泛型不可以省略        PriorityQueue&lt;Integer&gt; queue=new PriorityQueue&lt;Integer&gt;(new Comparator&lt;Integer&gt;(){        /*    public修饰符不可以省略            原因未知            这里是小根堆，使用自然排序（从小到大），当n1&gt;n2，返回1           */       public int compare(Integer n1,Integer n2){           if(hashmap.get(n1)&gt;hashmap.get(n2))               return 1;           else if(hashmap.get(n1)==hashmap.get(n2))               return 0;           else               return -1;       }         });        for(Integer num:hashmap.keySet()){            queue.add(num);            if(queue.size()&gt;k){                queue.poll();            }        }        while(queue.size()&gt;=1){            list.add(queue.poll());        }        //逆转        Collections.reverse(list);        return list;    }</code></pre><pre><code class="java">//使用lambda表达式初始化//(x, y) -&gt; x – y  接受2个参数(数字),并返回他们的差值PriorityQueue&lt;Integer&gt; heap =         new PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; hashmap.get(n1) - hashmap.get(n2));</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树</title>
    <link href="undefined2019/10/19/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>2019/10/19/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-binary-search-trees-ii/</a></p><p>给定一个整数 <em>n</em>，生成所有由 1 … <em>n</em> 为节点所组成的<strong>二叉搜索树</strong>。</p><p>递归：我们从序列 <code>1 ..n</code> 中取出数字 <code>i</code>，作为当前树的树根。于是，剩余 <code>i - 1</code> 个元素可用于左子树，<code>n - i</code> 个元素用于右子树。通过递归构建所有的子树。</p><pre><code class="java">public List&lt;TreeNode&gt; generateTrees(int n) {    if(n==0) return new ArrayList&lt;TreeNode&gt;();    return createTree(1,n);}//每次递归应该返回可能的子树列表List&lt;TreeNode&gt; createTree(int start,int end){    List&lt;TreeNode&gt; list=new ArrayList&lt;&gt;();    if(start&gt;end){        list.add(null);        return list;    }     for(int i=start;i&lt;=end;i++){        List&lt;TreeNode&gt; leftList=createTree(start,i-1);        List&lt;TreeNode&gt; rightList=createTree(i+1,end);        //将左右子树连接        for(TreeNode left:leftList){            for(TreeNode right:rightList){                TreeNode root=new TreeNode(i);                root.left=left;                root.right=right;                list.add(root);            }        }     }    return list;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java随笔--内部类</title>
    <link href="undefined2019/10/19/java%E9%9A%8F%E7%AC%94-%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>2019/10/19/java%E9%9A%8F%E7%AC%94-%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="一、成员内部类"><a href="#一、成员内部类" class="headerlink" title="一、成员内部类"></a>一、成员内部类</h3><p>​        内部类可以用来实现多继承。成员内部类可以访问外部类的所有成员变量，包括private修饰的。</p><p>​        内部类跟外部类有一个很重要区别：内部类可以用private修饰，而外部类是不能使用private修饰的。如果内部类仅仅在类内部使用时，使用private修饰后，就可以更好的隐藏内部信息。</p><p>​        当需要使用到内部类的时候，还是推荐使用<code>getInnerInstance</code>的方式来获取，特别是当内部类只有无参构造器的时候</p><pre><code class="java">public class Outer {    private int num;    private Inner inner;    Outer(){        num = 1;        inner = new Inner();    }    public void print(){        System.out.println(&quot;Outer.print()&quot;);        System.out.println(inner.num);        System.out.println(num);    }    //获取内部类对象    public Inner getInnerInstance() {        return new Inner();    }    class Inner{        private int num;        Inner(){            num = 2;        }        public void print(){            System.out.println(&quot;Inner.print()&quot;);            System.out.println(this.num);            System.out.println(Outer.this.num);        }    }}</code></pre><pre><code class="java">public class Test {    public static void main(String[] args) {        Outer outer = new Outer();        Outer.Inner inner = outer.new Inner();        outer.print();        inner.print();    }}</code></pre><p>​        外部类访问内部类是先生成内部类实例，然后就能访问所有方法和属性，内部类访问外部类方法和属性则直接使用Outer.属性/方法名 即可。</p><h3 id="二、局部内部类"><a href="#二、局部内部类" class="headerlink" title="二、局部内部类"></a>二、局部内部类</h3><p>局部内部类就是定义在代码块、方法体内、作用域（使用花括号“{}”括起来的一段代码）内的类。局部内部类有以下特性：</p><ol><li>局部内部类只能在代码代码块、方法体内和作用域中使用。</li><li>局部内部类同样可以无限制调用外部类的方法和属性。</li><li>可以使用abstract修饰，声明为抽象类。</li></ol><pre><code class="java">public class Outer {    public static final int TOTAL_NUMBER = 5;    public int id = 123;    public void func() {        final int age = 15;        String str = &quot;http://www.weixueyuan.net&quot;;        class Inner {            public void innerTest() {                System.out.println(TOTAL_NUMBER);                System.out.println(id);                // System.out.println(str);不合法，只能访问本地方法的final变量                System.out.println(age);            }        }        new Inner().innerTest();    }    public static void main(String[] args) {        Outer outer = new Outer();        outer.func();    }}</code></pre><h3 id="三、匿名内部类"><a href="#三、匿名内部类" class="headerlink" title="三、匿名内部类"></a>三、匿名内部类</h3><pre><code class="java">new 父类（参数列表）|实现接口（） {//匿名内部类的内部定义}</code></pre><pre><code class="java">public class AnonymousTest {    public static void main(String[] args) {        new Thread(new Runnable() {            public void run() {                for (int i = 0; i &lt; 10; i++) {                    try {                        sleep(1000);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(i);                }            }        }).start();    }}</code></pre><p>这里创建了一个继承于Thread的匿名内部类，覆盖了其中的 run方法，并创建了一个实例返回给了t，然后再调用run方法，可以看到，匿名内部类只能存在一个实例对象，因为new过一次就无法再创建了。匿名内部类不仅可以继承于类，也可以实现于接口：</p><pre><code class="java">public class AnonymousTest {    public static void main(String[] args) {        new Thread(new Runnable() {            public void run() { …… }).start();    }}</code></pre><p>当我们创建的类只需要一个实例的时候可以使用匿名内部类，比如说在多线程中，要使用多线程，一般先继承Thread类或者实现Runnable接口，然后再去调用它的方法，而每个任务一般都不一样，每次都新建一个类显然会很难管理，因为每个类只用一次就丢掉了，这个时候使用匿名内部类就很方便了，不仅不需要管理一堆一次性类，而且创建起来简单粗暴。</p><pre><code>使用匿名内部类还是有很多限制的：1、匿名内部类必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。2、匿名内部类不能定义构造函数。3、匿名内部类中不能存在任何的静态成员变量和静态方法。4、匿名内部类是特殊的局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</code></pre><pre><code class="java">//通过初始化块来实现匿名内部类的初始化//匿名内部类只能定义在方法等内部public class AnonymousTest{    public static void main(String[] args){        Human human = new Human(){            private String name;            {                name=&quot;human&quot;;            }            @Override            public void walk(){……}        };        human.walk();    }}</code></pre><p>注意，如果匿名内部类需要使用外部的参数或者变量，那么必须使用final修饰，因为内部类使用的其实是参数的拷贝，并不是参数本身，为了更明显的表明参数不可变，编译器会要求使用final关键字来修饰需要使用的变量。</p><pre><code class="java">public class AnonymousTest {    public static void main(String[] args) {        Human human = new AnonymousTest().getHumanInstance(&quot;Frank&quot;);        human.walk();    }    public Human getHumanInstance(final String name){        return new Human() {            private String nameA;            {                nameA = name;            }            @Override            public void walk() {                System.out.println(nameA + &quot; walk.&quot;);            }        };    }}</code></pre><h3 id="四、静态内部类"><a href="#四、静态内部类" class="headerlink" title="四、静态内部类"></a>四、静态内部类</h3><p>它的创建不依赖外部类，创建内部类的实例不需要像普通内部类一样先创建外部类实例才能创建。它不能无限制访问外部类的方法和成员变量，<strong>只能访问静态成员变量和静态方法</strong>。</p><pre><code class="java">public class Caculate {    //定义一个pair类来将两个数捆绑    static class Pair{        private int first;        private int second;        public Pair(int first, int second) {            this.first = first;            this.second = second;        }        public int getFirst() {            return first;        }        public int getSecond() {            return second;        }    }    //获取一个int数组中的最大和最小值    public static Pair getMaxMin(int[] values){        int max = Integer.MIN_VALUE;        int min = Integer.MAX_VALUE;        for (int i:values){            if (min &gt; i) min = i;            if (max &lt; i) max = i;        }        return new Pair(min,max);    }    public static void main(String[] args){        int[] list = {1,3,5,2,77,23,25};        Caculate.Pair pair = Caculate.getMaxMin(list);        System.out.println(pair.getFirst());        System.out.println(pair.getSecond());        System.out.println(pair.first);        System.out.println(pair.second);    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找细节详解</title>
    <link href="undefined2019/10/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%86%E8%8A%82%E8%AF%A6%E8%A7%A3/"/>
    <url>2019/10/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%86%E8%8A%82%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="1、基本二分查找"><a href="#1、基本二分查找" class="headerlink" title="1、基本二分查找"></a>1、基本二分查找</h3><pre><code class="java">//常见场景：查找一个数int binarySearch(int[] nums, int target) {    int left = 0;     int right = nums.length - 1; // 注意    while(left &lt;= right) {        int mid = (right + left) / 2;        if(nums[mid] == target)            return mid;         else if (nums[mid] &lt; target)            left = mid + 1; // 注意        else if (nums[mid] &gt; target)            right = mid - 1; // 注意        }    return -1;}</code></pre><p>1、为什么 while 循环的条件中是 &lt;=，而不是 &lt; ？</p><p>答：因为初始化 right 的赋值是 nums.length-1，即最后一个元素的索引，而不是 nums.length。这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。</p><p>我们这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间。<strong>这个区间其实就是每次进行搜索的区间，我们不妨称为「搜索区间」</strong>。</p><h3 id="2、寻找左侧边界的二分查找"><a href="#2、寻找左侧边界的二分查找" class="headerlink" title="2、寻找左侧边界的二分查找"></a>2、寻找左侧边界的二分查找</h3><pre><code class="java">//对于注意点，主要从搜索区间和终止条件方面考虑int left_bound(int[] nums, int target) {    if (nums.length == 0) return -1;    int left = 0;    int right = nums.length; // 注意    while (left &lt; right) { // 注意        int mid = (left + right) / 2;        if (nums[mid] == target) {            right = mid;        } else if (nums[mid] &lt; target) {            left = mid + 1;        } else if (nums[mid] &gt; target) {            right = mid; // 注意        }    }    return left;}</code></pre><p>1、为什么 left = mid + 1，right = mid ？和之前的算法不一样？</p><p>答：因为我们的「搜索区间」是 <code>[left, right)</code> 左闭右开，所以当 nums[mid] 被检测之后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 <code>[left, mid)</code> 或 <code>[mid + 1, right)</code>。（搜索区间格式不变）</p><p>2、为什么该算法能够搜索左侧边界？</p><p>答：关键在于对于 <code>nums[mid]</code> == <code>target</code> 这种情况的处理：找到target值时不直接返回，而是缩小搜索上边界。</p><p>3、为什么返回 <code>left</code> 而不是 <code>right</code>？</p><p>答：都是一样的，因为 <code>while</code> 终止的条件是 <code>left == right</code>。</p><h3 id="3、寻找右侧边界的二分查找"><a href="#3、寻找右侧边界的二分查找" class="headerlink" title="3、寻找右侧边界的二分查找"></a>3、寻找右侧边界的二分查找</h3><pre><code class="java">int right_bound(int[] nums, int target) {    if (nums.length == 0) return -1;    int left = 0, right = nums.length;    while (left &lt; right) {        int mid = (left + right) / 2;        if (nums[mid] == target) {            left = mid + 1; // 注意        } else if (nums[mid] &lt; target) {            left = mid + 1;        } else if (nums[mid] &gt; target) {            right = mid;        }    }    return left - 1; // 注意}</code></pre><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/</a></p><pre><code class="java">class Solution {    public int[] searchRange(int[] nums, int target) {        int[] index={-1,-1};        if(nums.length&lt;1) return index;        int right,left;  //左右边界        //寻找左侧边界        int low=0,high=nums.length;        int mid;        while(low&lt;high){            mid=(low+high)/2;            if(nums[mid]==target){                high=mid;            }else if(nums[mid]&gt;target){                high=mid;            }else{                low=mid+1;            }        }        //没有找到直接返回(比所有数都大或者最后的数不等于目标值)        if(low==nums.length||nums[low]!=target)            return index;        left=low;        //寻找右侧边界        low=0;high=nums.length;        while(low&lt;high){            mid=(low+high)/2;            if(nums[mid]==target){                low=mid+1;            }else if(nums[mid]&gt;target){                high=mid;            }else{                low=mid+1;            }        }        right=low-1;        index[0]=left;index[1]=right;                  return index;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java随笔--对象的克隆</title>
    <link href="undefined2019/10/17/Java%E9%9A%8F%E7%AC%94-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%8B%E9%9A%86/"/>
    <url>2019/10/17/Java%E9%9A%8F%E7%AC%94-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%8B%E9%9A%86/</url>
    
    <content type="html"><![CDATA[<p>java的引用类型（包括类、接口、数组等复杂类型）是无法通过等号直接赋值的。</p><pre><code class="java">public class GoodsTest {    public static void main(String[] args){        Goods goodsA = new Goods(&quot;GoodsA&quot;,20);        Goods goodsB = goodsA;        System.out.println(&quot;Before Change:&quot;);        goodsA.print();        goodsB.print();        goodsB.setTitle(&quot;GoodsB&quot;);        goodsB.setPrice(50);        System.out.println(&quot;After Change:&quot;);        goodsA.print();        goodsB.print();    }}//修改goodsB,goodsA也会发生变化，两个变量指向同一个地址</code></pre><p>如果要实现对象的复制，需要重写clone方法，所有类都继承自Object类，该类有一个protected的clone方法。</p><pre><code class="java">//要使用克隆方法需要实现Cloneable接口public class Goods implements Cloneable{    private String title;    private double price;    public Goods(String aTitle, double aPrice){        title = aTitle;        price = aPrice;    }    //这里重载了接口的clone方法    @Override    protected Object clone(){        Goods g = null;        try{            //使用super来引用父类的成分，用this来引用当前对象            g = (Goods)super.clone();        }catch (CloneNotSupportedException e){            System.out.println(e.toString());        }        return g;    }</code></pre><p>如果一个类的成员变量包含另一个类的对象，使用上述方法只能克隆该类的非引用类型，引用类型仍然指向同一个地址。解决这个问题需要使用深克隆（序列化、反序列化）。下面例子中Cart和Goods类都需要实现Serializable接口。</p><pre><code class="java">import java.io.*;public class Cart implements Serializable{    //实例域    Goods goodsList = new Goods(&quot;&quot;,0);//简单起见，这里只放了一个商品    double budget = 0.0;//预算    //构造函数    public Cart(double aBudget){        budget = aBudget;    }    public Object deepClone() throws IOException, OptionalDataException,ClassNotFoundException {        // 将对象写到流里        ByteArrayOutputStream bo = new ByteArrayOutputStream();        ObjectOutputStream oo = new ObjectOutputStream(bo);        oo.writeObject(this);        // 从流里读出来        ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());        ObjectInputStream oi = new ObjectInputStream(bi);        return (oi.readObject());    }}public class Goods implements Serializable{……}</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合总数</title>
    <link href="undefined2019/10/17/%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0/"/>
    <url>2019/10/17/%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/combination-sum/solution/hui-shuo-suan-fa-di-gui-java-by-longchenghuang/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combination-sum/solution/hui-shuo-suan-fa-di-gui-java-by-longchenghuang/</a></p><p>总结：回溯主要是通过递归对所有情况进行遍历，通过剪枝降低复杂度。难点在于如何通过剪枝降低系统栈深度，降低时间复杂度？</p><p>后面选取的数不能比前面选的数还要小，即 “更深层的边上的数值不能比它上层的边上的数值小”，本题通过这种方式降低复杂度。</p><pre><code class="java">List&lt;List&lt;Integer&gt;&gt; set=new ArrayList&lt;List&lt;Integer&gt;&gt;();public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {    //排序    Arrays.sort(candidates);     List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;();    trace(0,list,candidates,target);    return set;}public void trace(int index,List&lt;Integer&gt; list,int[] candidates,int tempTarget){    if(tempTarget==0) {        //引用类型，需要创建新的对象        List&lt;Integer&gt; num=new ArrayList&lt;Integer&gt;(list);        set.add(num);        return;    }    if(index&gt;=candidates.length||tempTarget&lt;candidates[index]) return;    //以index为起点，就是考虑了去重的问题，且考虑到了数字可以多次使用的条件    //通过这种方式，迭代会一直从同一个下标开始，直到不符合条件，下标加一，    //对比i从零开始的情况    for(int i=index;i&lt;candidates.length;i++){        list.add(candidates[i]);        trace(i,list,candidates,tempTarget-candidates[i]);        //回溯的关键，进行同一层的下一步时，需要先删除这一层上一步的元素        list.remove(list.size()-1);    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电话号码的字母组合</title>
    <link href="undefined2019/10/12/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
    <url>2019/10/12/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/</a></p><p>思路：DFS、回溯（没有剪枝，解空间即为答案）</p><p>改进：字符串相加可以使用StringBuffer。</p><pre><code class="java">class Solution {    //两个大括号的方式初始化(本质上是匿名内部类 + 实例化代码块儿)    Map&lt;String,String&gt; hashMap=new HashMap&lt;String,String&gt;(){{        put("2","abc");         put("3","def");         put("4","ghi");         put("5","jkl");         put("6","mno");         put("7","pqrs");         put("8","tuv");         put("9","wxyz");     }};    public List&lt;String&gt; letterCombinations(String digits) {        List&lt;String&gt; list=new ArrayList&lt;String&gt;();        if(digits.length()&lt;1||digits==null) return list;        String str=String.valueOf(digits.charAt(0));        for(int i=0;i&lt;hashMap.get(str).length();i++){            String s=String.valueOf(hashMap.get(str).charAt(i));            backTrace(list,s,digits,1);        }        return list;    }    //dep为深度，这里指字符的索引;s为前面映射的字符串    public void backTrace(List&lt;String&gt; list,String s,String digits,int dep){        if(digits.length()==dep){            list.add(s);            return;        }        String str=String.valueOf(digits.charAt(dep));        for(int i=0;i&lt;hashMap.get(str).length();i++){            String s1=s+String.valueOf(hashMap.get(str).charAt(i));            backTrace(list,s1,digits,dep+1);        }    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长回文字符串</title>
    <link href="undefined2019/10/11/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>2019/10/11/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/</a></p><p>方法一：中心扩展法</p><p>遍历字符串，以每个字符为中心，判断以其为中心的最长回文串长度。记录最长回文串的起始位置。注意回文串长度分奇偶两种情况。</p><pre><code class="java">class Solution {    public String longestPalindrome(String s) {        if(s==null||s.length()&lt;1) return s;        //回文串左右位置        int left=0;int right=0;        for(int i=0;i&lt;s.length();i++){            //回文串长度为奇数            int len1=lengthOfHuiwen(s,i,i);            //长度为偶数            int len2=lengthOfHuiwen(s,i,i+1);            int len=Math.max(len1,len2);            if(len&gt;right-left){                left=i-(len+1)/2+1;                right=i+len/2;            }        }        return s.substring(left,right+1);    }    //left,right为中心字符串左右位置    public int lengthOfHuiwen(String s,int left,int right){        int L=left,R=right;        while(L&gt;=0&amp;&amp;R&lt;s.length()&amp;&amp;s.charAt(L)==s.charAt(R)){            L--;            R++;        }        return R-L-1;    }}</code></pre><p>方法二：动态规划</p><pre><code>（一）状态    f[i][j]表示s的第 i 个字符到第 j 个字符组成的子串，是否为回文串（二）转移方程    如果s的第 i 个字符和第 j 个字符相同的话，且 i + 1, 到 j - 1 的子串也是回文串的话，f[i][j] 也为回文串        f[i][j] = f[i + 1][j - 1] and s[i] == s[j]    稍微要注意的是，如果 i == j 或者 i + 1 == j 的时候，也就是单个字符的子串和两个相邻字符的子串，就不需要f[i + 1][j - 1]了    注意遍历顺序，i 从最后一个字符开始往前遍历，j 从 i 开始往后遍历，这样可以保证每个子问题都已经算好了。</code></pre><pre><code class="java">class Solution {    public String longestPalindrome(String s) {        int n=s.length();        if(n&lt;1||s==null) return s;        String res=&quot;&quot;;        boolean[][] flag=new boolean[n][n];        for(int i=n-1;i&gt;=0;i--){            for(int j=i;j&lt;n;j++){            if(s.charAt(i)==s.charAt(j)&amp;&amp;(j-i&lt;=1||flag[i+1][j-1])){                    flag[i][j]=true;                    if(res.length()&lt;j-i+1)                        res=s.substring(i,j+1);                }            }        }        return res;    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC连接池&amp; JDBCTemplate</title>
    <link href="undefined2019/10/10/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <url>2019/10/10/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><ol><li><p>概念：其实就是一个容器(集合)，存放数据库连接的容器。</p><pre><code> 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</code></pre></li><li><p>好处：</p><ol><li>节约资源</li><li>用户访问高效</li></ol></li><li><p>实现：</p><ol><li><p>标准接口：DataSource   javax.sql包下的</p><ol><li>方法：<ul><li>获取连接：getConnection()</li><li>归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接</li></ul></li></ol></li><li><p>一般我们不去实现它，有数据库厂商来实现</p><ol><li>C3P0：数据库连接池技术</li><li>Druid：数据库连接池实现技术，由阿里巴巴提供的</li></ol></li></ol></li><li><p>C3P0：数据库连接池技术</p><ul><li><p>步骤：</p><ol><li><p>导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，</p><ul><li>不要忘记导入数据库驱动jar包</li></ul></li><li><p>定义配置文件：</p><ul><li>名称： c3p0.properties 或者 c3p0-config.xml</li><li>路径：直接将文件放在src目录下即可。</li></ul></li><li><p>创建核心对象 数据库连接池对象 ComboPooledDataSource</p></li><li><p>获取连接： getConnection</p></li></ol></li><li><p>代码：<br>   //1.创建数据库连接池对象<br>  DataSource ds  = new ComboPooledDataSource();<br>  //2. 获取连接对象<br>  Connection conn = ds.getConnection();</p></li></ul></li><li><p>Druid：数据库连接池实现技术，由阿里巴巴提供的</p><ol><li>步骤：<ol><li>导入jar包 druid-1.0.9.jar</li><li>定义配置文件：<ul><li>是properties形式的</li><li>可以叫任意名称，可以放在任意目录下</li></ul></li><li>加载配置文件。Properties</li><li>获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory</li><li>获取连接：getConnection</li></ol></li></ol></li></ol><pre><code class="java">        * 代码：         //3.加载配置文件        Properties pro = new Properties();        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);        pro.load(is);        //4.获取连接池对象        DataSource ds = DruidDataSourceFactory.createDataSource(pro);        //5.获取连接        Connection conn = ds.getConnection();    2. 定义工具类        1. 定义一个类 JDBCUtils        2. 提供静态代码块加载配置文件，初始化连接池对象        3. 提供方法            1. 获取连接方法：通过数据库连接池获取连接            2. 释放资源            3. 获取连接池的方法</code></pre><pre><code class="java">    * 代码：        public class JDBCUtils {            //1.定义成员变量 DataSource            private static DataSource ds ;            static{                try {                    //1.加载配置文件                    Properties pro = new Properties();                    pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));                    //2.获取DataSource                    ds = DruidDataSourceFactory.createDataSource(pro);                } catch (IOException e) {                    e.printStackTrace();                } catch (Exception e) {                    e.printStackTrace();                }            }            /**             * 获取连接             */            public static Connection getConnection() throws SQLException {                return ds.getConnection();            }            /**             * 释放资源             */            public static void close(Statement stmt,Connection conn){               /* if(stmt != null){                    try {                        stmt.close();                    } catch (SQLException e) {                        e.printStackTrace();                    }                }                if(conn != null){                    try {                        conn.close();//归还连接                    } catch (SQLException e) {                        e.printStackTrace();                    }                }*/               close(null,stmt,conn);            }</code></pre><p>​                            </p><pre><code class="java">   public static void close(ResultSet rs , Statement stmt, Connection conn){               if(rs != null){                    try {                        rs.close();                    } catch (SQLException e) {                        e.printStackTrace();                    }                }              if(stmt != null){                    try {                        stmt.close();                    } catch (SQLException e) {                        e.printStackTrace();                    }                }                if(conn != null){                    try {                        conn.close();//归还连接                    } catch (SQLException e) {                        e.printStackTrace();                    }                }            }            /**             * 获取连接池方法             */            public static DataSource getDataSource(){                return  ds;            }        }</code></pre><h2 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h2><ul><li><p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p></li><li><p>步骤：</p><ol><li><p>导入jar包</p></li><li><p>创建JdbcTemplate对象。依赖于数据源DataSource</p><ul><li>JdbcTemplate template = new JdbcTemplate(ds);</li></ul></li><li><p>调用JdbcTemplate的方法来完成CRUD的操作</p><ul><li>update():执行DML语句。增、删、改语句</li><li>queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合<ul><li>注意：这个方法查询的结果集长度只能是1</li></ul></li><li>queryForList():查询结果将结果集封装为list集合<ul><li>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</li></ul></li><li>query():查询结果，将结果封装为JavaBean对象<ul><li>query的参数：RowMapper<ul><li>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</li><li>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</li></ul></li></ul></li><li>queryForObject：查询结果，将结果封装为对象<ul><li>一般用于聚合函数的查询</li></ul></li></ul></li></ol></li></ul><pre><code class="java">    4. 练习：        * 需求：            1. 修改1号数据的 salary 为 10000            2. 添加一条记录            3. 删除刚才添加的记录            4. 查询id为1的记录，将其封装为Map集合            5. 查询所有记录，将其封装为List            6. 查询所有记录，将其封装为Emp对象的List集合            7. 查询总记录数        * 代码：            import cn.itcast.domain.Emp;            import cn.itcast.utils.JDBCUtils;            import org.junit.Test;            import org.springframework.jdbc.core.BeanPropertyRowMapper;            import org.springframework.jdbc.core.JdbcTemplate;            import org.springframework.jdbc.core.RowMapper;            import java.sql.Date;            import java.sql.ResultSet;            import java.sql.SQLException;            import java.util.List;            import java.util.Map;            public class JdbcTemplateDemo2 {                //Junit单元测试，可以让方法独立执行</code></pre><p>​                </p><pre><code class="java">                //1. 获取JDBCTemplate对象                private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());                /**                 * 1. 修改1号数据的 salary 为 10000                 */                @Test                public void test1(){                    //2. 定义sql                    String sql = &quot;update emp set salary = 10000 where id = 1001&quot;;                    //3. 执行sql                    int count = template.update(sql);                    System.out.println(count);                }                /**                 * 2. 添加一条记录                 */                @Test                public void test2(){                    String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;                    int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);                    System.out.println(count);                }                /**                 * 3.删除刚才添加的记录                 */                @Test                public void test3(){                    String sql = &quot;delete from emp where id = ?&quot;;                    int count = template.update(sql, 1015);                    System.out.println(count);                }                /**                 * 4.查询id为1001的记录，将其封装为Map集合                 * 注意：这个方法查询的结果集长度只能是1                 */                @Test                public void test4(){                    String sql = &quot;select * from emp where id = ? or id = ?&quot;;                    Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);                    System.out.println(map);                    //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20}                }                /**                 * 5. 查询所有记录，将其封装为List                 */                @Test                public void test5(){                    String sql = &quot;select * from emp&quot;;                    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);                    for (Map&lt;String, Object&gt; stringObjectMap : list) {                        System.out.println(stringObjectMap);                    }                }                /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                @Test                public void test6(){                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() {                        @Override                        public Emp mapRow(ResultSet rs, int i) throws SQLException {                            Emp emp = new Emp();                            int id = rs.getInt(&quot;id&quot;);                            String ename = rs.getString(&quot;ename&quot;);                            int job_id = rs.getInt(&quot;job_id&quot;);                            int mgr = rs.getInt(&quot;mgr&quot;);                            Date joindate = rs.getDate(&quot;joindate&quot;);                            double salary = rs.getDouble(&quot;salary&quot;);                            double bonus = rs.getDouble(&quot;bonus&quot;);                            int dept_id = rs.getInt(&quot;dept_id&quot;);                            emp.setId(id);                            emp.setEname(ename);                            emp.setJob_id(job_id);                            emp.setMgr(mgr);                            emp.setJoindate(joindate);                            emp.setSalary(salary);                            emp.setBonus(bonus);                            emp.setDept_id(dept_id);                            return emp;                        }                    });</code></pre><p>​                </p><pre><code class="java">                    for (Emp emp : list) {                        System.out.println(emp);                    }                }                /**                 * 6. 查询所有记录，将其封装为Emp对象的List集合                 */                @Test                public void test6_2(){                    String sql = &quot;select * from emp&quot;;                    List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));                    for (Emp emp : list) {                        System.out.println(emp);                    }                }                /**                 * 7. 查询总记录数                 */                @Test                public void test7(){                    String sql = &quot;select count(id) from emp&quot;;                    Long total = template.queryForObject(sql, Long.class);                    System.out.println(total);                }            }</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC基础</title>
    <link href="undefined2019/10/10/JDBC%E5%9F%BA%E7%A1%80/"/>
    <url>2019/10/10/JDBC%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h2><ol><li><p>概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库</p><ul><li>JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</li></ul></li><li><p>快速入门：</p><ul><li>步骤：<ol><li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar<br> 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下<br> 2.右键–&gt;Add As Library</li><li>注册驱动</li><li>获取数据库连接对象 Connection</li><li>定义sql</li><li>获取执行sql语句的对象 Statement</li><li>执行sql，接受返回结果</li><li>处理结果</li><li>释放资源</li></ol></li></ul></li></ol><pre><code class="java">{r tidy=FALSE}    * 代码实现：          //1. 导入驱动jar包        //2.注册驱动        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //3.获取数据库连接对象        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);        //4.定义sql语句        String sql = &quot;update account set balance = 500 where id = 1&quot;;        //5.获取执行sql的对象 Statement        Statement stmt = conn.createStatement();        //6.执行sql        int count = stmt.executeUpdate(sql);        //7.处理结果        System.out.println(count);        //8.释放资源        stmt.close();        conn.close();3. 详解各个对象：    1. DriverManager：驱动管理对象        * 功能：            1. 注册驱动：告诉程序该使用哪一个数据库驱动jar                static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。                 写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块                 static {                        try {                            java.sql.DriverManager.registerDriver(new Driver());                        } catch (SQLException E) {                            throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);                        }                    }                注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。            2. 获取数据库连接：                * 方法：static Connection getConnection(String url, String user, String password)                 * 参数：                    * url：指定连接的路径                        * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称                        * 例子：jdbc:mysql://localhost:3306/db3                        * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称                    * user：用户名                    * password：密码     2. Connection：数据库连接对象        1. 功能：            1. 获取执行sql 的对象                * Statement createStatement()                * PreparedStatement prepareStatement(String sql)              2. 管理事务：                * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务                * 提交事务：commit()                 * 回滚事务：rollback()     3. Statement：执行sql的对象        1. 执行sql            1. boolean execute(String sql) ：可以执行任意的sql 了解             2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句                * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。            3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句        2. 练习：            1. account表 添加一条记录            2. account表 修改记录            3. account表 删除一条记录            代码：                Statement stmt = null;                Connection conn = null;                try {                    //1. 注册驱动                    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                    //2. 定义sql                    String sql = &quot;insert into account values(null,&#39;王五&#39;,3000)&quot;;                    //3.获取Connection对象                    conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;);                    //4.获取执行sql的对象 Statement                    stmt = conn.createStatement();                    //5.执行sql                    int count = stmt.executeUpdate(sql);//影响的行数                    //6.处理结果                    System.out.println(count);                    if(count &gt; 0){                        System.out.println(&quot;添加成功！&quot;);                    }else{                        System.out.println(&quot;添加失败！&quot;);                    }                } catch (ClassNotFoundException e) {                    e.printStackTrace();                } catch (SQLException e) {                    e.printStackTrace();                }finally {                    //stmt.close();                    //7. 释放资源                    //避免空指针异常                    if(stmt != null){                        try {                            stmt.close();                        } catch (SQLException e) {                            e.printStackTrace();                        }                    }                    if(conn != null){                        try {                            conn.close();                        } catch (SQLException e) {                            e.printStackTrace();                        }                    }                }    4. ResultSet：结果集对象,封装查询结果        * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true        * getXxx(参数):获取数据            * Xxx：代表数据类型   如： int getInt() ,    String getString()            * 参数：                1. int：代表列的编号,从1开始   如： getString(1)                2. String：代表列名称。 如： getDouble(&quot;balance&quot;)        * 注意：            * 使用步骤：                1. 游标向下移动一行                2. 判断是否有数据                3. 获取数据               //循环判断游标是否是最后一行末尾。                while(rs.next()){                    //获取数据                    //6.2 获取数据                    int id = rs.getInt(1);                    String name = rs.getString(&quot;name&quot;);                    double balance = rs.getDouble(3);                    System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);                }        * 练习：            * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。                1. 定义Emp类                2. 定义方法 public List&lt;Emp&gt; findAll(){}                3. 实现方法 select * from emp;</code></pre><ol start="5"><li><p>PreparedStatement：执行sql</p><ol><li><p>SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</p><p> 输入用户随便，输入密码：’a’ or ‘a’ = ‘a’</p><p> sql：select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’</p></li><li><p>解决sql注入问题：使用PreparedStatement对象来解决</p></li><li><p>预编译的SQL：参数使用?作为占位符</p></li><li><p>步骤：</p><ol><li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</li><li>注册驱动</li><li>获取数据库连接对象 Connection</li><li>定义sql<ul><li>注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;</li></ul></li><li>获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql) </li><li>给？赋值：<ul><li>方法： setXxx(参数1,参数2)<pre><code>* 参数1：？的位置编号 从1 开始* 参数2：？的值</code></pre></li></ul></li><li>执行sql，接受返回结果，不需要传递sql语句</li><li>处理结果</li><li>释放资源</li></ol></li><li><p>注意：后期都会使用PreparedStatement来完成增删改查的所有操作</p><ol><li>可以防止SQL注入</li><li>效率更高</li></ol></li></ol></li></ol><h2 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h2><ul><li>目的：简化书写</li><li>分析：<ol><li>注册驱动也抽取</li><li>抽取一个方法获取连接对象<ul><li>需求：不想传递参数（麻烦），还得保证工具类的通用性。</li><li>解决：配置文件<br>  jdbc.properties<pre><code>  url=  user=  password=</code></pre></li></ul></li><li>抽取一个方法释放资源</li></ol></li></ul><pre><code class="java">    * 代码实现：    public class JDBCUtils {    private static String url;    private static String user;    private static String password;    private static String driver;    /**     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块     */    static{        //读取资源文件，获取值。        try {            //1. 创建Properties集合类。            Properties pro = new Properties();            //获取src路径下的文件的方式---&gt;ClassLoader 类加载器            ClassLoader classLoader = JDBCUtils.class.getClassLoader();            URL res  = classLoader.getResource(&quot;jdbc.properties&quot;);            String path = res.getPath();            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties            //2. 加载文件           // pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));            pro.load(new FileReader(path));            //3. 获取数据，赋值            url = pro.getProperty(&quot;url&quot;);            user = pro.getProperty(&quot;user&quot;);            password = pro.getProperty(&quot;password&quot;);            driver = pro.getProperty(&quot;driver&quot;);            //4. 注册驱动            Class.forName(driver);        } catch (IOException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }</code></pre><p>​    </p><pre><code class="java">    /**     * 获取连接     * @return 连接对象     */    public static Connection getConnection() throws SQLException {        return DriverManager.getConnection(url, user, password);    }    /**     * 释放资源     * @param stmt     * @param conn     */    public static void close(Statement stmt,Connection conn){        if( stmt != null){            try {                stmt.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if( conn != null){            try {                conn.close();            } catch (SQLException e) {                e.printStackTrace();            }        }    }</code></pre><p>​    </p><pre><code class="java">    /**     * 释放资源     * @param stmt     * @param conn     */    public static void close(ResultSet rs,Statement stmt, Connection conn){        if( rs != null){            try {                rs.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if( stmt != null){            try {                stmt.close();            } catch (SQLException e) {                e.printStackTrace();            }        }        if( conn != null){            try {                conn.close();            } catch (SQLException e) {                e.printStackTrace();            }        }    }}* 练习：    * 需求：        1. 通过键盘录入用户名和密码        2. 判断用户是否登录成功            * select * from user where username = &quot;&quot; and password = &quot;&quot;;            * 如果这个sql有查询结果，则成功，反之，则失败    * 步骤：        1. 创建数据库表 user            CREATE TABLE USER(                id INT PRIMARY KEY AUTO_INCREMENT,                username VARCHAR(32),                PASSWORD VARCHAR(32)            );            INSERT INTO USER VALUES(NULL,&#39;zhangsan&#39;,&#39;123&#39;);            INSERT INTO USER VALUES(NULL,&#39;lisi&#39;,&#39;234&#39;);        2. 代码实现：            public class JDBCDemo9 {                public static void main(String[] args) {                    //1.键盘录入，接受用户名和密码                    Scanner sc = new Scanner(System.in);                    System.out.println(&quot;请输入用户名：&quot;);                    String username = sc.nextLine();                    System.out.println(&quot;请输入密码：&quot;);                    String password = sc.nextLine();                    //2.调用方法                    boolean flag = new JDBCDemo9().login(username, password);                    //3.判断结果，输出不同语句                    if(flag){                        //登录成功                        System.out.println(&quot;登录成功！&quot;);                    }else{                        System.out.println(&quot;用户名或密码错误！&quot;);                    }               }    </code></pre><pre><code class="java">                /**                 * 登录方法                 */                public boolean login(String username ,String password){                    if(username == null || password == null){                        return false;                    }                    //连接数据库判断是否登录成功                    Connection conn = null;                    Statement stmt =  null;                    ResultSet rs = null;                    //1.获取连接                    try {                        conn =  JDBCUtils.getConnection();                        //2.定义sql                        String sql = &quot;select * from user where username = &#39;&quot;+username+&quot;&#39; and password = &#39;&quot;+password+&quot;&#39; &quot;;                        //3.获取执行sql的对象                        stmt = conn.createStatement();                        //4.执行查询                        rs = stmt.executeQuery(sql);                        //5.判断                       /* if(rs.next()){//如果有下一行，则返回true                            return true;                        }else{                            return false;                        }*/                       return rs.next();//如果有下一行，则返回true                    } catch (SQLException e) {                        e.printStackTrace();                    }finally {                        JDBCUtils.close(rs,stmt,conn);                    }                        return false;                }            }</code></pre><p>​                </p><h2 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h2><ol><li>事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</li><li>操作：<ol><li>开启事务</li><li>提交事务</li><li>回滚事务</li></ol></li><li>使用Connection对象来管理事务<ul><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务<ul><li>在执行sql之前开启事务</li></ul></li><li>提交事务：commit() <ul><li>当所有sql都执行完提交事务</li></ul></li><li>回滚事务：rollback() <ul><li>在catch中回滚事务</li></ul></li></ul></li></ol><pre><code class="java">4. 代码：    public class JDBCDemo10 {        public static void main(String[] args) {            Connection conn = null;            PreparedStatement pstmt1 = null;            PreparedStatement pstmt2 = null;            try {                //1.获取连接                conn = JDBCUtils.getConnection();                //开启事务                conn.setAutoCommit(false);                //2.定义sql                //2.1 张三 - 500                String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;;                //2.2 李四 + 500                String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;;                //3.获取执行sql对象                pstmt1 = conn.prepareStatement(sql1);                pstmt2 = conn.prepareStatement(sql2);                //4. 设置参数                pstmt1.setDouble(1,500);                pstmt1.setInt(2,1);                pstmt2.setDouble(1,500);                pstmt2.setInt(2,2);                //5.执行sql                pstmt1.executeUpdate();                // 手动制造异常                int i = 3/0;                pstmt2.executeUpdate();                //提交事务                conn.commit();            } catch (Exception e) {                //事务回滚                try {                    if(conn != null) {                        conn.rollback();                    }                } catch (SQLException e1) {                    e1.printStackTrace();                }                e.printStackTrace();            }finally {                JDBCUtils.close(pstmt1,conn);                JDBCUtils.close(pstmt2,null);            } }        }</code></pre><p>​        </p><p>​            </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go(三)</title>
    <link href="undefined2019/10/03/Go-%E4%B8%89/"/>
    <url>2019/10/03/Go-%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><h4 id="3-1-数组"><a href="#3-1-数组" class="headerlink" title="3.1 数组"></a>3.1 数组</h4><pre><code class="go">var a [3]intvar q [3]int = [3]int{1, 2, 3}q := [...]int{1, 2, 3}  //长度由初始化值的个数来计算months := [...]string{1: &quot;January&quot;, /* ... */, 12: &quot;December&quot;}  //索引0自动初始化为空字符串</code></pre><p>数组类型可以直接比较（==），只有当两个数组所有元素都是相等的时候数组才是相等的。</p><h4 id="3-2-Slice"><a href="#3-2-Slice" class="headerlink" title="3.2 Slice"></a>3.2 Slice</h4><p>一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。</p><p>slice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。</p><p>slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较：</p><pre><code class="go">func equal(x, y []string) bool {    if len(x) != len(y) {        return false    }    for i := range x {        if x[i] != y[i] {            return false        }    }    return true}</code></pre><p>slice唯一合法的比较操作是和nil比较，内置的make函数创建一个指定元素类型、长度和容量的slice。</p><pre><code class="go">var s []int    // len(s) == 0, s == nils = nil        // len(s) == 0, s == nils = []int(nil) // len(s) == 0, s == nils = []int{}    // len(s) == 0, s != nilmake([]T, len)   //返回整个数组make([]T, len, cap) // same as make([]T, cap)[:len]</code></pre><h4 id="3-3-append函数"><a href="#3-3-append函数" class="headerlink" title="3.3 append函数"></a>3.3 append函数</h4><p>内置的append函数用于向slice追加元素</p><pre><code class="go">var runes []runefor _, r := range &quot;Hello, 世界&quot; {    runes = append(runes, r)}fmt.Printf(&quot;%q\n&quot;, runes) // &quot;[&#39;H&#39; &#39;e&#39; &#39;l&#39; &#39;l&#39; &#39;o&#39; &#39;,&#39; &#39; &#39; &#39;世&#39; &#39;界&#39;]&quot;</code></pre><p>copy函数可以方便地将一个slice复制另一个相同类型的slice。copy函数的第一个参数是要复制的目标slice，第二个参数是源slice。<code>copy(z, x)</code></p><pre><code class="go">var x []intx = append(x, 1)x = append(x, 2, 3)x = append(x, 4, 5, 6)x = append(x, x...) // append the slice x</code></pre><p>一个slice可以用来模拟一个stack。最初给定的空slice对应一个空的stack，然后可以使用append函数将新的值压入stack：</p><pre><code class="go">stack = append(stack, v) // push vtop := stack[len(stack)-1] // top of stackstack = stack[:len(stack)-1] // pop</code></pre><p>要删除slice中间的某个元素并保存原有的元素顺序，可以通过内置的copy函数将后面的子slice向前依次移动一位完成：</p><pre><code class="go">func remove(slice []int, i int) []int {    copy(slice[i:], slice[i+1:])    return slice[:len(slice)-1]}func main() {    s := []int{5, 6, 7, 8, 9}    fmt.Println(remove(s, 2)) // &quot;[5 6 8 9]&quot;}</code></pre><h4 id="3-4-Map"><a href="#3-4-Map" class="headerlink" title="3.4 Map"></a>3.4 Map</h4><p>在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。</p><pre><code class="go">ages := make(map[string]int) // mapping from strings to intsages := map[string]int{    &quot;alice&quot;:   31,    &quot;charlie&quot;: 34,}//创建空的mapmap[string]int{}//使用内置的delete函数可以删除元素delete(ages, &quot;alice&quot;) // remove element ages[&quot;alice&quot;]</code></pre><p>map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作，原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</p><pre><code class="go">_ = &amp;ages[&quot;bob&quot;] // compile error: cannot take address of map element</code></pre><p><strong>遍历map</strong></p><pre><code class="go">for name, age := range ages {    fmt.Printf(&quot;%s\t%d\n&quot;, name, age)}</code></pre><p>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。如果要按顺序遍历key/value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序。</p><pre><code class="go">import &quot;sort&quot;var names []stringfor name := range ages {    names = append(names, name)}sort.Strings(names)for _, name := range names {    fmt.Printf(&quot;%s\t%d\n&quot;, name, ages[name])}</code></pre><pre><code class="go">age, ok := ages[&quot;bob&quot;]//在这种场景下，map的下标语法将产生两个值；第二个是一个布尔值，//用于报告元素是否真的存在。布尔变量一般命名为ok，特别适合马上用于if条件判断部分。</code></pre><p>Go语言没有提供set类型，可以用map实现set类型，</p><pre><code class="go">func main() {    seen := make(map[string]bool) // a set of strings    input := bufio.NewScanner(os.Stdin)    for input.Scan() {        line := input.Text()        if !seen[line] {            seen[line] = true            fmt.Println(line)        }    }    if err := input.Err(); err != nil {        fmt.Fprintf(os.Stderr, &quot;dedup: %v\n&quot;, err)        os.Exit(1)    }}</code></pre><h4 id="3-5-结构体"><a href="#3-5-结构体" class="headerlink" title="3.5 结构体"></a>3.5 结构体</h4><pre><code class="Go">type Employee struct {    ID        int    Name      string    Address   string    DoB       time.Time}var dilbert Employee</code></pre><p>结构体变量的成员可以通过点操作符访问，比如dilbert.Name和dilbert.DoB。赋值可以直接进行或者通过指针：</p><pre><code class="Go">name := &amp;dilbert.Name*name = &quot;Robin&quot;</code></pre><p>点操作符也可以和指向结构体的指针一起工作：</p><pre><code class="Go">var employeeOfTheMonth *Employee = &amp;dilbertemployeeOfTheMonth.Position += &quot; (proactive team player)&quot;//上面语句等价于(*employeeOfTheMonth).Position += &quot; (proactive team player)&quot;</code></pre><p>结构体成员的输入顺序也有重要的意义。交换Name和Address出现的先后顺序，那样的话就是定义了不同的结构体类型。如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个命名为S的结构体类型将不能再包含S类型的成员，但是S类型的结构体可以包含<code>*S</code>指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。</p><h5 id="3-5-1-结构体字面值"><a href="#3-5-1-结构体字面值" class="headerlink" title="3.5.1 结构体字面值"></a>3.5.1 结构体字面值</h5><pre><code class="Go">type Point struct{ X, Y int }p := Point{1, 2}q := Point{X:1,Y:2}    </code></pre><p>上面第一种写法，要求以结构体成员定义的顺序为每个结构体成员指定一个字面值。这个方法一般只在定义结构体的包内部使用，或者是在较小的结构体中使用。第二种方法是以成员名字和相应的值来初始化。结构体通常通过指针处理，可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址：</p><pre><code class="Go">pp := &amp;Point{1, 2}//等价于pp := new(Point)*pp = Point{1, 2}</code></pre><h5 id="3-5-2-结构体比较"><a href="#3-5-2-结构体比较" class="headerlink" title="3.5.2 结构体比较"></a>3.5.2 结构体比较</h5><p>如果结构体的全部成员都是可以比较的，那么这个结构体也是可以比较的，可以通过==或!=运算符进行比较。</p><pre><code class="Go">type Point struct{ X, Y int }p := Point{1, 2}q := Point{2, 1}fmt.Println(p.X == q.X &amp;&amp; p.Y == q.Y) // &quot;false&quot;fmt.Println(p == q)                   // &quot;false&quot;</code></pre><p>可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型。</p><pre><code class="Go">type address struct {    hostname string    port     int}hits := make(map[address]int)hits[address{&quot;golang.org&quot;, 443}]++</code></pre><h5 id="3-5-3-结构体嵌入和匿名变量"><a href="#3-5-3-结构体嵌入和匿名变量" class="headerlink" title="3.5.3 结构体嵌入和匿名变量"></a>3.5.3 结构体嵌入和匿名变量</h5><pre><code class="Go">type Point struct {    X, Y int}type Circle struct {    Center Point    Radius int}type Wheel struct {    Circle Circle    Spokes int}var w Wheelw.Circle.Center.X = 8w.Circle.Center.Y = 8w.Circle.Radius = 5w.Spokes = 20</code></pre><p>Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。得意于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径：</p><pre><code class="Go">type Circle struct {    Point    Radius int}type Wheel struct {    Circle    Spokes int}var w Wheelw.X = 8         // equivalent to w.Circle.Point.X = 8w.Y = 8         // equivalent to w.Circle.Point.Y = 8w.Radius = 5    // equivalent to w.Circle.Radius = 5w.Spokes = 20//匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。</code></pre><p>结构体字面值没有简短表示匿名成员的语法，所以必须遵循形状类型声明时的结构，按照以下方式赋值：</p><pre><code class="Go">w = Wheel{Circle{Point{8, 8}, 5}, 20}w = Wheel{    Circle: Circle{        Point:  Point{X: 8, Y: 8},        Radius: 5,    },    Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)}</code></pre><p>因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。同时，因为成员的名字是由其类型隐式地决定的，所有匿名成员也有可见性的规则约束。在上面的例子中，Point和Circle匿名成员都是导出的。即使它们不导出（比如改成小写字母开头的point和circle），我们依然可以用简短形式访问匿名成员嵌套的成员，但是在包外部，这是不允许的。</p><pre><code class="Go">w.X = 8 // equivalent to w.circle.point.X = 8</code></pre><h4 id="3-6-JSON-encoding-json包"><a href="#3-6-JSON-encoding-json包" class="headerlink" title="3.6 JSON(encoding/json包)"></a>3.6 JSON(encoding/json包)</h4><pre><code class="Go">type Movie struct {    Title  string    Year   int  `json:&quot;released&quot;`    Color  bool `json:&quot;color,omitempty&quot;`    Actors []string}var movies = []Movie{    {Title: &quot;Casablanca&quot;, Year: 1942, Color: false,        Actors: []string{&quot;Humphrey Bogart&quot;, &quot;Ingrid Bergman&quot;}},    {Title: &quot;Cool Hand Luke&quot;, Year: 1967, Color: true,        Actors: []string{&quot;Paul Newman&quot;}},    {Title: &quot;Bullitt&quot;, Year: 1968, Color: true,        Actors: []string{&quot;Steve McQueen&quot;, &quot;Jacqueline Bisset&quot;}},    // ...}</code></pre><p>结构体声明中，Year和Color成员后面的字符串面值是结构体成员的Tag。将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）。编组通过调用json.Marshal函数完成：</p><pre><code class="Go">data, err := json.Marshal(movies)if err != nil {    log.Fatalf(&quot;JSON marshaling failed: %s&quot;, err)}fmt.Printf(&quot;%s\n&quot;, data)</code></pre><p>Marshal函数返还一个编码后的字节slice，包含很长的字符串，并且没有空白缩进。这种紧凑的表示形式虽然包含了全部的信息，但是很难阅读。为了生成便于阅读的格式，另一个json.MarshalIndent函数将产生整齐缩进的输出。该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进。</p><pre><code class="Go">data, err := json.MarshalIndent(movies, &quot;&quot;, &quot;    &quot;)if err != nil {    log.Fatalf(&quot;JSON marshaling failed: %s&quot;, err)}fmt.Printf(&quot;%s\n&quot;, data)//输出格式[    {        &quot;Title&quot;: &quot;Casablanca&quot;,        &quot;released&quot;: 1942,        &quot;Actors&quot;: [            &quot;Humphrey Bogart&quot;,            &quot;Ingrid Bergman&quot;        ]    },    ………………</code></pre><p>其中Year名字的成员在编码后变成了released，还有Color成员编码后变成了小写字母开头的color。这是因为构体成员Tag所导致的。结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:”value”键值对序列；因为值中含义双引号字符，因此成员Tag一般用原生字符串面值的形式书写。<strong>json开头键名</strong>对应的值用于控制encoding/json包的编码和解码的行为，并且encoding/…下面其它的包也遵循这个约定。成员Tag中json对应值的第一部分用于指定JSON对象的名字，Color成员的Tag还带了一个额外的omitempty选项，表示当Go语言结构体成员为空或零值时不生成JSON对象，如Casablanca的color成员变量值为false（零值），所以没有输出color成员。</p><p>解码操作是将JSON数据解码成Go语言的数据结构，通过<strong>json.Unmarshal</strong>函数完成。下面的代码将JSON格式的电影数据解码为一个结构体slice，结构体中只有Title成员。通过定义合适的Go语言数据结构，我们可以<strong>选择性地解码</strong>JSON中感兴趣的成员。当Unmarshal函数调用返回，slice将被只含有Title信息值填充，其它JSON成员将被忽略。</p><pre><code class="Go">var titles []struct{ Title string }if err := json.Unmarshal(data, &amp;titles); err != nil {    log.Fatalf(&quot;JSON unmarshaling failed: %s&quot;, err)}fmt.Println(titles) // &quot;[{Casablanca} {Cool Hand Luke} {Bullitt}]&quot;</code></pre><h4 id="3-7-文本和HTML模板"><a href="#3-7-文本和HTML模板" class="headerlink" title="3.7 文本和HTML模板"></a>3.7 文本和HTML模板</h4><p>text\template和html\template提供了一个将变量值填充到文本或HTML格式的模板的机制。</p><p>一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的<code></code>对象。大部分的字符串只是按字面值打印，但是对于actions部分将触发其它的行为。下面是一个简短的模板字符串。</p><pre><code class="Go">const templ = `{{.TotalCount}} issues:{{range .Items}}----------------------------------------Number: {{.Number}}User:   {{.User.Login}}Title:  {{.Title | printf "%.64s"}}Age:    {{.CreatedAt | daysAgo}} days{{end}}`</code></pre><pre><code>对于每一个action，都有一个当前值的概念，对应点操作符，写作“.”。模板中{{.TotalCount}}对应action将展开为结构体中TotalCount成员以默认的方式打印的值。模板中{{range .Items}}和{{end}}对应一个循环action，因此它们直接的内容可能会被展开多次，循环每次迭代的当前值对应当前的Items元素的值。</code></pre><p>在一个action中，<code>|</code>操作符表示将前一个表达式的结果作为后一个函数的输入，在Title这一行的action中，第二个操作是一个printf函数，是一个基于fmt.Sprintf实现的内置函数，所有模板都可以直接使用。</p><p>生成模板：template.New先创建并返回一个模板；Funcs方法将daysAgo等自定义函数注册到模板中，并返回模板；最后调用Parse函数分析模板。</p><pre><code class="Go">report, err := template.New(&quot;report&quot;).    Funcs(template.FuncMap{&quot;daysAgo&quot;: daysAgo}).    Parse(templ)if err != nil {    log.Fatal(err)}</code></pre><p><a href="https://books.studygolang.com/gopl-zh/ch4/ch4-06.html" target="_blank" rel="noopener">https://books.studygolang.com/gopl-zh/ch4/ch4-06.html</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go(四)</title>
    <link href="undefined2019/10/01/Go-%E5%9B%9B/"/>
    <url>2019/10/01/Go-%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="4-1-函数声明"><a href="#4-1-函数声明" class="headerlink" title="4.1 函数声明"></a>4.1 函数声明</h4><p>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。</p><pre><code class="go">func name(parameter-list) (result-list) {    body}</code></pre><p>如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。</p><pre><code class="go">func f(i, j, k int, s, t string)                 { /* ... */ }func f(i int, j int, k int,  s string, t string) { /* ... */ }</code></pre><pre><code class="go">func add(x int, y int) int   {return x + y}func sub(x, y int) (z int)   { z = x - y; return}func first(x int, _ int) int { return x }func zero(int, int) int      { return 0 }fmt.Printf(&quot;%T\n&quot;, add)   // &quot;func(int, int) int&quot;fmt.Printf(&quot;%T\n&quot;, sub)   // &quot;func(int, int) int&quot;fmt.Printf(&quot;%T\n&quot;, first) // &quot;func(int, int) int&quot;fmt.Printf(&quot;%T\n&quot;, zero)  // &quot;func(int, int) int&quot;</code></pre><p>在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。</p><p>遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符。</p><pre><code class="go">func Sin(x float64) float //implemented in assembly language</code></pre><h4 id="4-2-递归"><a href="#4-2-递归" class="headerlink" title="4.2 递归"></a>4.2 递归</h4><p>Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题。</p><h4 id="4-3-多返回值"><a href="#4-3-多返回值" class="headerlink" title="4.3 多返回值"></a>4.3 多返回值</h4><p>在Go中，一个函数可以返回多个值。我们已经在之前例子中看到，许多标准库中的函数返回2个值，一个是期望得到的返回值，另一个是函数出错时的错误信息。</p><p>调用多返回值函数时，返回给调用者的是一组值，调用者必须显式的将这些值分配给变量:</p><pre><code class="go">links, err := findLinks(url)links, _ := findLinks(url) // errors ignored</code></pre><p>当你调用接受多参数的函数时，可以将一个返回多参数的函数作为该函数的参数。虽然这很少出现在实际生产代码中，但这个特性在debug时很方便，我们只需要一条语句就可以输出所有的返回值。下面的代码是等价的。</p><pre><code class="Go">log.Println(findLinks(url))links, err := findLinks(url)log.Println(links, err)</code></pre><p>如果一个函数所有的返回值都显示变量名，那么该函数的return语句可以省略操作数，称之为base return。</p><pre><code class="go">func Count(num1,num2 int) (count1,count2 int,err error){    count1,count2:=num1,num2    err:=nil    return }</code></pre><h4 id="4-4-文件结尾错误EOF"><a href="#4-4-文件结尾错误EOF" class="headerlink" title="4.4 文件结尾错误EOF"></a>4.4 文件结尾错误EOF</h4><p>io包保证任何由文件结束引起的读取失败都返回同一个错误io.EOF，该错误在io包中定义：</p><pre><code class="Go">package ioimport &quot;errors&quot;// EOF is the error returned by Read when no more input is available.var EOF = errors.New(&quot;EOF&quot;)</code></pre><p>调用者只需通过简单的比较，就可以检测出这个错误。</p><pre><code class="Go">in := bufio.NewReader(os.Stdin)for {    r, _, err := in.ReadRune()    if err == io.EOF {        break // finished reading    }    if err != nil {        return fmt.Errorf(&quot;read failed:%v&quot;, err)    }}</code></pre><h4 id="4-5-函数值"><a href="#4-5-函数值" class="headerlink" title="4.5 函数值"></a>4.5 函数值</h4><p>在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被<strong>赋值给其他变量，传递给函数，从函数返回</strong>。对函数值（function value）的调用类似函数调用。</p><pre><code class="Go">func square(n int) int { return n * n }f := squarefmt.Println(f(3)) // &quot;9&quot;</code></pre><p>函数类型的零值是nil。调用值为nil的函数值会引起panic错误。函数可以和nil比较，但是函数之间是不可以比较的，不可以作为map的key。</p><p>函数值作为函数的参数，下面strings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者。</p><pre><code class="Go">func add1(r rune) rune { return r + 1 }//String.Map函数定义//func Map(mapping func(rune) rune, s string) stringfmt.Println(strings.Map(add1, &quot;HAL-9000&quot;)) // &quot;IBM.:111&quot;</code></pre><h4 id="4-6-匿名函数"><a href="#4-6-匿名函数" class="headerlink" title="4.6 匿名函数"></a>4.6 匿名函数</h4><p>函数值字面量是一种表达式，它的值被成为匿名函数（anonymous function）。函数字面量允许我们在使用函数时，再定义它。</p><pre><code class="Go">strings.Map(func(r rune) rune { return r + 1 }, &quot;HAL-9000&quot;)</code></pre><p>更为重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量：</p><pre><code class="Go">func squares() func() int {    var x int    return func() int {        x++        return x * x    }}func main() {    f := squares()    fmt.Println(f()) // &quot;1&quot;    fmt.Println(f()) // &quot;4&quot;    fmt.Println(f()) // &quot;9&quot;    fmt.Println(f()) // &quot;16&quot;}</code></pre><p>squares的例子证明，函数值不仅仅是一串代码，还记录了状态，其中的变量生命周期不由它的作用域决定。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。这就是<strong>函数值属于引用类型</strong>和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。</p><p>当匿名函数需要被递归调用时，我们必须首先声明一个变量，再将匿名函数赋值给这个变量。</p><pre><code class="Go">visitAll := func(items []string) {    // ...    visitAll(m[item]) // compile error: undefined: visitAll    // ...}</code></pre><h4 id="4-7-捕获迭代变量"><a href="#4-7-捕获迭代变量" class="headerlink" title="4.7 捕获迭代变量"></a>4.7 捕获迭代变量</h4><pre><code class="go">var rmdirs []func()for _, dir := range tempDirs() {    os.MkdirAll(dir, 0755)    rmdirs = append(rmdirs, func() {        os.RemoveAll(dir) // NOTE: incorrect!    })}for _, rmdir := range rmdirs {    rmdir() // clean up}</code></pre><p>上面代码是错误的，在该循环中生成的所有函数值都共享相同的循环变量，需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。所以后续的迭代会不断更新dir的值，当删除操作执行时，for循环已完成，dir中存储的值等于最后一次迭代的值。</p><p>通常，为了解决这个问题，我们会引入一个与循环变量同名的局部变量，作为循环变量的副本。</p><pre><code class="Go">for _, dir := range tempDirs() {    dir := dir // declares inner dir, initialized to outer dir    // ...}</code></pre><h4 id="4-8-可变参数"><a href="#4-8-可变参数" class="headerlink" title="4.8 可变参数"></a>4.8 可变参数</h4><p>参数数量可变的函数称为为可变参数函数。在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“…”，这表示该函数会接收任意数量的该类型参数。</p><pre><code class="Go">func sum(vals...int) int {    total := 0    for _, val := range vals {        total += val    }    return total}fmt.Println(sum())           // &quot;0&quot;fmt.Println(sum(3))          // &quot;3&quot;fmt.Println(sum(1, 2, 3, 4)) // &quot;10&quot;</code></pre><p>在上面的代码中，调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调函数。如果原始参数已经是切片类型，只需在最后一个参数后加上省略符。</p><pre><code class="Go">values := []int{1, 2, 3, 4}fmt.Println(sum(values...)) // &quot;10&quot;</code></pre><h4 id="4-9-Deferred函数"><a href="#4-9-Deferred函数" class="headerlink" title="4.9 Deferred函数"></a>4.9 Deferred函数</h4><p>在普通函数或方法前加上关键字defer，这时当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行。可以在一个函数中执行多条defer语句，他们执行顺序与声明顺序相反，类似于栈。</p><p>defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。</p><p>defer后的函数会在return或者异常后执行，可以用来记录函数返回值。同样可以避免函数出现异常返回，导致文件没有关闭，或者简化代码。</p><pre><code class="go">func CopyFile(dstName, srcName string) (written int64, err error) {src, err := os.Open(srcName)if err != nil {return}defer src.Close()dst, err := os.Create(dstName)if err != nil {return}defer dst.Close()return io.Copy(dst, src)}</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go(二)</title>
    <link href="undefined2019/09/26/Go-%E4%BA%8C/"/>
    <url>2019/09/26/Go-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h2><h4 id="2-1-整形"><a href="#2-1-整形" class="headerlink" title="2.1 整形"></a>2.1 整形</h4><pre><code class="go">*      /      %      &lt;&lt;       &gt;&gt;     &amp;       &amp;^+      -      |      ^==     !=     &lt;      &lt;=       &gt;      &gt;=&amp;&amp;||</code></pre><p>二元运算符有五种优先级。在同一个优先级，使用左优先结合规则，但是使用括号可以明确优先顺序，使用括号也可以用于提升优先级。在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此<code>-5%3</code>和<code>-5%-3</code>结果都是-2。除法运算符<code>/</code>的行为则依赖于操作数是否为全为整数，比如<code>5.0/4.0</code>的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。</p><pre><code class="go">&amp;      位运算 AND|      位运算 OR^      位运算 XOR&amp;^     位清空 (AND NOT)&lt;&lt;     左移&gt;&gt;     右移</code></pre><p>位操作运算符<code>^</code>作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反；位操作运算符<code>&amp;^</code>用于按位置零（AND NOT）：如果对应y中bit位为1的话, 表达式<code>z = x &amp;^ y</code>结果z的对应的bit位为0，否则z对应的bit位等于x相应的bit位的值。</p><p>任何大小的整数字面值都可以用以0开始的八进制格式书写，例如0666；或用以0x或0X开头的十六进制格式书写，例如0xdeadbeef。十六进制数字可以用大写或小写字母。</p><pre><code class="go">o := 0666fmt.Printf(&quot;%d %[1]o %#[1]o\n&quot;, o) // &quot;438 666 0666&quot;x := int64(0xdeadbeef)fmt.Printf(&quot;%d %[1]x %#[1]x %#[1]X\n&quot;, x)// Output:// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF</code></pre><p>通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的<code>[1]</code>副词告诉Printf函数再次使用第一个操作数。第二，%后的<code>#</code>副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。字符使用<code>%c</code>参数打印，或者是用<code>%q</code>参数打印带单引号的字符。</p><h4 id="2-2-浮点数"><a href="#2-2-浮点数" class="headerlink" title="2.2 浮点数"></a>2.2 浮点数</h4><p>float32、float64</p><p>很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分。</p><pre><code class="go">const Avogadro = 6.02214129e23  // 阿伏伽德罗常数</code></pre><p>用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。所有的这三个打印形式都可以指定打印的宽度和控制打印精度。</p><pre><code class="go">for x := 0; x &lt; 8; x++ {    fmt.Printf(&quot;x = %d e^x = %8.3f\n&quot;, x, math.Exp(float64(x)))}x = 5       e^x =  148.413x = 6       e^x =  403.429x = 7       e^x = 1096.633</code></pre><p>math包中有定义的特殊值：+Inf、-Inf、NAN（正负无穷，非数）。函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。</p><pre><code class="go">nan := math.NaN()fmt.Println(nan == nan, nan &lt; nan, nan &gt; nan) // &quot;false false false&quot;</code></pre><h4 id="2-3-复数"><a href="#2-3-复数" class="headerlink" title="2.3 复数"></a>2.3 复数</h4><p>Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的<strong>real</strong>和<strong>imag</strong>函数分别返回复数的实部和虚部：</p><pre><code class="go">var x complex128 = complex(1, 2) // 1+2ivar y complex128 = complex(3, 4) // 3+4ifmt.Println(x*y)                 // &quot;(-5+10i)&quot;fmt.Println(real(x*y))           // &quot;-5&quot;fmt.Println(imag(x*y))           // &quot;10&quot;</code></pre><p>math/cmplx包提供了复数处理的许多函数，例如求复数的平方根函数和求幂函数。</p><h4 id="2-4-布尔值"><a href="#2-4-布尔值" class="headerlink" title="2.4 布尔值"></a>2.4 布尔值</h4><p>布尔值可以和&amp;&amp;（AND）和||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值。</p><p><code>&amp;&amp;</code>的优先级比<code>||</code>高</p><p>布尔值并不会隐式转换为数字值0或1，反之亦然。</p><h4 id="2-5-字符串"><a href="#2-5-字符串" class="headerlink" title="2.5 字符串"></a>2.5 字符串</h4><p>支持切片，‘+’链接字符串，字符串是不可修改的，尝试修改字符串内部的字符是禁止的。</p><p>原生字符串使用反引号代替双引号，原生的字符串字面量多用于书写多行消息、HTML以及正则表达式。在原生的字符串面值中，没有转义操作；<strong>全部的内容都是字面的意思</strong>，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行。</p><pre><code class="go">const GoUsage = `Go is a tool for managing Go source code.Usage:    go command [arguments]...`</code></pre><p>strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。</p><pre><code class="go">//strings包func Contains(s, substr string) boolfunc Count(s, sep string) intfunc Fields(s string) []stringfunc HasPrefix(s, prefix string) boolfunc Index(s, sep string) intfunc Join(a []string, sep string) string//bytes包func Contains(b, subslice []byte) boolfunc Count(s, sep []byte) intfunc Fields(s []byte) [][]bytefunc HasPrefix(s, prefix []byte) boolfunc Index(s, sep []byte) intfunc Join(s [][]byte, sep []byte) []byte</code></pre><p>bytes包还提供了<strong>Buffer类型</strong>用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效的：</p><pre><code class="go">var buf bytes.Bufferbuf.WriteByte(&#39;[&#39;)buf.WriteRune(&#39;中&#39;)buf.WriteString(&quot;, d &quot;)</code></pre><p>strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。</p><h4 id="2-6-UTF-8"><a href="#2-6-UTF-8" class="headerlink" title="2.6 UTF-8"></a>2.6 UTF-8</h4><p>UTF8编码使用1到4个字节来表示每个Unicode码点，ASCII部分字符只使用1个字节，常用字符部分使用2或3个字节表示。如果第一个字节的高端bit为0，则表示对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统的ASCII编码兼容。如果第一个字节的高端bit是110，则说明需要2个字节；后续的每个高端bit都以10开头。</p><pre><code>0xxxxxxx                             runes 0-127    (ASCII)110xxxxx 10xxxxxx                    128-2047       (values &lt;128 unused)1110xxxx 10xxxxxx 10xxxxxx           2048-65535     (values &lt;2048 unused)11110xxx 10xxxxxx 10xxxxxx 10xxxxxx  65536-0x10ffff (other values unused)</code></pre><pre><code>//Unicode转义字符让我们可以通过Unicode码点输入特殊的字符。下面是相同的字符串&quot;世界&quot;&quot;\xe4\xb8\x96\xe7\x95\x8c&quot;&quot;\u4e16\u754c&quot;&quot;\U00004e16\U0000754c&quot;</code></pre><pre><code class="go">import &quot;unicode/utf8&quot;s := &quot;Hello, 世界&quot;fmt.Println(len(s))                    // &quot;13&quot;fmt.Println(utf8.RuneCountInString(s)) // &quot;9&quot;</code></pre><p>Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串。</p><p>如果是将一个[]rune类型的Unicode字符slice或数组转为string，则对它们进行UTF8编码：</p><pre><code class="go">s := &quot;プログラム&quot;fmt.Printf(&quot;% x\n&quot;, s) // &quot;e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0&quot;r := []rune(s)fmt.Printf(&quot;%x\n&quot;, r)  // &quot;[30d7 30ed 30b0 30e9 30e0]&quot;fmt.Println(string(r)) // &quot;プログラム&quot;fmt.Println(string(65))     // &quot;A&quot;, not &quot;65&quot;fmt.Println(string(0x4eac)) // &quot;京&quot;fmt.Println(string(1234567)) // &quot;�&quot;（无效字符）fmt.Println(rune(&#39;你&#39;))//输出20320</code></pre><p>rune在golang中是int32的别名，在各个方面都与int32相同。可以将rune理解为一个可以表示Unicode编码的int值，称为码点。参考java中的char类型（可以和int运算）。</p><p>在Go中，双引号是用来表示字符串string，本质是[]byte类型，单引号表示rune类型。</p><h4 id="2-7-字符串和数字的转换"><a href="#2-7-字符串和数字的转换" class="headerlink" title="2.7 字符串和数字的转换"></a>2.7 字符串和数字的转换</h4><p>将一个整数转为字符串，一种方法是用fmt.Sprintf返回一个格式化的字符串；另一个方法是用strconv.Itoa(“整数到ASCII”)：</p><pre><code class="go">x := 123y := fmt.Sprintf(&quot;%d&quot;, x)fmt.Println(y, strconv.Itoa(x)) // &quot;123 123&quot;</code></pre><p>FormatInt和FormatUint函数可以用不同的进制来格式化数字：</p><pre><code class="go">fmt.Println(strconv.FormatInt(int64(x), 2)) // &quot;1111011&quot;</code></pre><p>fmt.Sprintf函数的%b、%d、%o和%x等参数提供功能往往比strconv包的Format函数方便很多，特别是在需要包含附加额外信息的时候：</p><pre><code class="go">s := fmt.Sprintf(&quot;x=%b&quot;, x) // &quot;x=1111011&quot;</code></pre><p>如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数：</p><pre><code class="go">x, err := strconv.Atoi(&quot;123&quot;)             // x is an inty, err := strconv.ParseInt(&quot;123&quot;, 10, 64) // base 10, up to 64 bitsfunc ParseInt(s string, base int, bitSize int) (i int64, err error)</code></pre><p>ParseInt函数的第三个参数是用于指定返回整型数的大小；例如16表示int16，0则表示int。第二个参数为数字字符串的进制。</p><p>int随系统而定，32位系统为int32</p><h4 id="2-8-常量"><a href="#2-8-常量" class="headerlink" title="2.8 常量"></a>2.8 常量</h4><p>批量声明</p><pre><code class="go">const (    e  = 2.7182818284590452    e1    pi = 3.1415926535897932    p3)//p3=pi,e1=e</code></pre><p><strong>iota 常量生成器</strong>:在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。</p><pre><code class="go">type Weekday intconst (    Sunday Weekday = iota    Monday    Tuesday    Wednesday    Thursday    Friday    Saturday)//周日将对应0，周一为1，如此等等const (    _ = 1 &lt;&lt; (10 * iota)    KiB // 1024    MiB // 1048576    GiB // 1073741824    TiB // 1099511627776             (exceeds 1 &lt;&lt; 32)    PiB // 1125899906842624    EiB // 1152921504606846976    ZiB // 1180591620717411303424    (exceeds 1 &lt;&lt; 64)    YiB // 1208925819614629174706176)</code></pre><h4 id="2-9-无类型常量"><a href="#2-9-无类型常量" class="headerlink" title="2.9 无类型常量"></a>2.9 无类型常量</h4><p>有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</p><p>math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：</p><pre><code class="go">var x float32 = math.Pivar y float64 = math.Pivar z complex128 = math.Pi</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go(一)</title>
    <link href="undefined2019/09/26/Go-%E4%B8%80/"/>
    <url>2019/09/26/Go-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h4 id="1-1命名"><a href="#1-1命名" class="headerlink" title="1.1命名"></a>1.1命名</h4><p>Go中函数名字的开头字母大小决定了该函数在包外的可见性：大写字母开头，这个函数在包外可以使用；小写字母开头不可以在包外部访问。Go语言程序员推荐使用 <strong>驼峰式</strong> 命名。</p><h4 id="1-2声明"><a href="#1-2声明" class="headerlink" title="1.2声明"></a>1.2声明</h4><p>var、const、type、func：变量、常量、类型、函数实体对象声明    </p><p>包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句。在包一级声明的名字可以在整个包和引用了该包的源文件中访问。</p><h4 id="1-3变量"><a href="#1-3变量" class="headerlink" title="1.3变量"></a>1.3变量</h4><pre><code class="go">var 变量名字 类型 = 表达式</code></pre><p>go语言中所有变量定义时如果未赋值，都会初始化为一个默认值。 </p><p>在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“<strong>名字 := 表达式</strong>”形式声明变量，变量的类型根据表达式来自动推导。</p><pre><code class="go">freq := rand.Float64() * 3.0t := 0.0i, j := 0, 1  //变量声明语句i, j = j, i // 交换 i 和 j 的值，赋值语句（元组赋值）</code></pre><p>简短变量声明语句中必须至少要声明一个新的变量，否则不能编译通过。</p><h4 id="1-4指针"><a href="#1-4指针" class="headerlink" title="1.4指针"></a>1.4指针</h4><p>如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时<code>*p</code>表达式对应p指针指向的变量的值。一般<code>*p</code>表达式读取指针指向的变量的值，这里为int类型的值，同时因为<code>*p</code>对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。</p><pre><code class="go">x := 1p := &amp;x         // p, of type *int, points to xfmt.Println(*p) // &quot;1&quot;*p = 2          // equivalent to x = 2fmt.Println(x)  // &quot;2&quot;*p++            // x=3,p仍然指向x</code></pre><p>指针的零值为<strong>nil</strong>，在Go语言中，返回函数中局部变量的地址也是安全的。</p><pre><code class="go">var p = f()func f() *int {    v := 1    return &amp;v}</code></pre><h4 id="1-5-new-函数"><a href="#1-5-new-函数" class="headerlink" title="1.5 new 函数"></a>1.5 new 函数</h4><p>表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code>。</p><pre><code class="go">p := new(int)  // p, *int 类型, 指向匿名的 int 变量fmt.Println(*p) // &quot;0&quot;//下面两个函数功能相同func newInt() *int {    return new(int)}func newInt() *int {    var dummy int    return &amp;dummy}</code></pre><p>由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。下面由于new被定义为int类型的变量名，因此在delta函数内部是无法使用内置的new函数的。</p><pre><code class="go">func delta(old, new int) int { return new - old }</code></pre><p>了解go语言自动垃圾回收器。</p><h4 id="1-6-类型"><a href="#1-6-类型" class="headerlink" title="1.6 类型"></a>1.6 类型</h4><pre><code class="go">type 类型名字 底层类型type Celsius float64    // 摄氏温度</code></pre><p>1.7下划线 ‘_’</p><pre><code class="go">//用在import//引入包，会先调用包中的初始化函数，这种使用方式仅让导入的包做初始化，而不使用包中其他功能import  _  &quot;net/http/pprof&quot;//用在返回值//表示忽略某个值。单函数有多个返回值，用来获取某个特定的值for _,v := range Slice{}_,err := func()//用在变量//上面用来判断 type T是否实现了I,用作类型断言，如果T没有实现借口I，则编译错误.type T struct{}var _ I = T{}其中 I为interface//用在函数定义中省略带名的参数func demo() ( int, int, string, int ,error)//返回多个参数时,尤其是类型相同的，不利于阅读，func demo() ( sumA int, sumB int, _ string, total int ,_ error)//返回参数 int 加了名字，对比上面,便于理解,但是 &quot;string&quot; 和 &quot;error&quot;没有名字，编译会报错，用下划线可以忽略命名</code></pre><h4 id="1-8-os-Args"><a href="#1-8-os-Args" class="headerlink" title="1.8 os.Args"></a>1.8 <strong>os.Args</strong></h4><p>由os包实现，用于给出程序运行时的参数。os.Args的类型是 <strong>[]string</strong> ，也就是字符串切片。所以可以在for循环的range中遍历，还可以用 <strong>len(os.Args)</strong> 来获取其数量。</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;os&quot;    &quot;strconv&quot;)func main () {    for idx, args := range os.Args {        fmt.Println(&quot;参数&quot; + strconv.Itoa(idx) + &quot;:&quot;, args)    }}//运行结果$go run main.go 1 3 -X ?参数0: /tmp/go-build116558042/command-line-arguments/_obj/exe/main参数1: 1参数2: 3参数3: -X参数4: ?//参数0为程序路径本身</code></pre><h4 id="1-9-flag包"><a href="#1-9-flag包" class="headerlink" title="1.9 flag包"></a>1.9 <strong>flag</strong>包</h4><p>使用flag包，首先定义待解析命令行参数，也就是以”-“开头的参数，比如这里的 -b -s -help等。-help不需要特别指定，可以自动处理。      </p><p>flag使用前，必须首先解析：<code>flag.Parse()</code> 。  参数中没有能够按照预定义的参数解析的部分，通过flag.Args()即可获取，是一个字符串切片。        </p><p>通过flag.Bool和flag.String，建立了2个指针b和s，分别指向bool类型和string类型的变量。所以后续要通过 <strong>*b</strong> 和 <strong>*s</strong> 使用变量值。</p><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;flag&quot;)//参数：命令行参数名称，默认值，提示字符串var b = flag.Bool(&quot;b&quot;, false, &quot;bool类型参数&quot;)var s = flag.String(&quot;s&quot;, &quot;&quot;, &quot;string类型参数&quot;)func main() {    flag.Parse()    fmt.Println(&quot;-b:&quot;, *b)    fmt.Println(&quot;-s:&quot;, *s)    fmt.Println(&quot;其他参数：&quot;, flag.Args())}------------------------------------$ go run main.go-b: false-s: 其他参数： []------------------------------------$ go run main.go -b-b: true-s: 其他参数： []------------------------------------$ go run main.go -b -s test others-b: true-s: test其他参数： [others]------------------------------------$ go run main.go  -helpUsage of /tmp/go-build080353851/command-line-arguments/_obj/exe/main:  -b    bool类型参数  -s string        string类型参数exit status 2</code></pre><h4 id="1-10-err"><a href="#1-10-err" class="headerlink" title="1.10 err"></a>1.10 <strong>err</strong></h4><p>error类型是一个接口类型，定义如下：</p><pre><code class="go">type error interface {    Error() string}</code></pre><p>可以通过实现error接口来生成错误信息，如果产生错误，就会生成一个non-nil的error对象，将此对象与nil比较，结果为true。</p><pre><code class="go">func Sqrt(f float64) (float64, error) {    if f &lt; 0 {        return 0, errors.New(&quot;math: square root of negative number&quot;)    }    // 实现}result, err:= Sqrt(-1)if err != nil {   fmt.Println(err)}</code></pre><h4 id="1-11-包的初始化和标准输入输出"><a href="#1-11-包的初始化和标准输入输出" class="headerlink" title="1.11 包的初始化和标准输入输出"></a>1.11 包的初始化和标准输入输出</h4><p><code>func init() { /* ... */ }</code></p><p>初始化函数在包调用时自动执行。</p><pre><code class="go">func main() {    input := bufio.NewScanner(os.Stdin)//初始化一个扫表对象    for input.Scan() {//扫描输入内容        line := input.Text()//把输入内容转换为字符串        fmt.Println(line)//输出到标准输出    }}</code></pre><h4 id="1-12-作用域"><a href="#1-12-作用域" class="headerlink" title="1.12 作用域"></a>1.12 作用域</h4><p>if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域。</p><pre><code class="go">if x := f(); x == 0 {    fmt.Println(x)} else if y := g(x); x == y {    fmt.Println(x, y)} else {    fmt.Println(x, y)}fmt.Println(x, y) // compile error: x and y are not visible here</code></pre><p>在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归引用了自身，则会产生编译错误。</p><pre><code class="go">var cwd string//使用声明语句，初始化的cwd为局部变量，导致全局变量cwd并未被初始化func init() {    cwd, err := os.Getwd() // NOTE: wrong!    if err != nil {        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)    }    log.Printf(&quot;Working directory = %s&quot;, cwd)}</code></pre><pre><code class="go">var cwd string//将err先定义，再使用赋值方法func init() {    var err error    cwd, err = os.Getwd()    if err != nil {        log.Fatalf(&quot;os.Getwd failed: %v&quot;, err)    }}</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java随笔--正则表达式</title>
    <link href="undefined2019/09/22/java-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>2019/09/22/java-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>题目地址：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p><pre><code class="java">import java.util.regex.*;class Solution {       public static int myAtoi(String str) {       str=str.trim();        String pattern=&quot;^[\\+\\-\\d]\\d*&quot;;//正则表达式，表示以正号或负号或数字开头，且后面是0个或多个数字        Pattern p=Pattern.compile(pattern);        Matcher m=p.matcher(str);        String res=&quot;&quot;;        if(m.find()){//能匹配到            res=str.substring(m.start(),m.end());        }else{//不能匹配到            return 0;        }        //能匹配到但只有一个+-号，也返回0        if(res.length()==1&amp;&amp;(res.charAt(0)==&#39;+&#39;||res.charAt(0)==&#39;-&#39;)){            return 0;        }        try{            int r=Integer.parseInt(res);            return r;        }catch(Exception e){            return res.charAt(0)==&#39;-&#39;?Integer.MIN_VALUE:Integer.MAX_VALUE;        }    }}</code></pre><p>在使用java正则表达式时要注意：java中”\\“表示”\“,”\\+”表示”+”,因为”+”需要转义，</p><h3 id="lookingAt"><a href="#lookingAt" class="headerlink" title="lookingAt()"></a>lookingAt()</h3><p>lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返回true </p><pre><code class="java">Pattern p=Pattern.compile(&quot;\\d+&quot;); Matcher m=p.matcher(&quot;22bb23&quot;); m.lookingAt();//返回true,因为\d+匹配到了前面的22 Matcher m2=p.matcher(&quot;aa2223&quot;); m2.lookingAt();//返回false,因为\d+不能匹配前面的aa </code></pre><h3 id="Mathcer-start-Matcher-end-Matcher-group"><a href="#Mathcer-start-Matcher-end-Matcher-group" class="headerlink" title="Mathcer.start()/ Matcher.end()/ Matcher.group()"></a><strong>Mathcer.start()/ Matcher.end()/ Matcher.group()</strong></h3><p>start()返回匹配到的子字符串在字符串中的索引位置.<br>end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置.<br>group()返回匹配到的子字符串 </p><p>start(),end(),group()均有一个重载方法它们是start(int i),end(int i),group(int i)专用于分组操作,Mathcer类还有一个groupCount()用于返回有多少组. </p><pre><code class="java">Pattern p=Pattern.compile(&quot;\\d+&quot;); Matcher m=p.matcher(&quot;我的QQ是:456456 我的电话是:0532214 我的邮箱是:aaa123@aaa.com&quot;); while(m.find()) {      System.out.println(m.group()); } 输出：456456 0532214 123  //或者   while(m.find()) {      System.out.println(m.group());      System.out.print(&quot;start:&quot;+m.start());      System.out.println(&quot; end:&quot;+m.end()); } 输出：456456 start:6 end:12 0532214 start:19 end:26 123 start:36 end:39 </code></pre><p>可以看出，每执行一次find()，matcher对应的分组都会自动加一。start(),end(),group()三个方法的值都会改变,匹配到的子字符串的信息,以及它们的重载方法,也会改变成相应的信息. </p><p>后面遇到有关正则表达式问题再进行补充。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql学习笔记（三）</title>
    <link href="undefined2019/09/21/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>2019/09/21/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>select 字段列表<br>form 表名<br>where 查询筛选条件<br>group by 指定分组的列列表<br>having 指定分组后的筛选条件<br>order by 排序列的列表<br>limit 起始索引值，要查询的记录条数</p><p>1、分组查询：group by<br>分组函数（聚合函数）：将多行的值进行统计返回一行结果<br>sum() ; avg();  min();  max(); count().<br>注：分组函数不能和与分组无关的列一起使用；<br>分组查询时，查询的列可以是分组的条件</p><pre><code>SELECT SUM(salary)，COUNT(eid)，did FROM t_employGROUP BY did;SELECT did,COUNT(eid)FROM t_employWHERE salary&gt;10000AND did IS NOT NULLGROUP BY did;   </code></pre><p>2、条件中需要使用分组后的结果:having作用和where一样，但是执行顺序在分组之后</p><pre><code>SELECT AVG(salary)FROM t_employGROUP BY didHAVING AVG(salary)&gt;9000;</code></pre><p>3、order by：降序排列desc，升序排列asc<br><code>SELECT * FROM t_employ ORDER BY salary DESC, eid ASC;</code></p><p>4、分页查询：limit index，size</p><p>5、子查询：当前查询依赖另一个查询的结果</p><pre><code>SELECT * FROM t_employ WHERE did=(        SELECT did FROM t_employ WHERE ename=&#39;罗宾&#39;)；</code></pre><p>三种类型：1、将子查询结果当做where查询的条件；2、当做临时表再次查询；3、作为主查询的判断条件，决定数据是否查询。<br>exists型子查询</p><p>6、复制表<br> 复制表结构：<code>CREATE TABLE t_emp AS(SELECT * FROM t_employ WHERE 1=2);</code><br>复制表结构+指定数据：where 条件 </p><p>7、单行函数：处理一行返回一行结果<br><code>SELECT UPPER(email) FROM t_employ;</code><br>password():mysql数据库在将数据库管理员的信息进行保存时，会将密码加密保存。<br><code>SELECT PASSWORD(&#39;123456&#39;) FROM DUAL;   (dual练习表)</code></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql学习笔记（二）</title>
    <link href="undefined2019/09/21/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>2019/09/21/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>1、自增长：如果一列是主键，并且数据类型是int，则支持自动增长，每次插入数据时，会自动加一<br>表定义时加上</p><p><code>id INT(11) PRIMARY KEY AUTO_INCREMENT；</code></p><p>2、给查询到的列取别名，表也可以取别名<br><code>SELECT 列名 AS ‘别  名’，列名 别名，…… FROM 表名</code><br>3、去重复：将查询到的所有列的重复筛选掉<br><code>SELECT DISTINCT 列名 FROM 表名</code></p><p>4、查询时 进行计算<br>支持数学运算符，逻辑运算符：xor异或<br>比较运算符：=，&gt;,&lt;,&gt;=,&lt;=<br>集合：in(值列表)<br>范围：between min and max</p><p>5、模糊查询:like ‘模糊字符串’<br>%:代表0~n个任意字符<br>_：代表一个任意字符</p><p>6、使用 ifnull(字段，默认值) 方法解决null值计算问题</p><p>7、字符串拼接时的null值（sql中的+不能拼接字符串）<br>concat（字段和字符串列表）：自动将方法内的所有字符串进行拼接处理</p><p>8、联合查询<br>多表查询时，需要指定连接条件才能避免笛卡尔积：表名.列名（指定是哪个表的列）<br>多表查询时，最少指定n-1个连接条件才能避免笛卡尔积</p><p>9、内连接（INNER JOIN）<br>sql99推荐多表连接使用：表1 join 表2 on 连接条件 join 表3 on 连接条件<br>INNER JOIN（只有满足条件的数据才能被查询）</p><p>10、外连接(左外连接：左表不满足条件的数据也查询出来，右外连接）<br>LEFT OUTER JOIN<br>全连接</p><p>11、自连接：当前表连接当前表，使用别名区分</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql学习笔记（一）</title>
    <link href="undefined2019/09/21/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>2019/09/21/Mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>DDL语句<br>1、建库  </p><pre><code>CREAT DATABASE  名字</code></pre><p>不区分大小写，推荐关键字大写；单词间加‘_’<br>mysql数据结构：char，varchar  </p><pre><code>CREATE TABLE tm_teammanager(         id INT(11),          &#39;name&#39;  VARCHAR(30),#通过飘号选中的字符会保留字符串本意，不会当成关键字，~          gender CHAR(2))</code></pre><p>2、查表结构  </p><pre><code>DESC tm_teammanager</code></pre><p>3、从删库到跑路<br>备份为.sql文件  </p><pre><code>DROP TABLE 表名  DROP DATABASE </code></pre><p>4、修改表名  </p><pre><code>ALTER TABLE oldname RENAME newname;</code></pre><p>5、给表添加一列  </p><pre><code>ALTER TABLE 表名  ADD COLUMN 名字 INT(3) (加上类型)</code></pre><p>6、删除表一列  </p><pre><code>ALTER TABLE 表名 DROP COLUMN 列名</code></pre><p>7、给一列重命名change  </p><pre><code>ALTER TABLE 表名 CHANGE 列名 新列名 数据类型</code></pre><p>8、修改表列的数据类型modify  </p><pre><code>ALTER TABLE 表名 MODIFY 列名 新数据类型</code></pre><p>DML语句<br>1、插入数据   </p><pre><code>INSERT INTO 表名 VALUES();  #必须给所有列指定值  INSERT INTO 表名(id,列名……)  VALUES(对应值);</code></pre><p>2、查询 select</p><p>3、修改数据 update  </p><pre><code>UPDATE 表名 SET 列名=值 WHERE id=2；</code></pre><p>4、删除 delete  </p><pre><code>DELETE FROM 表名  delete、drop、truncate区别</code></pre><p>约束 constrains<br>1、主键约束 primary key（字段值唯一非空）主键只能有一个<br>1.1添加主键：创建表时添加约束CONSTRAINT PRIMARY KEY(列名)<br>1.2 通过alter语句给表添加主键约束（表创建后添加）  </p><pre><code>ALTER TABLE 表名 DROP PRIMARY KEY; #先删除原有主键约束  ALTER TABLE 表名 ADD PRIMARY KEY(列名)  或 ALTER TABLE 表名 MODIFY …… PRIMARY KEY</code></pre><p>2、唯一键约束<br>2.1 创建时添加<br>2.2 修改表的指定列添加唯一键约束  </p><pre><code>ALTER TABLE ^ MODIFY ^ ^ UNIQUE;  </code></pre><p>删除唯一键约束  </p><pre><code>ALTER TABLE 表名 DROP INDEX 列名；  </code></pre><p>查看索引 SHOW INDEX FROM 表名</p><p>3、非空约束 not null<br>3.1创建表时添加  </p><pre><code>CREATE TABLE t_stu(  &amp;emsp;&amp;emsp;id INT(11) NOT NULL;  );  </code></pre><p>删除非空约束  </p><pre><code>alter table 表名 modify 列名 类型；</code></pre><p>3.2修改列添加非空约束  </p><pre><code>alter table 表名 modify 列名 类型 not null default “etc”；  </code></pre><p>4、默认值约束 default<br>5、外键约束<br>外键关联时，两张表建立外键的列数据类型必须相同，长度尽量一致</p><p>5.1修改表的指定列，添加外键约束  </p><pre><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY （当前表的指定列） references 关联的表名（指定要关联的列名）;ALTER TABLE t_stu ADD CONSTRAINT fk_cid FOREIGN KEY(cid) REFERENCES t_course(id);</code></pre><p>删除外键约束：删除外键，然后才能删除外键对应的索引  </p><pre><code>ALTER TEBLE 表名 DROP FOREIGN KEY(外键名)  ALTER TABLE 表名 DROP INDEX 外键名；  </code></pre><p>索引需要删除，否则影响效率</p><p>5.2创建表时添加  </p><pre><code>CONSTRAINT 外键名 FOREIGN KEY(列名) REFERENCES关联的表名（列名）</code></pre><p>5.3删除被其他表关联的数据：当没有其他表引用该行数据可以删除<br>5.4添加外键时指定级联删除或者级联置空</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unsupervised Video Summarization with Adversarial LSTM</title>
    <link href="undefined2019/09/21/3/"/>
    <url>2019/09/21/3/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本文提出一个由summarizer和discriminator组成的生成对抗框架。目的是选择视频的稀疏子集，使得视频和摘要的表示误差最小。</p><p><img src="/2019/09/21/3/1.png" srcset="/img/loading.gif" alt></p><p>&emsp;&emsp;原始视频的特征是通过GAN和LSTM提取的，GAN以像素为基础提取特征，LSTM捕捉帧之间的长期依赖关系，得到深度特征向量。由于明确深度特征间的合适距离困难，所以由左边结构转换为右边的结构。</p><p>论文理论基础：Variational Autoencoder(VAE)，GAN</p><h2 id="Model-Overview"><a href="#Model-Overview" class="headerlink" title="Model Overview"></a>Model Overview</h2><p><img src="/2019/09/21/3/2.png" srcset="/img/loading.gif" alt="模型结构示意图"><br>&emsp;&emsp;CNN输出的是视频帧的深度特征（deep features x），sLSTM（selector LSTM）在这些帧中选择一个子集，eLSTM(encoder LSTM)将选择的帧序列编码成向量 e 。sLSTM生成每一个帧的标准化重要性得分s，结合x，输入到eLSTM中。dLSTM(decoder LSTM)以e为输入，重构了输入视频的特征序列。鉴别器（discriminator）用来区分原始和摘要视频帧间的特征，用于估计两者之间的representation error。</p><p>&emsp;&emsp;本实验中使用二元序列分类器（a binary sequence classifier），所以鉴别器为cLSTM(classifier LSTM)，输出是二分类。</p><p><img src="/2019/09/21/3/3.png" srcset="/img/loading.gif" alt="模型训练示意图"></p><p><img src="/2019/09/21/3/4.png" srcset="/img/loading.gif" alt></p><p>&emsp;&emsp;生成对抗训练的关键是引入一个额外的帧选择器Sp（基于先验分布的，例如均匀分布）。利用概率Sp选择一个子集作为eLSTM的输入，以相同的pipeline生成一系列值，用于计算误差。</p><h3 id="Reconstruction-loss-Lreconst"><a href="#Reconstruction-loss-Lreconst" class="headerlink" title="Reconstruction loss Lreconst"></a>Reconstruction loss Lreconst</h3><p>&emsp;&emsp;没有采用传统的欧式距离，而是基于cLSTM的隐藏层表示。cLSTM最后一个隐藏层的输出**表示一个紧凑的特征向量，它捕捉了x（特征序列）的长距离依赖关系。Lre是对数似然的期望。</p><p><img src="/2019/09/21/3/5.png" srcset="/img/loading.gif" alt></p><h3 id="Loss-of-GAN"><a href="#Loss-of-GAN" class="headerlink" title="Loss of GAN"></a>Loss of GAN</h3><p>这里的先验分布使用均匀分布。<img src="/2019/09/21/3/6.png" srcset="/img/loading.gif" alt></p><p>&emsp;&emsp;cLSTM(·)是一个二元的softmax输出。更新参数使用随机梯度变分bayes估计（Stochastic Gradient Variational Bayes estimation）</p><p><img src="/2019/09/21/3/7.png" srcset="/img/loading.gif" alt="模型训练伪代码"></p><h3 id="正则化训练"><a href="#正则化训练" class="headerlink" title="正则化训练"></a>正则化训练</h3><h4 id="Summary-Length-Regularization"><a href="#Summary-Length-Regularization" class="headerlink" title="Summary-Length Regularization"></a>Summary-Length Regularization</h4><p><img src="/2019/09/21/3/8.png" srcset="/img/loading.gif" alt></p><p>M帧数量，*希望选择帧数量的百分比</p><h4 id="Diversity-Regularization"><a href="#Diversity-Regularization" class="headerlink" title="Diversity Regularization"></a>Diversity Regularization</h4><p><img src="/2019/09/21/3/9.png" srcset="/img/loading.gif" alt></p><p>基于DPP</p><p><img src="/2019/09/21/3/10.png" srcset="/img/loading.gif" alt></p><p>排斥正则化器（Repelling regularizer）</p><h4 id="Keyframe-Regularization"><a href="#Keyframe-Regularization" class="headerlink" title="Keyframe Regularization"></a>Keyframe Regularization</h4><p><img src="/2019/09/21/3/11.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视频摘要</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deep Reinforcement Learning for Unsupervised V-S </title>
    <link href="undefined2019/09/15/Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization/"/>
    <url>2019/09/15/Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization/</url>
    
    <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>&emsp;&emsp;本文创新点：1、构建DSN网络；2、设计一个新的奖励函数（基于帧的多样性和代表性）；3、设计一个端到端的、基于强化学习的框架来训练网络。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>&emsp;&emsp;DPP-LSTM效果较好，但是视频摘要的评价时，人类具有更多的主观性，所以非监督方法很有必要。<br>&emsp;&emsp;本文的DSN网络：encoder：CNN（在视频帧上进行特征提取）；decoder：BiLSTM（产生概率分布来选择帧）。RL（增强学习）：通过迭代方式训练agent。<br>&emsp;&emsp;主要贡献：将无监督方法扩展到监督版本，以利用标签；首次将RL应用到无监督视频摘要上。</p><p><img src="/2019/09/15/Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization/pasted-0.png" srcset="/img/loading.gif" alt></p><h2 id="Model-Overview"><a href="#Model-Overview" class="headerlink" title="Model Overview"></a>Model Overview</h2><h3 id="Deep-Summarization-Network"><a href="#Deep-Summarization-Network" class="headerlink" title="Deep Summarization Network"></a>Deep Summarization Network</h3><p>&emsp;&emsp;采用encoder-decoder结构，CNN选用在ImageNet上预训练好的GoogLeNet，从它倒数第二层提取出视觉特征向量x_{t}。LSTM用来捕获视频帧之间的长时间依赖性。训练中只更新decoder。  </p><p>&emsp;&emsp;将BiLSTM网络的正向和反向的隐藏层输出拼接作为相应的隐状态，网络输入为视觉特征向量。全连接层结束于sigmoid函数，得出每个帧选择的概率分布，帧是否选择服从二项分布。视频摘要由这些选择的帧组成。</p><p><img src="/2019/09/15/Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization/1.png" srcset="/img/loading.gif" alt></p><h3 id="Diversity-Representativeness-Reward-Function"><a href="#Diversity-Representativeness-Reward-Function" class="headerlink" title="Diversity-Representativeness Reward Function"></a>Diversity-Representativeness Reward Function</h3><p>&emsp;&emsp;训练时DSN的目的是最大化奖励函数。<br>&emsp;&emsp;Diversity reward:通过计算选择帧之间的差异性（取平均值）来度量多样性，</p><p><img src="/2019/09/15/Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization/02.png" srcset="/img/loading.gif" alt></p><p>&emsp;&emsp;公式3忽视了序列数据时间上的关联性，事实上，时间相距较大的两个相似帧对故事线的构筑都很重要。所以设置如下， 入控制时间距离。</p><p><img src="/2019/09/15/Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization/3.png" srcset="/img/loading.gif" alt></p><p>&emsp;&emsp;Representativeness reward:视频摘要代表性的度量是一个k-medoids问题，</p><p><img src="/2019/09/15/Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization/4.png" srcset="/img/loading.gif" alt></p><p>&emsp;&emsp;reward function使用这两个相加，训练时，保持这两个数量级一致。</p><h3 id="Training-with-Policy-Gradient"><a href="#Training-with-Policy-Gradient" class="headerlink" title="Training with Policy Gradient"></a>Training with Policy Gradient</h3><p>&emsp;&emsp;这里介绍使用的强化学习的训练方法，和一些tricks。<br>&emsp;&emsp;因为选择更多的帧也能提高reward，所以加入正则项。和防止过拟合的改进。<br>&emsp;&emsp;这里给出更新参数的公式和最优化算法（Adam），详情见论文。</p><h3 id="Summary-Generation"><a href="#Summary-Generation" class="headerlink" title="Summary Generation"></a>Summary Generation</h3><p>&emsp;&emsp;通过最大化得分选择子热点，同时控制帧数量不超过总长度15%。热点得分是通过平均化同一个热点中帧的得分来计算的。时间分割算法使用KTS。</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视频摘要</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Video Summarization with LSTM</title>
    <link href="undefined2019/09/15/Video-Summarization-with-Long-Short-term-Memory/"/>
    <url>2019/09/15/Video-Summarization-with-Long-Short-term-Memory/</url>
    
    <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>&emsp;&emsp;这篇文章提出一个新奇的监督学习方法用来进行视频摘要，用来自动选择关键帧或者关键子热点。将这项任务看成一个结构预测问题（structured prediction problem），主要思路是用LSTM对帧的时间依赖性进行建模。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>&emsp;&emsp;视频摘要如今有两个重要的方法：关键帧选择（keyframe selection，选择一些具有代表性的帧来组成摘要）；关键子热点选择（Key subshot selection，选择一系列在短时间类连续的帧组成摘要，即选择视频中具有代表性的每个时间点，将这些时间点的帧选择）。<br>&emsp;&emsp;非监督学习方法：通过直观标准选择帧<br>&emsp;&emsp;监督学习方法：通过视频帧的标注训练模型，使模型自动学习选择帧的标准。<br>&emsp;&emsp;模型输入是视频的帧序列，输出是一个二元数组（表示这些帧是否选择）。由此得到启发使用LSTM。视频帧内部的依赖性是复杂且不均匀的。<br>&emsp;&emsp;使用LSTM从时间上建立帧的联系，比从视觉上建立联系好（比如不同帧的相似性）。时间上相近的帧，包含的信息会冗余且相似。但是相似的帧包含的信息并不一定相同，且时间不一定相近。使用LSTM来学习时间线。<br>&emsp;&emsp;这篇文章研究如何将LSTM及其变体应用到Video Summarization中。将LSTM与DPP（determinantalpoint process）结合，等一些改进方法。</p><h2 id="Model-Overview"><a href="#Model-Overview" class="headerlink" title="Model Overview"></a>Model Overview</h2><p><strong>vsLSTM</strong>网络结构：</p><p><img src="/2019/09/15/Video-Summarization-with-Long-Short-term-Memory/1.png" srcset="/img/loading.gif" alt></p><p><strong>MLP</strong>（多层感知机）：输出为标量</p><p><img src="/2019/09/15/Video-Summarization-with-Long-Short-term-Memory/2.png" srcset="/img/loading.gif" alt="2"></p><p>使用SGD更新参数，这里是监督学习的方法，使用帧级别重要性得分（连续变量）或者选择的关键帧编码（二元向量）</p><p>由于LSTM（查全率高，查准率低），DPP（查准率高，查全率低），现在将这两个结合，</p><p><strong>DPP</strong>（行列式点过程）：DPP编码了从全集中选取任意一个子集的概率</p><p><img src="/2019/09/15/Video-Summarization-with-Long-Short-term-Memory/3.png" srcset="/img/loading.gif" alt="3"></p><p>z是子集,Z为全集，L为N*N的核矩阵（记录任意连个帧之间的相似性，实对称<strong>半正定</strong>方阵），det()为行列式的值，I是N*N的单位矩阵，子集z的概率与矩阵Lz的主子式行列式的值成正比。如果子集中有两个相同的元素时，det(Lz)将等于0。Lz是z在Z中标号对应元素组成的子方阵。</p><p>关于DDP的数学证明：<a href="https://blog.csdn.net/qq_23947237/article/details/90698325" target="_blank" rel="noopener">https://blog.csdn.net/qq_23947237/article/details/90698325</a></p><p><strong>dppLSTM</strong>：</p><p><img src="/2019/09/15/Video-Summarization-with-Long-Short-term-Memory/4.png" srcset="/img/loading.gif" alt="4"></p><p>MLP是由256个sigmoid隐单元、sigmoid和线性输出单元组成的单层神经网络，两个MLP（第一个计算frame-level importance,第二个计算相似性）</p><p><strong>Learning</strong>：</p><p>参数的学习使用MLE（最大似然估计），采用阶段化优化策略：首先训练MLP1和LSTM（vsLSTM）；接下来通过最大化dpp模型指定关键帧的可能性来训练所有mlp和lstm层。</p><p>具体细节见论文及增刊</p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视频摘要</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-Hueman Insight-Search配置</title>
    <link href="undefined2019/09/09/Hexo-Hueman-Insight-Search%E9%85%8D%E7%BD%AE/"/>
    <url>2019/09/09/Hexo-Hueman-Insight-Search%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>博客中的搜索功能一直无法使用，使用<br><code>npm install -S hexo-generator-json-content</code><br>安装插件后，仍然无法使用。</p><p>通过阅读<strong>hexo-generator-json-content</strong>的源码配置文件后得知，还需要对hexo的config文件做相应配置：</p><pre><code class="javascript">jsonContent:  meta: true  dafts: false  file: content.json  keywords: undefined  dateFormat: undefined  pages:    title: true    slug: true    date: true    updated: true    comments: true    path: true    link: true    permalink: true    excerpt: true    keywords: false    text: true    raw: false    content: false    author: true  posts:    title: true    slug: true    date: true    updated: true    comments: true    path: true    link: true    permalink: true    excerpt: true    keywords: false    text: true    raw: false    content: false    author: true    categories: true    tags: true</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3 while-else、//</title>
    <link href="undefined2019/09/08/Python3-while-else%E3%80%81/"/>
    <url>2019/09/08/Python3-while-else%E3%80%81/</url>
    
    <content type="html"><![CDATA[<p>在LeetCode-自除数答案中学到的几个语法和技巧，</p><p><strong>While-else:</strong></p><p>1、在Python中，else 可以和 while 循环搭配使用，当 while 循环正常执行完的情况下，执行 else 输出；    </p><p>2、如果当 while 循环中执行了跳出循环的语句，比如 break，将不执行 else 代码块的内容。</p><p><strong>//</strong>:向下取整</p><pre><code class="python">class Solution:    def selfDividingNumbers(self, left: int, right: int) -&gt; List[int]:        ans = []        for num in range(left,right + 1):            copy = num            while copy &gt; 0:                div, copy = copy % 10, copy // 10                if div == 0 or num % div != 0: break            else: ans.append(num) # while … else 在循环条件为 false 时执行 else 语句块        return ans</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python3 Counter类、all()</title>
    <link href="undefined2019/09/06/Python3-Counter%E7%B1%BB%E3%80%81all/"/>
    <url>2019/09/06/Python3-Counter%E7%B1%BB%E3%80%81all/</url>
    
    <content type="html"><![CDATA[<p><strong>Counter类(计数器)</strong></p><p>Counter类返回一个字典，统计每个元素出现次数，可以更新</p><pre><code class="python">import collectionsobj = collections.Counter([&#39;11&#39;,&#39;22&#39;])obj.update([&#39;22&#39;,&#39;55&#39;])print(obj)#输出：Counter({&#39;22&#39;: 2, &#39;11&#39;: 1, &#39;55&#39;: 1})</code></pre><p><strong>all()</strong> 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。</p><pre><code class="python">class Solution:    def countCharacters(self, words: List[str], chars: str) -&gt; int:        count=collections.Counter(chars)        sumlen=0        for word in words:            c=collections.Counter(word)            #list类型作为参数            if all([count[i]&gt;=c[i] for i in word]):                sumlen+=len(word)        return sumlen              </code></pre><p><strong>dict.item()</strong>返回字典键值对组成的元组</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>yield from简单理解</title>
    <link href="undefined2019/09/05/yield-from%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
    <url>2019/09/05/yield-from%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p><strong>yield</strong>简单理解可以看成<strong>return</strong>，但是函数执行<strong>yield</strong>后会返回值但是不会终止。</p><pre><code class="python"># yield返回值, 生成器def gen():    for x in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]:        yield xfor i in gen():    print(i)# a b c</code></pre><p><strong>在函数外部不能使用yield from（yield也不行）。</strong></p><h3 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h3><p><strong>yield from</strong>用来调用生成器，可以用于递归函数中，或者调用的函数中包含<strong>yield语句</strong></p><pre><code class="python">#中序遍历树class Solution:    def increasingBST(self, root):        def inorder(node):            if node:                yield from inorder(node.left)                yield node.val                yield from inorder(node.right)        ans = cur = TreeNode(None)        for v in inorder(root):            cur.right = TreeNode(v)            cur = cur.right        return ans.right</code></pre><p>上例函数为生成器函数，生成器对象是一个可迭代对象，可以存储遍历结果</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-下一个更大元素1</title>
    <link href="undefined2019/09/04/LeetCode-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A01/"/>
    <url>2019/09/04/LeetCode-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A01/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">题目地址</a></p><p>数据结构：栈、哈希表</p><p>思路：遍历nums2，哈希表存储每个元素后第一个大于它的元素。栈为递减栈，当遇到比栈顶元素大的元素，依次弹出元素，存入哈希表。最后遍历nums1，hash[nums[i]]组成的列表即为所求。</p><p>如 nums1 = [4,1,2], nums2 = [1,3,4,2]. </p><p>stack=[1]  hash[1]=3  hash[3]=-1(第一次出现该元素，hash值为-1)</p><p>stack=[3]  hash[3]=4 hash[4]=-1 stack=[4]  stack=[4,2] hash[2]=-1</p><pre><code class="python">class Solution(object):    def nextGreaterElement(self, nums1, nums2):        &quot;&quot;&quot;        :type nums1: List[int]        :type nums2: List[int]        :rtype: List[int]        &quot;&quot;&quot;        stack=[]        hashmap={}        for num in nums2:            while  len(stack)&gt;0 and stack[-1]&lt;num :                hashmap[stack.pop()]=num            hashmap[num]=-1            stack.append(num)        return [hashmap[i] for i in nums1]</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-质数排列</title>
    <link href="undefined2019/09/02/LeetCode-%E8%B4%A8%E6%95%B0%E6%8E%92%E5%88%97/"/>
    <url>2019/09/02/LeetCode-%E8%B4%A8%E6%95%B0%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><strong>质数</strong>：质数是大于1的，且不能用小于它的两个正整数乘积表示。</p><p>首先求1-n中质数的个数</p><pre><code class="python">def getnum(self,n:int) -&gt;int:        num=0        for i in range(2,n+1):            flag=True            for j in range(2,int(i**0.5)+1):                if i%j==0:                    flag=False                    break            if flag==True:                num+=1        return num</code></pre><p>总的方案数就是质数排列数和非质数排列数的乘积</p><pre><code class="python">    def jiecheng(self,n:int) -&gt;int:        sums=1        for i in range(1,n+1):            sums*=i        return sums%1000000007    def numPrimeArrangements(self, n: int) -&gt; int:        if n==1 or n==2:            return 1        count=self.getnum(n)        #调用类中的函数要使用self.        num=self.jiecheng(count)*self.jiecheng(n-count)        return num%1000000007</code></pre>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-回文字符串</title>
    <link href="undefined2019/08/30/Python-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>2019/08/30/Python-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>filter(str.isalnum,s)**<br>1、<strong>filter()</strong> 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。<br>2、Python <strong>isalnum()</strong>方法<br><strong>isalnum()</strong> 方法检测字符串是否由字母和数字组成。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>