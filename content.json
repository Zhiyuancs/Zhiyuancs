{"meta":{"title":"Zhiyuan的博客","subtitle":null,"description":"东北大学，中国矿业大学","author":"Zhiyuan","url":"http://Zhiyuancs.github.io","root":"/"},"pages":[],"posts":[{"title":"Go(二)","slug":"Go-二","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2019/09/26/Go-二/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/26/Go-二/","excerpt":"","text":"基础数据类型2.1 整形12345* / % &lt;&lt; &gt;&gt; &amp; &amp;^+ - | ^== != &lt; &lt;= &gt; &gt;=&amp;&amp;|| 二元运算符有五种优先级。在同一个优先级，使用左优先结合规则，但是使用括号可以明确优先顺序，使用括号也可以用于提升优先级。在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此-5%3和-5%-3结果都是-2。除法运算符/的行为则依赖于操作数是否为全为整数，比如5.0/4.0的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。 123456&amp; 位运算 AND| 位运算 OR^ 位运算 XOR&amp;^ 位清空 (AND NOT)&lt;&lt; 左移&gt;&gt; 右移 位操作运算符^作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反；位操作运算符&amp;^用于按位置零（AND NOT）：如果对应y中bit位为1的话, 表达式z = x &amp;^ y结果z的对应的bit位为0，否则z对应的bit位等于x相应的bit位的值。 任何大小的整数字面值都可以用以0开始的八进制格式书写，例如0666；或用以0x或0X开头的十六进制格式书写，例如0xdeadbeef。十六进制数字可以用大写或小写字母。 123456o := 0666fmt.Printf(\"%d %[1]o %#[1]o\\n\", o) // \"438 666 0666\"x := int64(0xdeadbeef)fmt.Printf(\"%d %[1]x %#[1]x %#[1]X\\n\", x)// Output:// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF 通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的[1]副词告诉Printf函数再次使用第一个操作数。第二，%后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。字符使用%c参数打印，或者是用%q参数打印带单引号的字符。 2.2 浮点数float32、float64 很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分。 1const Avogadro = 6.02214129e23 // 阿伏伽德罗常数 用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。所有的这三个打印形式都可以指定打印的宽度和控制打印精度。 1234567for x := 0; x &lt; 8; x++ &#123; fmt.Printf(\"x = %d e^x = %8.3f\\n\", x, math.Exp(float64(x)))&#125;x = 5 e^x = 148.413x = 6 e^x = 403.429x = 7 e^x = 1096.633 math包中有定义的特殊值：+Inf、-Inf、NAN（正负无穷，非数）。函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。 12nan := math.NaN()fmt.Println(nan == nan, nan &lt; nan, nan &gt; nan) // \"false false false\" 2.3 复数Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部： 12345var x complex128 = complex(1, 2) // 1+2ivar y complex128 = complex(3, 4) // 3+4ifmt.Println(x*y) // \"(-5+10i)\"fmt.Println(real(x*y)) // \"-5\"fmt.Println(imag(x*y)) // \"10\" math/cmplx包提供了复数处理的许多函数，例如求复数的平方根函数和求幂函数。 2.4 布尔值布尔值可以和&amp;&amp;（AND）和||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值。 &amp;&amp;的优先级比||高 布尔值并不会隐式转换为数字值0或1，反之亦然。 2.5 字符串支持切片，‘+’链接字符串，字符串是不可修改的，尝试修改字符串内部的字符是禁止的。 原生字符串使用反引号代替双引号，原生的字符串字面量多用于书写多行消息、HTML以及正则表达式。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行。 12345const GoUsage = `Go is a tool for managing Go source code.Usage: go command [arguments]...` strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。 1234567891011121314//strings包func Contains(s, substr string) boolfunc Count(s, sep string) intfunc Fields(s string) []stringfunc HasPrefix(s, prefix string) boolfunc Index(s, sep string) intfunc Join(a []string, sep string) string//bytes包func Contains(b, subslice []byte) boolfunc Count(s, sep []byte) intfunc Fields(s []byte) [][]bytefunc HasPrefix(s, prefix []byte) boolfunc Index(s, sep []byte) intfunc Join(s [][]byte, sep []byte) []byte bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效的： 1234var buf bytes.Bufferbuf.WriteByte('[')buf.WriteRune('中')buf.WriteString(\", d \") strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。 2.6 UTF-8UTF8编码使用1到4个字节来表示每个Unicode码点，ASCII部分字符只使用1个字节，常用字符部分使用2或3个字节表示。如果第一个字节的高端bit为0，则表示对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统的ASCII编码兼容。如果第一个字节的高端bit是110，则说明需要2个字节；后续的每个高端bit都以10开头。 12340xxxxxxx runes 0-127 (ASCII)110xxxxx 10xxxxxx 128-2047 (values &lt;128 unused)1110xxxx 10xxxxxx 10xxxxxx 2048-65535 (values &lt;2048 unused)11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 65536-0x10ffff (other values unused) 12345//Unicode转义字符让我们可以通过Unicode码点输入特殊的字符。下面是相同的字符串\"世界\"\"\\xe4\\xb8\\x96\\xe7\\x95\\x8c\"\"\\u4e16\\u754c\"\"\\U00004e16\\U0000754c\" 12345import \"unicode/utf8\"s := \"Hello, 世界\"fmt.Println(len(s)) // \"13\"fmt.Println(utf8.RuneCountInString(s)) // \"9\" Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串。 如果是将一个[]rune类型的Unicode字符slice或数组转为string，则对它们进行UTF8编码： 123456789s := \"プログラム\"fmt.Printf(\"% x\\n\", s) // \"e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0\"r := []rune(s)fmt.Printf(\"%x\\n\", r) // \"[30d7 30ed 30b0 30e9 30e0]\"fmt.Println(string(r)) // \"プログラム\"fmt.Println(string(65)) // \"A\", not \"65\"fmt.Println(string(0x4eac)) // \"京\"fmt.Println(string(1234567)) // \"�\"（无效字符）fmt.Println(rune('你'))//输出20320 rune在golang中是int32的别名，在各个方面都与int32相同。可以将rune理解为一个可以表示Unicode编码的int值，称为码点。参考java中的char类型（可以和int运算）。 在Go中，双引号是用来表示字符串string，本质是[]byte类型，单引号表示rune类型。 2.7 字符串和数字的转换将一个整数转为字符串，一种方法是用fmt.Sprintf返回一个格式化的字符串；另一个方法是用strconv.Itoa(“整数到ASCII”)： 123x := 123y := fmt.Sprintf(\"%d\", x)fmt.Println(y, strconv.Itoa(x)) // \"123 123\" FormatInt和FormatUint函数可以用不同的进制来格式化数字： 1fmt.Println(strconv.FormatInt(int64(x), 2)) // \"1111011\" fmt.Sprintf函数的%b、%d、%o和%x等参数提供功能往往比strconv包的Format函数方便很多，特别是在需要包含附加额外信息的时候： 1s := fmt.Sprintf(\"x=%b\", x) // \"x=1111011\" 如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数： 123x, err := strconv.Atoi(\"123\") // x is an inty, err := strconv.ParseInt(\"123\", 10, 64) // base 10, up to 64 bitsfunc ParseInt(s string, base int, bitSize int) (i int64, err error) ParseInt函数的第三个参数是用于指定返回整型数的大小；例如16表示int16，0则表示int。第二个参数为数字字符串的进制。 int随系统而定，32位系统为int32 2.8 常量批量声明 1234567const ( e = 2.7182818284590452 e1 pi = 3.1415926535897932 p3)//p3=pi,e1=e iota 常量生成器:在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。 123456789101112131415161718192021222324type Weekday intconst ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday)//周日将对应0，周一为1，如此等等const ( _ = 1 &lt;&lt; (10 * iota) KiB // 1024 MiB // 1048576 GiB // 1073741824 TiB // 1099511627776 (exceeds 1 &lt;&lt; 32) PiB // 1125899906842624 EiB // 1152921504606846976 ZiB // 1180591620717411303424 (exceeds 1 &lt;&lt; 64) YiB // 1208925819614629174706176) 2.9 无类型常量有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。 math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方： 123var x float32 = math.Pivar y float64 = math.Pivar z complex128 = math.Pi","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://Zhiyuancs.github.io/tags/Go/"}]},{"title":"Go(一)","slug":"Go-一","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2019/09/26/Go-一/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/26/Go-一/","excerpt":"","text":"1.1命名Go中函数名字的开头字母大小决定了该函数在包外的可见性：大写字母开头，这个函数在包外可以使用；小写字母开头不可以在包外部访问。Go语言程序员推荐使用 驼峰式 命名。 1.2声明var、const、type、func：变量、常量、类型、函数实体对象声明 包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句。在包一级声明的名字可以在整个包和引用了该包的源文件中访问。 1.3变量1var 变量名字 类型 = 表达式 go语言中所有变量定义时如果未赋值，都会初始化为一个默认值。 在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。 1234freq := rand.Float64() * 3.0t := 0.0i, j := 0, 1 //变量声明语句i, j = j, i // 交换 i 和 j 的值，赋值语句（元组赋值） 简短变量声明语句中必须至少要声明一个新的变量，否则不能编译通过。 1.4指针如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时*p表达式对应p指针指向的变量的值。一般*p表达式读取指针指向的变量的值，这里为int类型的值，同时因为*p对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。 123456x := 1p := &amp;x // p, of type *int, points to xfmt.Println(*p) // \"1\"*p = 2 // equivalent to x = 2fmt.Println(x) // \"2\"*p++ // x=3,p仍然指向x 指针的零值为nil，在Go语言中，返回函数中局部变量的地址也是安全的。 123456var p = f()func f() *int &#123; v := 1 return &amp;v&#125; 1.5 new 函数表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。 1234567891011p := new(int) // p, *int 类型, 指向匿名的 int 变量fmt.Println(*p) // \"0\"//下面两个函数功能相同func newInt() *int &#123; return new(int)&#125;func newInt() *int &#123; var dummy int return &amp;dummy&#125; 由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。下面由于new被定义为int类型的变量名，因此在delta函数内部是无法使用内置的new函数的。 1func delta(old, new int) int &#123; return new - old &#125; 了解go语言自动垃圾回收器。 1.6 类型123type 类型名字 底层类型type Celsius float64 // 摄氏温度 1.7下划线 ‘_’ 12345678910111213141516171819202122//用在import//引入包，会先调用包中的初始化函数，这种使用方式仅让导入的包做初始化，而不使用包中其他功能import _ \"net/http/pprof\"//用在返回值//表示忽略某个值。单函数有多个返回值，用来获取某个特定的值for _,v := range Slice&#123;&#125;_,err := func()//用在变量//上面用来判断 type T是否实现了I,用作类型断言，如果T没有实现借口I，则编译错误.type T struct&#123;&#125;var _ I = T&#123;&#125;其中 I为interface//用在函数定义中省略带名的参数func demo() ( int, int, string, int ,error)//返回多个参数时,尤其是类型相同的，不利于阅读，func demo() ( sumA int, sumB int, _ string, total int ,_ error)//返回参数 int 加了名字，对比上面,便于理解,但是 \"string\" 和 \"error\"没有名字，编译会报错，用下划线可以忽略命名 1.8 os.Args由os包实现，用于给出程序运行时的参数。os.Args的类型是 []string ，也就是字符串切片。所以可以在for循环的range中遍历，还可以用 len(os.Args) 来获取其数量。 123456789101112131415161718192021package mainimport ( \"fmt\" \"os\" \"strconv\")func main () &#123; for idx, args := range os.Args &#123; fmt.Println(\"参数\" + strconv.Itoa(idx) + \":\", args) &#125;&#125;//运行结果$go run main.go 1 3 -X ?参数0: /tmp/go-build116558042/command-line-arguments/_obj/exe/main参数1: 1参数2: 3参数3: -X参数4: ?//参数0为程序路径本身 1.9 flag包使用flag包，首先定义待解析命令行参数，也就是以”-“开头的参数，比如这里的 -b -s -help等。-help不需要特别指定，可以自动处理。 flag使用前，必须首先解析：flag.Parse() 。 参数中没有能够按照预定义的参数解析的部分，通过flag.Args()即可获取，是一个字符串切片。 通过flag.Bool和flag.String，建立了2个指针b和s，分别指向bool类型和string类型的变量。所以后续要通过 *b 和 *s 使用变量值。 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"flag\")//参数：命令行参数名称，默认值，提示字符串var b = flag.Bool(\"b\", false, \"bool类型参数\")var s = flag.String(\"s\", \"\", \"string类型参数\")func main() &#123; flag.Parse() fmt.Println(\"-b:\", *b) fmt.Println(\"-s:\", *s) fmt.Println(\"其他参数：\", flag.Args())&#125;------------------------------------$ go run main.go-b: false-s: 其他参数： []------------------------------------$ go run main.go -b-b: true-s: 其他参数： []------------------------------------$ go run main.go -b -s test others-b: true-s: test其他参数： [others]------------------------------------$ go run main.go -helpUsage of /tmp/go-build080353851/command-line-arguments/_obj/exe/main: -b bool类型参数 -s string string类型参数exit status 2 1.10 errerror类型是一个接口类型，定义如下： 123type error interface &#123; Error() string&#125; 可以通过实现error接口来生成错误信息，如果产生错误，就会生成一个non-nil的error对象，将此对象与nil比较，结果为true。 123456789101112func Sqrt(f float64) (float64, error) &#123; if f &lt; 0 &#123; return 0, errors.New(\"math: square root of negative number\") &#125; // 实现&#125;result, err:= Sqrt(-1)if err != nil &#123; fmt.Println(err)&#125; 1.11 包的初始化和标准输入输出func init() { /* ... */ } 初始化函数在包调用时自动执行。 1234567func main() &#123; input := bufio.NewScanner(os.Stdin)//初始化一个扫表对象 for input.Scan() &#123;//扫描输入内容 line := input.Text()//把输入内容转换为字符串 fmt.Println(line)//输出到标准输出 &#125;&#125; 1.12 作用域if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域。 12345678if x := f(); x == 0 &#123; fmt.Println(x)&#125; else if y := g(x); x == y &#123; fmt.Println(x, y)&#125; else &#123; fmt.Println(x, y)&#125;fmt.Println(x, y) // compile error: x and y are not visible here 在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归引用了自身，则会产生编译错误。 123456789var cwd string//使用声明语句，初始化的cwd为局部变量，导致全局变量cwd并未被初始化func init() &#123; cwd, err := os.Getwd() // NOTE: wrong! if err != nil &#123; log.Fatalf(\"os.Getwd failed: %v\", err) &#125; log.Printf(\"Working directory = %s\", cwd)&#125; 123456789var cwd string//将err先定义，再使用赋值方法func init() &#123; var err error cwd, err = os.Getwd() if err != nil &#123; log.Fatalf(\"os.Getwd failed: %v\", err) &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://Zhiyuancs.github.io/tags/Go/"}]},{"title":"java 正则表达式","slug":"java-正则表达式","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2019/09/22/java-正则表达式/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/22/java-正则表达式/","excerpt":"","text":"题目地址：https://leetcode-cn.com/problems/string-to-integer-atoi/ 1234567891011121314151617181920212223242526272829import java.util.regex.*;class Solution &#123; public static int myAtoi(String str) &#123; str=str.trim(); String pattern=\"^[\\\\+\\\\-\\\\d]\\\\d*\";//正则表达式，表示以正号或负号或数字开头，且后面是0个或多个数字 Pattern p=Pattern.compile(pattern); Matcher m=p.matcher(str); String res=\"\"; if(m.find())&#123;//能匹配到 res=str.substring(m.start(),m.end()); &#125;else&#123;//不能匹配到 return 0; &#125; //能匹配到但只有一个+-号，也返回0 if(res.length()==1&amp;&amp;(res.charAt(0)=='+'||res.charAt(0)=='-'))&#123; return 0; &#125; try&#123; int r=Integer.parseInt(res); return r; &#125;catch(Exception e)&#123; return res.charAt(0)=='-'?Integer.MIN_VALUE:Integer.MAX_VALUE; &#125; &#125;&#125; 在使用java正则表达式时要注意：java中”\\\\“表示”\\“,”\\\\+”表示”+”,因为”+”需要转义， lookingAt()lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返回true 12345Pattern p=Pattern.compile(\"\\\\d+\"); Matcher m=p.matcher(\"22bb23\"); m.lookingAt();//返回true,因为\\d+匹配到了前面的22 Matcher m2=p.matcher(\"aa2223\"); m2.lookingAt();//返回false,因为\\d+不能匹配前面的aa Mathcer.start()/ Matcher.end()/ Matcher.group()start()返回匹配到的子字符串在字符串中的索引位置.end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置.group()返回匹配到的子字符串 start(),end(),group()均有一个重载方法它们是start(int i),end(int i),group(int i)专用于分组操作,Mathcer类还有一个groupCount()用于返回有多少组. 12345678910111213141516171819202122Pattern p=Pattern.compile(\"\\\\d+\"); Matcher m=p.matcher(\"我的QQ是:456456 我的电话是:0532214 我的邮箱是:aaa123@aaa.com\"); while(m.find()) &#123; System.out.println(m.group()); &#125; 输出：456456 0532214 123 //或者 while(m.find()) &#123; System.out.println(m.group()); System.out.print(\"start:\"+m.start()); System.out.println(\" end:\"+m.end()); &#125; 输出：456456 start:6 end:12 0532214 start:19 end:26 123 start:36 end:39 可以看出，每执行一次find()，matcher对应的分组都会自动加一。start(),end(),group()三个方法的值都会改变,匹配到的子字符串的信息,以及它们的重载方法,也会改变成相应的信息. 后面遇到有关正则表达式问题再进行补充。","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"http://Zhiyuancs.github.io/tags/java/"}]},{"title":"Mysql学习笔记（三）","slug":"Mysql学习笔记（三）","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2019/09/21/Mysql学习笔记（三）/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/21/Mysql学习笔记（三）/","excerpt":"","text":"select 字段列表form 表名where 查询筛选条件group by 指定分组的列列表having 指定分组后的筛选条件order by 排序列的列表limit 起始索引值，要查询的记录条数 1、分组查询：group by分组函数（聚合函数）：将多行的值进行统计返回一行结果sum() ; avg(); min(); max(); count().注：分组函数不能和与分组无关的列一起使用；分组查询时，查询的列可以是分组的条件 123456789SELECT SUM(salary)，COUNT(eid)，did FROM t_employGROUP BY did;SELECT did,COUNT(eid)FROM t_employWHERE salary&gt;10000AND did IS NOT NULLGROUP BY did; 2、条件中需要使用分组后的结果:having作用和where一样，但是执行顺序在分组之后 1234SELECT AVG(salary)FROM t_employGROUP BY didHAVING AVG(salary)&gt;9000; 3、order by：降序排列desc，升序排列ascSELECT * FROM t_employ ORDER BY salary DESC, eid ASC; 4、分页查询：limit index，size 5、子查询：当前查询依赖另一个查询的结果 123SELECT * FROM t_employ WHERE did=( SELECT did FROM t_employ WHERE ename='罗宾')； 三种类型：1、将子查询结果当做where查询的条件；2、当做临时表再次查询；3、作为主查询的判断条件，决定数据是否查询。exists型子查询 6、复制表 复制表结构：CREATE TABLE t_emp AS(SELECT * FROM t_employ WHERE 1=2);复制表结构+指定数据：where 条件 7、单行函数：处理一行返回一行结果SELECT UPPER(email) FROM t_employ;password():mysql数据库在将数据库管理员的信息进行保存时，会将密码加密保存。SELECT PASSWORD(&#39;123456&#39;) FROM DUAL; (dual练习表)","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://Zhiyuancs.github.io/tags/Mysql/"}]},{"title":"Mysql学习笔记（四）","slug":"Mysql学习笔记（四）","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2019/09/21/Mysql学习笔记（四）/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/21/Mysql学习笔记（四）/","excerpt":"","text":"","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://Zhiyuancs.github.io/tags/Mysql/"}]},{"title":"Mysql学习笔记（二）","slug":"Mysql学习笔记（二）","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2019/09/21/Mysql学习笔记（二）/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/21/Mysql学习笔记（二）/","excerpt":"","text":"1、自增长：如果一列是主键，并且数据类型是int，则支持自动增长，每次插入数据时，会自动加一表定义时加上 id INT(11) PRIMARY KEY AUTO_INCREMENT； 2、给查询到的列取别名，表也可以取别名SELECT 列名 AS ‘别 名’，列名 别名，…… FROM 表名3、去重复：将查询到的所有列的重复筛选掉SELECT DISTINCT 列名 FROM 表名 4、查询时 进行计算支持数学运算符，逻辑运算符：xor异或比较运算符：=，&gt;,&lt;,&gt;=,&lt;=集合：in(值列表)范围：between min and max 5、模糊查询:like ‘模糊字符串’%:代表0~n个任意字符_：代表一个任意字符 6、使用 ifnull(字段，默认值) 方法解决null值计算问题 7、字符串拼接时的null值（sql中的+不能拼接字符串）concat（字段和字符串列表）：自动将方法内的所有字符串进行拼接处理 8、联合查询多表查询时，需要指定连接条件才能避免笛卡尔积：表名.列名（指定是哪个表的列）多表查询时，最少指定n-1个连接条件才能避免笛卡尔积 9、内连接（INNER JOIN）sql99推荐多表连接使用：表1 join 表2 on 连接条件 join 表3 on 连接条件INNER JOIN（只有满足条件的数据才能被查询） 10、外连接(左外连接：左表不满足条件的数据也查询出来，右外连接）LEFT OUTER JOIN全连接 11、自连接：当前表连接当前表，使用别名区分","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://Zhiyuancs.github.io/tags/Mysql/"}]},{"title":"Mysql学习笔记（一）","slug":"Mysql学习笔记（一）","date":"un66fin66","updated":"un33fin33","comments":true,"path":"2019/09/21/Mysql学习笔记（一）/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/21/Mysql学习笔记（一）/","excerpt":"","text":"DDL语句1、建库 1CREAT DATABASE 名字 不区分大小写，推荐关键字大写；单词间加‘_’mysql数据结构：char，varchar 12345CREATE TABLE tm_teammanager( id INT(11), 'name' VARCHAR(30),#通过飘号选中的字符会保留字符串本意，不会当成关键字，~ gender CHAR(2)) 2、查表结构 1DESC tm_teammanager 3、从删库到跑路备份为.sql文件 12DROP TABLE 表名 DROP DATABASE 4、修改表名 1ALTER TABLE oldname RENAME newname; 5、给表添加一列 1ALTER TABLE 表名 ADD COLUMN 名字 INT(3) (加上类型) 6、删除表一列 1ALTER TABLE 表名 DROP COLUMN 列名 7、给一列重命名change 1ALTER TABLE 表名 CHANGE 列名 新列名 数据类型 8、修改表列的数据类型modify 1ALTER TABLE 表名 MODIFY 列名 新数据类型 DML语句1、插入数据 12INSERT INTO 表名 VALUES(); #必须给所有列指定值 INSERT INTO 表名(id,列名……) VALUES(对应值); 2、查询 select 3、修改数据 update 1UPDATE 表名 SET 列名=值 WHERE id=2； 4、删除 delete 12DELETE FROM 表名 delete、drop、truncate区别 约束 constrains1、主键约束 primary key（字段值唯一非空）主键只能有一个1.1添加主键：创建表时添加约束CONSTRAINT PRIMARY KEY(列名)1.2 通过alter语句给表添加主键约束（表创建后添加） 123ALTER TABLE 表名 DROP PRIMARY KEY; #先删除原有主键约束 ALTER TABLE 表名 ADD PRIMARY KEY(列名) 或 ALTER TABLE 表名 MODIFY …… PRIMARY KEY 2、唯一键约束2.1 创建时添加2.2 修改表的指定列添加唯一键约束 1ALTER TABLE ^ MODIFY ^ ^ UNIQUE; 删除唯一键约束 1ALTER TABLE 表名 DROP INDEX 列名； 查看索引 SHOW INDEX FROM 表名 3、非空约束 not null3.1创建表时添加 123CREATE TABLE t_stu( &amp;emsp;&amp;emsp;id INT(11) NOT NULL; ); 删除非空约束 1alter table 表名 modify 列名 类型； 3.2修改列添加非空约束 1alter table 表名 modify 列名 类型 not null default “etc”； 4、默认值约束 default5、外键约束外键关联时，两张表建立外键的列数据类型必须相同，长度尽量一致 5.1修改表的指定列，添加外键约束 123ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY （当前表的指定列） references 关联的表名（指定要关联的列名）;ALTER TABLE t_stu ADD CONSTRAINT fk_cid FOREIGN KEY(cid) REFERENCES t_course(id); 删除外键约束：删除外键，然后才能删除外键对应的索引 12ALTER TEBLE 表名 DROP FOREIGN KEY(外键名) ALTER TABLE 表名 DROP INDEX 外键名； 索引需要删除，否则影响效率 5.2创建表时添加 1CONSTRAINT 外键名 FOREIGN KEY(列名) REFERENCES关联的表名（列名） 5.3删除被其他表关联的数据：当没有其他表引用该行数据可以删除5.4添加外键时指定级联删除或者级联置空","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://Zhiyuancs.github.io/tags/Mysql/"}]},{"title":"Unsupervised Video Summarization with Adversarial LSTM","slug":"3","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2019/09/21/3/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/21/3/","excerpt":"","text":"&emsp;&emsp;本文提出一个由summarizer和discriminator组成的生成对抗框架。目的是选择视频的稀疏子集，使得视频和摘要的表示误差最小。 &emsp;&emsp;原始视频的特征是通过GAN和LSTM提取的，GAN以像素为基础提取特征，LSTM捕捉帧之间的长期依赖关系，得到深度特征向量。由于明确深度特征间的合适距离困难，所以由左边结构转换为右边的结构。 论文理论基础：Variational Autoencoder(VAE)，GAN Model Overview&emsp;&emsp;CNN输出的是视频帧的深度特征（deep features x），sLSTM（selector LSTM）在这些帧中选择一个子集，eLSTM(encoder LSTM)将选择的帧序列编码成向量 e 。sLSTM生成每一个帧的标准化重要性得分s，结合x，输入到eLSTM中。dLSTM(decoder LSTM)以e为输入，重构了输入视频的特征序列。鉴别器（discriminator）用来区分原始和摘要视频帧间的特征，用于估计两者之间的representation error。 &emsp;&emsp;本实验中使用二元序列分类器（a binary sequence classifier），所以鉴别器为cLSTM(classifier LSTM)，输出是二分类。 &emsp;&emsp;生成对抗训练的关键是引入一个额外的帧选择器Sp（基于先验分布的，例如均匀分布）。利用概率Sp选择一个子集作为eLSTM的输入，以相同的pipeline生成一系列值，用于计算误差。 Reconstruction loss Lreconst&emsp;&emsp;没有采用传统的欧式距离，而是基于cLSTM的隐藏层表示。cLSTM最后一个隐藏层的输出**表示一个紧凑的特征向量，它捕捉了x（特征序列）的长距离依赖关系。Lre是对数似然的期望。 Loss of GAN这里的先验分布使用均匀分布。 &emsp;&emsp;cLSTM(·)是一个二元的softmax输出。更新参数使用随机梯度变分bayes估计（Stochastic Gradient Variational Bayes estimation） 正则化训练Summary-Length Regularization M帧数量，*希望选择帧数量的百分比 Diversity Regularization 基于DPP 排斥正则化器（Repelling regularizer） Keyframe Regularization","author":"Zhiyuan","categories":[{"name":"AI","slug":"AI","permalink":"http://Zhiyuancs.github.io/categories/AI/"}],"tags":[{"name":"视频摘要","slug":"视频摘要","permalink":"http://Zhiyuancs.github.io/tags/视频摘要/"}]},{"title":"Deep Reinforcement Learning for Unsupervised V-S ","slug":"Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2019/09/15/Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/15/Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization/","excerpt":"","text":"Abstract&emsp;&emsp;本文创新点：1、构建DSN网络；2、设计一个新的奖励函数（基于帧的多样性和代表性）；3、设计一个端到端的、基于强化学习的框架来训练网络。 Introduction&emsp;&emsp;DPP-LSTM效果较好，但是视频摘要的评价时，人类具有更多的主观性，所以非监督方法很有必要。&emsp;&emsp;本文的DSN网络：encoder：CNN（在视频帧上进行特征提取）；decoder：BiLSTM（产生概率分布来选择帧）。RL（增强学习）：通过迭代方式训练agent。&emsp;&emsp;主要贡献：将无监督方法扩展到监督版本，以利用标签；首次将RL应用到无监督视频摘要上。 Model OverviewDeep Summarization Network&emsp;&emsp;采用encoder-decoder结构，CNN选用在ImageNet上预训练好的GoogLeNet，从它倒数第二层提取出视觉特征向量x_{t}。LSTM用来捕获视频帧之间的长时间依赖性。训练中只更新decoder。 &emsp;&emsp;将BiLSTM网络的正向和反向的隐藏层输出拼接作为相应的隐状态，网络输入为视觉特征向量。全连接层结束于sigmoid函数，得出每个帧选择的概率分布，帧是否选择服从二项分布。视频摘要由这些选择的帧组成。 Diversity-Representativeness Reward Function&emsp;&emsp;训练时DSN的目的是最大化奖励函数。&emsp;&emsp;Diversity reward:通过计算选择帧之间的差异性（取平均值）来度量多样性， &emsp;&emsp;公式3忽视了序列数据时间上的关联性，事实上，时间相距较大的两个相似帧对故事线的构筑都很重要。所以设置如下， 入控制时间距离。 &emsp;&emsp;Representativeness reward:视频摘要代表性的度量是一个k-medoids问题， &emsp;&emsp;reward function使用这两个相加，训练时，保持这两个数量级一致。 Training with Policy Gradient&emsp;&emsp;这里介绍使用的强化学习的训练方法，和一些tricks。&emsp;&emsp;因为选择更多的帧也能提高reward，所以加入正则项。和防止过拟合的改进。&emsp;&emsp;这里给出更新参数的公式和最优化算法（Adam），详情见论文。 Summary Generation&emsp;&emsp;通过最大化得分选择子热点，同时控制帧数量不超过总长度15%。热点得分是通过平均化同一个热点中帧的得分来计算的。时间分割算法使用KTS。","author":"Zhiyuan","categories":[{"name":"AI","slug":"AI","permalink":"http://Zhiyuancs.github.io/categories/AI/"}],"tags":[{"name":"视频摘要","slug":"视频摘要","permalink":"http://Zhiyuancs.github.io/tags/视频摘要/"}]},{"title":"Video Summarization with LSTM","slug":"Video-Summarization-with-Long-Short-term-Memory","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2019/09/15/Video-Summarization-with-Long-Short-term-Memory/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/15/Video-Summarization-with-Long-Short-term-Memory/","excerpt":"","text":"Abstract&emsp;&emsp;这篇文章提出一个新奇的监督学习方法用来进行视频摘要，用来自动选择关键帧或者关键子热点。将这项任务看成一个结构预测问题（structured prediction problem），主要思路是用LSTM对帧的时间依赖性进行建模。 Introduction&emsp;&emsp;视频摘要如今有两个重要的方法：关键帧选择（keyframe selection，选择一些具有代表性的帧来组成摘要）；关键子热点选择（Key subshot selection，选择一系列在短时间类连续的帧组成摘要，即选择视频中具有代表性的每个时间点，将这些时间点的帧选择）。&emsp;&emsp;非监督学习方法：通过直观标准选择帧&emsp;&emsp;监督学习方法：通过视频帧的标注训练模型，使模型自动学习选择帧的标准。&emsp;&emsp;模型输入是视频的帧序列，输出是一个二元数组（表示这些帧是否选择）。由此得到启发使用LSTM。视频帧内部的依赖性是复杂且不均匀的。&emsp;&emsp;使用LSTM从时间上建立帧的联系，比从视觉上建立联系好（比如不同帧的相似性）。时间上相近的帧，包含的信息会冗余且相似。但是相似的帧包含的信息并不一定相同，且时间不一定相近。使用LSTM来学习时间线。&emsp;&emsp;这篇文章研究如何将LSTM及其变体应用到Video Summarization中。将LSTM与DPP（determinantalpoint process）结合，等一些改进方法。 Model OverviewvsLSTM网络结构： MLP（多层感知机）：输出为标量 使用SGD更新参数，这里是监督学习的方法，使用帧级别重要性得分（连续变量）或者选择的关键帧编码（二元向量） 由于LSTM（查全率高，查准率低），DPP（查准率高，查全率低），现在将这两个结合， DPP（行列式点过程）：DPP编码了从全集中选取任意一个子集的概率 z是子集,Z为全集，L为N*N的核矩阵（记录任意连个帧之间的相似性，实对称半正定方阵），det()为行列式的值，I是N*N的单位矩阵，子集z的概率与矩阵Lz的主子式行列式的值成正比。如果子集中有两个相同的元素时，det(Lz)将等于0。Lz是z在Z中标号对应元素组成的子方阵。 关于DDP的数学证明：https://blog.csdn.net/qq_23947237/article/details/90698325 dppLSTM： MLP是由256个sigmoid隐单元、sigmoid和线性输出单元组成的单层神经网络，两个MLP（第一个计算frame-level importance,第二个计算相似性） Learning： 参数的学习使用MLE（最大似然估计），采用阶段化优化策略：首先训练MLP1和LSTM（vsLSTM）；接下来通过最大化dpp模型指定关键帧的可能性来训练所有mlp和lstm层。 具体细节见论文及增刊","author":"Zhiyuan","categories":[{"name":"AI","slug":"AI","permalink":"http://Zhiyuancs.github.io/categories/AI/"}],"tags":[{"name":"视频摘要","slug":"视频摘要","permalink":"http://Zhiyuancs.github.io/tags/视频摘要/"}]},{"title":"Hexo-Hueman Insight-Search配置","slug":"Hexo-Hueman-Insight-Search配置","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2019/09/09/Hexo-Hueman-Insight-Search配置/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/09/Hexo-Hueman-Insight-Search配置/","excerpt":"","text":"博客中的搜索功能一直无法使用，使用npm install -S hexo-generator-json-content安装插件后，仍然无法使用。 通过阅读hexo-generator-json-content的源码配置文件后得知，还需要对hexo的config文件做相应配置： 1234567891011121314151617181920212223242526272829303132333435363738jsonContent: meta: true dafts: false file: content.json keywords: undefined dateFormat: undefined pages: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: false text: true raw: false content: false author: true posts: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: false text: true raw: false content: false author: true categories: true tags: true","author":"Zhiyuan","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://Zhiyuancs.github.io/tags/Hexo/"}]},{"title":"Python3 while-else、//","slug":"Python3-while-else、","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2019/09/08/Python3-while-else、/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/08/Python3-while-else、/","excerpt":"","text":"在LeetCode-自除数答案中学到的几个语法和技巧， While-else: 1、在Python中，else 可以和 while 循环搭配使用，当 while 循环正常执行完的情况下，执行 else 输出； 2、如果当 while 循环中执行了跳出循环的语句，比如 break，将不执行 else 代码块的内容。 //:向下取整 12345678910class Solution: def selfDividingNumbers(self, left: int, right: int) -&gt; List[int]: ans = [] for num in range(left,right + 1): copy = num while copy &gt; 0: div, copy = copy % 10, copy // 10 if div == 0 or num % div != 0: break else: ans.append(num) # while … else 在循环条件为 false 时执行 else 语句块 return ans","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]},{"title":"Python3 Counter类、all()","slug":"Python3-Counter类、all","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2019/09/06/Python3-Counter类、all/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/06/Python3-Counter类、all/","excerpt":"","text":"Counter类(计数器) Counter类返回一个字典，统计每个元素出现次数，可以更新 123456import collectionsobj = collections.Counter(['11','22'])obj.update(['22','55'])print(obj)#输出：Counter(&#123;'22': 2, '11': 1, '55': 1&#125;) all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。 12345678910class Solution: def countCharacters(self, words: List[str], chars: str) -&gt; int: count=collections.Counter(chars) sumlen=0 for word in words: c=collections.Counter(word) #list类型作为参数 if all([count[i]&gt;=c[i] for i in word]): sumlen+=len(word) return sumlen dict.item()返回字典键值对组成的元组","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]},{"title":"yield from简单理解","slug":"yield-from简单理解","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2019/09/05/yield-from简单理解/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/05/yield-from简单理解/","excerpt":"","text":"yieldyield简单理解可以看成return，但是函数执行yield后会返回值但是不会终止。 123456789# yield返回值, 生成器def gen(): for x in [\"a\", \"b\", \"c\"]: yield xfor i in gen(): print(i)# a b c 在函数外部不能使用yield from（yield也不行）。 yield fromyield from用来调用生成器，可以用于递归函数中，或者调用的函数中包含yield语句 1234567891011121314#中序遍历树class Solution: def increasingBST(self, root): def inorder(node): if node: yield from inorder(node.left) yield node.val yield from inorder(node.right) ans = cur = TreeNode(None) for v in inorder(root): cur.right = TreeNode(v) cur = cur.right return ans.right 上例函数为生成器函数，生成器对象是一个可迭代对象，可以存储遍历结果","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]},{"title":"LeetCode-下一个更大元素1","slug":"LeetCode-下一个更大元素1","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2019/09/04/LeetCode-下一个更大元素1/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/04/LeetCode-下一个更大元素1/","excerpt":"","text":"题目地址 数据结构：栈、哈希表 思路：遍历nums2，哈希表存储每个元素后第一个大于它的元素。栈为递减栈，当遇到比栈顶元素大的元素，依次弹出元素，存入哈希表。最后遍历nums1，hash[nums[i]]组成的列表即为所求。 如 nums1 = [4,1,2], nums2 = [1,3,4,2]. stack=[1] hash[1]=3 hash[3]=-1(第一次出现该元素，hash值为-1) stack=[3] hash[3]=4 hash[4]=-1 stack=[4] stack=[4,2] hash[2]=-1 123456789101112131415class Solution(object): def nextGreaterElement(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: List[int] \"\"\" stack=[] hashmap=&#123;&#125; for num in nums2: while len(stack)&gt;0 and stack[-1]&lt;num : hashmap[stack.pop()]=num hashmap[num]=-1 stack.append(num) return [hashmap[i] for i in nums1]","author":"Zhiyuan","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/tags/LeetCode/"}]},{"title":"LeetCode-质数排列","slug":"LeetCode-质数排列","date":"un11fin11","updated":"un00fin00","comments":true,"path":"2019/09/02/LeetCode-质数排列/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/02/LeetCode-质数排列/","excerpt":"","text":"质数：质数是大于1的，且不能用小于它的两个正整数乘积表示。 首先求1-n中质数的个数 1234567891011def getnum(self,n:int) -&gt;int: num=0 for i in range(2,n+1): flag=True for j in range(2,int(i**0.5)+1): if i%j==0: flag=False break if flag==True: num+=1 return num 总的方案数就是质数排列数和非质数排列数的乘积 123456789101112def jiecheng(self,n:int) -&gt;int: sums=1 for i in range(1,n+1): sums*=i return sums%1000000007def numPrimeArrangements(self, n: int) -&gt; int: if n==1 or n==2: return 1 count=self.getnum(n) #调用类中的函数要使用self. num=self.jiecheng(count)*self.jiecheng(n-count) return num%1000000007","author":"Zhiyuan","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/tags/LeetCode/"},{"name":"数论","slug":"数论","permalink":"http://Zhiyuancs.github.io/tags/数论/"}]},{"title":"LeetCode-验证回文串","slug":"Python-回文字符串","date":"un55fin55","updated":"un11fin11","comments":true,"path":"2019/08/30/Python-回文字符串/","link":"","permalink":"http://Zhiyuancs.github.io/2019/08/30/Python-回文字符串/","excerpt":"","text":"filter(str.isalnum,s)1、filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。2、Python isalnum()方法isalnum() 方法检测字符串是否由字母和数字组成。","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]}]}