{"meta":{"title":"Zhiyuan的博客","subtitle":null,"description":"东北大学，中国矿业大学","author":"Zhiyuan","url":"http://Zhiyuancs.github.io","root":"/"},"pages":[],"posts":[{"title":"Mysql学习笔记（三）","slug":"Mysql学习笔记（三）","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2019/09/21/Mysql学习笔记（三）/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/21/Mysql学习笔记（三）/","excerpt":"","text":"select 字段列表form 表名where 查询筛选条件group by 指定分组的列列表having 指定分组后的筛选条件order by 排序列的列表limit 起始索引值，要查询的记录条数 1、分组查询：group by分组函数（聚合函数）：将多行的值进行统计返回一行结果sum() ; avg(); min(); max(); count().注：分组函数不能和与分组无关的列一起使用；分组查询时，查询的列可以是分组的条件 123456789SELECT SUM(salary)，COUNT(eid)，did FROM t_employGROUP BY did;SELECT did,COUNT(eid)FROM t_employWHERE salary&gt;10000AND did IS NOT NULLGROUP BY did; 2、条件中需要使用分组后的结果:having作用和where一样，但是执行顺序在分组之后 1234SELECT AVG(salary)FROM t_employGROUP BY didHAVING AVG(salary)&gt;9000; 3、order by：降序排列desc，升序排列ascSELECT * FROM t_employ ORDER BY salary DESC, eid ASC; 4、分页查询：limit index，size 5、子查询：当前查询依赖另一个查询的结果 123SELECT * FROM t_employ WHERE did=( SELECT did FROM t_employ WHERE ename='罗宾')； 三种类型：1、将子查询结果当做where查询的条件；2、当做临时表再次查询；3、作为主查询的判断条件，决定数据是否查询。exists型子查询 6、复制表 复制表结构：CREATE TABLE t_emp AS(SELECT * FROM t_employ WHERE 1=2);复制表结构+指定数据：where 条件 7、单行函数：处理一行返回一行结果SELECT UPPER(email) FROM t_employ;password():mysql数据库在将数据库管理员的信息进行保存时，会将密码加密保存。SELECT PASSWORD(&#39;123456&#39;) FROM DUAL; (dual练习表)","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://Zhiyuancs.github.io/tags/Mysql/"}]},{"title":"Mysql学习笔记（四）","slug":"Mysql学习笔记（四）","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2019/09/21/Mysql学习笔记（四）/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/21/Mysql学习笔记（四）/","excerpt":"","text":"","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://Zhiyuancs.github.io/tags/Mysql/"}]},{"title":"Mysql学习笔记（二）","slug":"Mysql学习笔记（二）","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2019/09/21/Mysql学习笔记（二）/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/21/Mysql学习笔记（二）/","excerpt":"","text":"1、自增长：如果一列是主键，并且数据类型是int，则支持自动增长，每次插入数据时，会自动加一表定义时加上 id INT(11) PRIMARY KEY AUTO_INCREMENT； 2、给查询到的列取别名，表也可以取别名SELECT 列名 AS ‘别 名’，列名 别名，…… FROM 表名3、去重复：将查询到的所有列的重复筛选掉SELECT DISTINCT 列名 FROM 表名 4、查询时 进行计算支持数学运算符，逻辑运算符：xor异或比较运算符：=，&gt;,&lt;,&gt;=,&lt;=集合：in(值列表)范围：between min and max 5、模糊查询:like ‘模糊字符串’%:代表0~n个任意字符_：代表一个任意字符 6、使用 ifnull(字段，默认值) 方法解决null值计算问题 7、字符串拼接时的null值（sql中的+不能拼接字符串）concat（字段和字符串列表）：自动将方法内的所有字符串进行拼接处理 8、联合查询多表查询时，需要指定连接条件才能避免笛卡尔积：表名.列名（指定是哪个表的列）多表查询时，最少指定n-1个连接条件才能避免笛卡尔积 9、内连接（INNER JOIN）sql99推荐多表连接使用：表1 join 表2 on 连接条件 join 表3 on 连接条件INNER JOIN（只有满足条件的数据才能被查询） 10、外连接(左外连接：左表不满足条件的数据也查询出来，右外连接）LEFT OUTER JOIN全连接 11、自连接：当前表连接当前表，使用别名区分","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://Zhiyuancs.github.io/tags/Mysql/"}]},{"title":"Mysql学习笔记（一）","slug":"Mysql学习笔记（一）","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2019/09/21/Mysql学习笔记（一）/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/21/Mysql学习笔记（一）/","excerpt":"","text":"DDL语句1、建库 1CREAT DATABASE 名字 不区分大小写，推荐关键字大写；单词间加‘_’mysql数据结构：char，varchar 12345CREATE TABLE tm_teammanager&#123; id INT(11), 'name' VARCHAR(30),#通过飘号选中的字符会保留字符串本意，不会当成关键字，~ gender CHAR(2)&#125; 2、查表结构 1DESC tm_teammanager 3、从删库到跑路备份为.sql文件 12DROP TABLE 表名 DROP DATABASE 4、修改表名 1ALTER TABLE oldname RENAME newname; 5、给表添加一列 1ALTER TABLE 表名 ADD COLUMN 名字 INT(3) (加上类型) 6、删除表一列 1ALTER TABLE 表名 DROP COLUMN 列名 7、给一列重命名change 1ALTER TABLE 表名 CHANGE 列名 新列名 数据类型 8、修改表列的数据类型modify 1ALTER TABLE 表名 MODIFY 列名 新数据类型 DML语句1、插入数据 12INSERT INTO 表名 VALUES(); #必须给所有列指定值 INSERT INTO 表名(id,列名……) VALUES(对应值); 2、查询 select 3、修改数据 update 1UPDATE 表名 SET 列名=值 WHERE id=2； 4、删除 delete 12DELETE FROM 表名 delete、drop、truncate区别 约束 constrains1、主键约束 primary key（字段值唯一非空）主键只能有一个1.1添加主键：创建表时添加约束CONSTRAINT PRIMARY KEY(列名)1.2 通过alter语句给表添加主键约束（表创建后添加） 123ALTER TABLE 表名 DROP PRIMARY KEY; #先删除原有主键约束 ALTER TABLE 表名 ADD PRIMARY KEY(列名) 或 ALTER TABLE 表名 MODIFY …… PRIMARY KEY 2、唯一键约束2.1 创建时添加2.2 修改表的指定列添加唯一键约束 1ALTER TABLE ^ MODIFY ^ ^ UNIQUE; 删除唯一键约束 1ALTER TABLE 表名 DROP INDEX 列名； 查看索引 SHOW INDEX FROM 表名 3、非空约束 not null3.1创建表时添加 123CREATE TABLE t_stu( &amp;emsp;&amp;emsp;id INT(11) NOT NULL; ); 删除非空约束 1alter table 表名 modify 列名 类型； 3.2修改列添加非空约束 1alter table 表名 modify 列名 类型 not null default “etc”； 4、默认值约束 default5、外键约束外键关联时，两张表建立外键的列数据类型必须相同，长度尽量一致 5.1修改表的指定列，添加外键约束 123ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY （当前表的指定列） references 关联的表名（指定要关联的列名）;ALTER TABLE t_stu ADD CONSTRAINT fk_cid FOREIGN KEY(cid) REFERENCES t_course(id); 删除外键约束：删除外键，然后才能删除外键对应的索引 12ALTER TEBLE 表名 DROP FOREIGN KEY(外键名) ALTER TABLE 表名 DROP INDEX 外键名； 索引需要删除，否则影响效率 5.2创建表时添加 1CONSTRAINT 外键名 FOREIGN KEY(列名) REFERENCES关联的表名（列名） 5.3删除被其他表关联的数据：当没有其他表引用该行数据可以删除5.4添加外键时指定级联删除或者级联置空","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://Zhiyuancs.github.io/tags/Mysql/"}]},{"title":"Unsupervised Video Summarization with Adversarial LSTM","slug":"3","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2019/09/21/3/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/21/3/","excerpt":"","text":"&emsp;&emsp;本文提出一个由summarizer和discriminator组成的生成对抗框架。目的是选择视频的稀疏子集，使得视频和摘要的表示误差最小。 &emsp;&emsp;原始视频的特征是通过GAN和LSTM提取的，GAN以像素为基础提取特征，LSTM捕捉帧之间的长期依赖关系，得到深度特征向量。由于明确深度特征间的合适距离困难，所以由左边结构转换为右边的结构。 论文理论基础：Variational Autoencoder(VAE)，GAN Model Overview&emsp;&emsp;CNN输出的是视频帧的深度特征（deep features x），sLSTM（selector LSTM）在这些帧中选择一个子集，eLSTM(encoder LSTM)将选择的帧序列编码成向量 e 。sLSTM生成每一个帧的标准化重要性得分s，结合x，输入到eLSTM中。dLSTM(decoder LSTM)以e为输入，重构了输入视频的特征序列。鉴别器（discriminator）用来区分原始和摘要视频帧间的特征，用于估计两者之间的representation error。 &emsp;&emsp;本实验中使用二元序列分类器（a binary sequence classifier），所以鉴别器为cLSTM(classifier LSTM)，输出是二分类。 &emsp;&emsp;生成对抗训练的关键是引入一个额外的帧选择器Sp（基于先验分布的，例如均匀分布）。利用概率Sp选择一个子集作为eLSTM的输入，以相同的pipeline生成一系列值，用于计算误差。 Reconstruction loss Lreconst&emsp;&emsp;没有采用传统的欧式距离，而是基于cLSTM的隐藏层表示。cLSTM最后一个隐藏层的输出**表示一个紧凑的特征向量，它捕捉了x（特征序列）的长距离依赖关系。Lre是对数似然的期望。 Loss of GAN这里的先验分布使用均匀分布。 &emsp;&emsp;cLSTM(·)是一个二元的softmax输出。更新参数使用随机梯度变分bayes估计（Stochastic Gradient Variational Bayes estimation） 正则化训练Summary-Length Regularization M帧数量，*希望选择帧数量的百分比 Diversity Regularization 基于DPP 排斥正则化器（Repelling regularizer） Keyframe Regularization","author":"Zhiyuan","categories":[{"name":"AI","slug":"AI","permalink":"http://Zhiyuancs.github.io/categories/AI/"}],"tags":[{"name":"视频摘要","slug":"视频摘要","permalink":"http://Zhiyuancs.github.io/tags/视频摘要/"}]},{"title":"Deep Reinforcement Learning for Unsupervised V-S ","slug":"Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2019/09/15/Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/15/Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization/","excerpt":"","text":"Abstract&emsp;&emsp;本文创新点：1、构建DSN网络；2、设计一个新的奖励函数（基于帧的多样性和代表性）；3、设计一个端到端的、基于强化学习的框架来训练网络。 Introduction&emsp;&emsp;DPP-LSTM效果较好，但是视频摘要的评价时，人类具有更多的主观性，所以非监督方法很有必要。&emsp;&emsp;本文的DSN网络：encoder：CNN（在视频帧上进行特征提取）；decoder：BiLSTM（产生概率分布来选择帧）。RL（增强学习）：通过迭代方式训练agent。&emsp;&emsp;主要贡献：将无监督方法扩展到监督版本，以利用标签；首次将RL应用到无监督视频摘要上。 Model OverviewDeep Summarization Network&emsp;&emsp;采用encoder-decoder结构，CNN选用在ImageNet上预训练好的GoogLeNet，从它倒数第二层提取出视觉特征向量x_{t}。LSTM用来捕获视频帧之间的长时间依赖性。训练中只更新decoder。 &emsp;&emsp;将BiLSTM网络的正向和反向的隐藏层输出拼接作为相应的隐状态，网络输入为视觉特征向量。全连接层结束于sigmoid函数，得出每个帧选择的概率分布，帧是否选择服从二项分布。视频摘要由这些选择的帧组成。 Diversity-Representativeness Reward Function&emsp;&emsp;训练时DSN的目的是最大化奖励函数。&emsp;&emsp;Diversity reward:通过计算选择帧之间的差异性（取平均值）来度量多样性， &emsp;&emsp;公式3忽视了序列数据时间上的关联性，事实上，时间相距较大的两个相似帧对故事线的构筑都很重要。所以设置如下， 入控制时间距离。 &emsp;&emsp;Representativeness reward:视频摘要代表性的度量是一个k-medoids问题， &emsp;&emsp;reward function使用这两个相加，训练时，保持这两个数量级一致。 Training with Policy Gradient&emsp;&emsp;这里介绍使用的强化学习的训练方法，和一些tricks。&emsp;&emsp;因为选择更多的帧也能提高reward，所以加入正则项。和防止过拟合的改进。&emsp;&emsp;这里给出更新参数的公式和最优化算法（Adam），详情见论文。 Summary Generation&emsp;&emsp;通过最大化得分选择子热点，同时控制帧数量不超过总长度15%。热点得分是通过平均化同一个热点中帧的得分来计算的。时间分割算法使用KTS。","author":"Zhiyuan","categories":[{"name":"AI","slug":"AI","permalink":"http://Zhiyuancs.github.io/categories/AI/"}],"tags":[{"name":"视频摘要","slug":"视频摘要","permalink":"http://Zhiyuancs.github.io/tags/视频摘要/"}]},{"title":"Video Summarization with LSTM","slug":"Video-Summarization-with-Long-Short-term-Memory","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2019/09/15/Video-Summarization-with-Long-Short-term-Memory/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/15/Video-Summarization-with-Long-Short-term-Memory/","excerpt":"","text":"Abstract&emsp;&emsp;这篇文章提出一个新奇的监督学习方法用来进行视频摘要，用来自动选择关键帧或者关键子热点。将这项任务看成一个结构预测问题（structured prediction problem），主要思路是用LSTM对帧的时间依赖性进行建模。 Introduction&emsp;&emsp;视频摘要如今有两个重要的方法：关键帧选择（keyframe selection，选择一些具有代表性的帧来组成摘要）；关键子热点选择（Key subshot selection，选择一系列在短时间类连续的帧组成摘要，即选择视频中具有代表性的每个时间点，将这些时间点的帧选择）。&emsp;&emsp;非监督学习方法：通过直观标准选择帧&emsp;&emsp;监督学习方法：通过视频帧的标注训练模型，使模型自动学习选择帧的标准。&emsp;&emsp;模型输入是视频的帧序列，输出是一个二元数组（表示这些帧是否选择）。由此得到启发使用LSTM。视频帧内部的依赖性是复杂且不均匀的。&emsp;&emsp;使用LSTM从时间上建立帧的联系，比从视觉上建立联系好（比如不同帧的相似性）。时间上相近的帧，包含的信息会冗余且相似。但是相似的帧包含的信息并不一定相同，且时间不一定相近。使用LSTM来学习时间线。&emsp;&emsp;这篇文章研究如何将LSTM及其变体应用到Video Summarization中。将LSTM与DPP（determinantalpoint process）结合，等一些改进方法。 Model OverviewvsLSTM网络结构： MLP（多层感知机）：输出为标量 使用SGD更新参数，这里是监督学习的方法，使用帧级别重要性得分（连续变量）或者选择的关键帧编码（二元向量） 由于LSTM（查全率高，查准率低），DPP（查准率高，查全率低），现在将这两个结合， DPP（行列式点过程）：DPP编码了从全集中选取任意一个子集的概率 z是子集,Z为全集，L为N*N的核矩阵（记录任意连个帧之间的相似性，实对称半正定方阵），det()为行列式的值，I是N*N的单位矩阵，子集z的概率与矩阵Lz的主子式行列式的值成正比。如果子集中有两个相同的元素时，det(Lz)将等于0。Lz是z在Z中标号对应元素组成的子方阵。 关于DDP的数学证明：https://blog.csdn.net/qq_23947237/article/details/90698325 dppLSTM： MLP是由256个sigmoid隐单元、sigmoid和线性输出单元组成的单层神经网络，两个MLP（第一个计算frame-level importance,第二个计算相似性） Learning： 参数的学习使用MLE（最大似然估计），采用阶段化优化策略：首先训练MLP1和LSTM（vsLSTM）；接下来通过最大化dpp模型指定关键帧的可能性来训练所有mlp和lstm层。 具体细节见论文及增刊","author":"Zhiyuan","categories":[{"name":"AI","slug":"AI","permalink":"http://Zhiyuancs.github.io/categories/AI/"}],"tags":[{"name":"视频摘要","slug":"视频摘要","permalink":"http://Zhiyuancs.github.io/tags/视频摘要/"}]},{"title":"Hexo-Hueman Insight-Search配置","slug":"Hexo-Hueman-Insight-Search配置","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2019/09/09/Hexo-Hueman-Insight-Search配置/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/09/Hexo-Hueman-Insight-Search配置/","excerpt":"","text":"博客中的搜索功能一直无法使用，使用npm install -S hexo-generator-json-content安装插件后，仍然无法使用。 通过阅读hexo-generator-json-content的源码配置文件后得知，还需要对hexo的config文件做相应配置： 1234567891011121314151617181920212223242526272829303132333435363738jsonContent: meta: true dafts: false file: content.json keywords: undefined dateFormat: undefined pages: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: false text: true raw: false content: false author: true posts: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: false text: true raw: false content: false author: true categories: true tags: true","author":"Zhiyuan","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://Zhiyuancs.github.io/tags/Hexo/"}]},{"title":"Python3 while-else、//","slug":"Python3-while-else、","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2019/09/08/Python3-while-else、/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/08/Python3-while-else、/","excerpt":"","text":"在LeetCode-自除数答案中学到的几个语法和技巧， While-else: 1、在Python中，else 可以和 while 循环搭配使用，当 while 循环正常执行完的情况下，执行 else 输出； 2、如果当 while 循环中执行了跳出循环的语句，比如 break，将不执行 else 代码块的内容。 //:向下取整 12345678910class Solution: def selfDividingNumbers(self, left: int, right: int) -&gt; List[int]: ans = [] for num in range(left,right + 1): copy = num while copy &gt; 0: div, copy = copy % 10, copy // 10 if div == 0 or num % div != 0: break else: ans.append(num) # while … else 在循环条件为 false 时执行 else 语句块 return ans","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]},{"title":"Python3 Counter类、all()","slug":"Python3-Counter类、all","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2019/09/06/Python3-Counter类、all/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/06/Python3-Counter类、all/","excerpt":"","text":"Counter类(计数器) Counter类返回一个字典，统计每个元素出现次数，可以更新 123456import collectionsobj = collections.Counter(['11','22'])obj.update(['22','55'])print(obj)#输出：Counter(&#123;'22': 2, '11': 1, '55': 1&#125;) all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。 12345678910class Solution: def countCharacters(self, words: List[str], chars: str) -&gt; int: count=collections.Counter(chars) sumlen=0 for word in words: c=collections.Counter(word) #list类型作为参数 if all([count[i]&gt;=c[i] for i in word]): sumlen+=len(word) return sumlen dict.item()返回字典键值对组成的元组","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]},{"title":"yield from简单理解","slug":"yield-from简单理解","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2019/09/05/yield-from简单理解/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/05/yield-from简单理解/","excerpt":"","text":"yieldyield简单理解可以看成return，但是函数执行yield后会返回值但是不会终止。 123456789# yield返回值, 生成器def gen(): for x in [\"a\", \"b\", \"c\"]: yield xfor i in gen(): print(i)# a b c 在函数外部不能使用yield from（yield也不行）。 yield fromyield from用来调用生成器，可以用于递归函数中，或者调用的函数中包含yield语句 1234567891011121314#中序遍历树class Solution: def increasingBST(self, root): def inorder(node): if node: yield from inorder(node.left) yield node.val yield from inorder(node.right) ans = cur = TreeNode(None) for v in inorder(root): cur.right = TreeNode(v) cur = cur.right return ans.right 上例函数为生成器函数，生成器对象是一个可迭代对象，可以存储遍历结果","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]},{"title":"LeetCode-下一个更大元素1","slug":"LeetCode-下一个更大元素1","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2019/09/04/LeetCode-下一个更大元素1/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/04/LeetCode-下一个更大元素1/","excerpt":"","text":"题目地址 数据结构：栈、哈希表 思路：遍历nums2，哈希表存储每个元素后第一个大于它的元素。栈为递减栈，当遇到比栈顶元素大的元素，依次弹出元素，存入哈希表。最后遍历nums1，hash[nums[i]]组成的列表即为所求。 如 nums1 = [4,1,2], nums2 = [1,3,4,2]. stack=[1] hash[1]=3 hash[3]=-1(第一次出现该元素，hash值为-1) stack=[3] hash[3]=4 hash[4]=-1 stack=[4] stack=[4,2] hash[2]=-1 123456789101112131415class Solution(object): def nextGreaterElement(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: List[int] \"\"\" stack=[] hashmap=&#123;&#125; for num in nums2: while len(stack)&gt;0 and stack[-1]&lt;num : hashmap[stack.pop()]=num hashmap[num]=-1 stack.append(num) return [hashmap[i] for i in nums1]","author":"Zhiyuan","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/tags/LeetCode/"}]},{"title":"LeetCode-质数排列","slug":"LeetCode-质数排列","date":"un11fin11","updated":"un00fin00","comments":true,"path":"2019/09/02/LeetCode-质数排列/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/02/LeetCode-质数排列/","excerpt":"","text":"质数：质数是大于1的，且不能用小于它的两个正整数乘积表示。 首先求1-n中质数的个数 1234567891011def getnum(self,n:int) -&gt;int: num=0 for i in range(2,n+1): flag=True for j in range(2,int(i**0.5)+1): if i%j==0: flag=False break if flag==True: num+=1 return num 总的方案数就是质数排列数和非质数排列数的乘积 123456789101112def jiecheng(self,n:int) -&gt;int: sums=1 for i in range(1,n+1): sums*=i return sums%1000000007def numPrimeArrangements(self, n: int) -&gt; int: if n==1 or n==2: return 1 count=self.getnum(n) #调用类中的函数要使用self. num=self.jiecheng(count)*self.jiecheng(n-count) return num%1000000007","author":"Zhiyuan","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/tags/LeetCode/"},{"name":"数论","slug":"数论","permalink":"http://Zhiyuancs.github.io/tags/数论/"}]},{"title":"LeetCode-验证回文串","slug":"Python-回文字符串","date":"un55fin55","updated":"un11fin11","comments":true,"path":"2019/08/30/Python-回文字符串/","link":"","permalink":"http://Zhiyuancs.github.io/2019/08/30/Python-回文字符串/","excerpt":"","text":"filter(str.isalnum,s)1、filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。2、Python isalnum()方法isalnum() 方法检测字符串是否由字母和数字组成。","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]}]}