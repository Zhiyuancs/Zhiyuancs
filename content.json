{"meta":{"title":"Zhiyuan的博客","subtitle":null,"description":"东北大学，中国矿业大学","author":"Zhiyuan","url":"http://Zhiyuancs.github.io","root":"/"},"pages":[],"posts":[{"title":"Deep Reinforcement Learning for Unsupervised V-S ","slug":"Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2019/09/15/Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/15/Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization/","excerpt":"","text":"Abstract&emsp;&emsp;本文创新点：1、构建DSN网络；2、设计一个新的奖励函数（基于帧的多样性和代表性）；3、设计一个端到端的、基于强化学习的框架来训练网络。 Introduction&emsp;&emsp;DPP-LSTM效果较好，但是视频摘要的评价时，人类具有更多的主观性，所以非监督方法很有必要。&emsp;&emsp;本文的DSN网络：encoder：CNN（在视频帧上进行特征提取）；decoder：BiLSTM（产生概率分布来选择帧）。RL（增强学习）：通过迭代方式训练agent。&emsp;&emsp;主要贡献：将无监督方法扩展到监督版本，以利用标签；首次将RL应用到无监督视频摘要上。 Model OverviewDeep Summarization Network&emsp;&emsp;采用encoder-decoder结构，CNN选用在ImageNet上预训练好的GoogLeNet，从它倒数第二层提取出视觉特征向量x_{t}。LSTM用来捕获视频帧之间的长时间依赖性。训练中只更新decoder。 &emsp;&emsp;将BiLSTM网络的正向和反向的隐藏层输出拼接作为相应的隐状态，网络输入为视觉特征向量。全连接层结束于sigmoid函数，得出每个帧选择的概率分布，帧是否选择服从二项分布。视频摘要由这些选择的帧组成。 Diversity-Representativeness Reward Function&emsp;&emsp;训练时DSN的目的是最大化奖励函数。&emsp;&emsp;Diversity reward:通过计算选择帧之间的差异性（取平均值）来度量多样性， &emsp;&emsp;公式3忽视了序列数据时间上的关联性，事实上，时间相距较大的两个相似帧对故事线的构筑都很重要。所以设置如下， 入控制时间距离。 &emsp;&emsp;Representativeness reward:视频摘要代表性的度量是一个k-medoids问题， &emsp;&emsp;reward function使用这两个相加，训练时，保持这两个数量级一致。 Training with Policy Gradient&emsp;&emsp;这里介绍使用的强化学习的训练方法，和一些tricks。&emsp;&emsp;因为选择更多的帧也能提高reward，所以加入正则项。和防止过拟合的改进。&emsp;&emsp;这里给出更新参数的公式和最优化算法（Adam），详情见论文。 Summary Generation&emsp;&emsp;通过最大化得分选择子热点，同时控制帧数量不超过总长度15%。热点得分是通过平均化同一个热点中帧的得分来计算的。时间分割算法使用KTS。","author":"Zhiyuan","categories":[{"name":"AI","slug":"AI","permalink":"http://Zhiyuancs.github.io/categories/AI/"}],"tags":[{"name":"视频摘要","slug":"视频摘要","permalink":"http://Zhiyuancs.github.io/tags/视频摘要/"}]},{"title":"Video Summarization with LSTM","slug":"Video-Summarization-with-Long-Short-term-Memory","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2019/09/15/Video-Summarization-with-Long-Short-term-Memory/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/15/Video-Summarization-with-Long-Short-term-Memory/","excerpt":"","text":"Abstract&emsp;&emsp;这篇文章提出一个新奇的监督学习方法用来进行视频摘要，用来自动选择关键帧或者关键子热点。将这项任务看成一个结构预测问题（structured prediction problem），主要思路是用LSTM对帧的时间依赖性进行建模。 Introduction&emsp;&emsp;视频摘要如今有两个重要的方法：关键帧选择（keyframe selection，选择一些具有代表性的帧来组成摘要）；关键子热点选择（Key subshot selection，选择一系列在短时间类连续的帧组成摘要，即选择视频中具有代表性的每个时间点，将这些时间点的帧选择）。&emsp;&emsp;非监督学习方法：通过直观标准选择帧&emsp;&emsp;监督学习方法：通过视频帧的标注训练模型，使模型自动学习选择帧的标准。&emsp;&emsp;模型输入是视频的帧序列，输出是一个二元数组（表示这些帧是否选择）。由此得到启发使用LSTM。视频帧内部的依赖性是复杂且不均匀的。&emsp;&emsp;使用LSTM从时间上建立帧的联系，比从视觉上建立联系好（比如不同帧的相似性）。时间上相近的帧，包含的信息会冗余且相似。但是相似的帧包含的信息并不一定相同，且时间不一定相近。使用LSTM来学习时间线。&emsp;&emsp;这篇文章研究如何将LSTM及其变体应用到Video Summarization中。将LSTM与DPP（determinantalpoint process）结合，等一些改进方法。 Model OverviewvsLSTM网络结构： MLP（多层感知机）：输出为标量 使用SGD更新参数，这里是监督学习的方法，使用帧级别重要性得分（连续变量）或者选择的关键帧编码（二元向量） 由于LSTM（查全率高，查准率低），DPP（查准率高，查全率低），现在将这两个结合， DPP（行列式点过程）：DPP编码了从全集中选取任意一个子集的概率 z是子集,Z为全集，L为N*N的核矩阵（记录任意连个帧之间的相似性，实对称半正定方阵），det()为行列式的值，I是N*N的单位矩阵，子集z的概率与矩阵Lz的主子式行列式的值成正比。如果子集中有两个相同的元素时，det(Lz)将等于0。Lz是z在Z中标号对应元素组成的子方阵。 关于DDP的数学证明：https://blog.csdn.net/qq_23947237/article/details/90698325 dppLSTM： MLP是由256个sigmoid隐单元、sigmoid和线性输出单元组成的单层神经网络，两个MLP（第一个计算frame-level importance,第二个计算相似性） Learning： 参数的学习使用MLE（最大似然估计），采用阶段化优化策略：首先训练MLP1和LSTM（vsLSTM）；接下来通过最大化dpp模型指定关键帧的可能性来训练所有mlp和lstm层。 具体细节见论文及增刊","author":"Zhiyuan","categories":[{"name":"AI","slug":"AI","permalink":"http://Zhiyuancs.github.io/categories/AI/"}],"tags":[{"name":"视频摘要","slug":"视频摘要","permalink":"http://Zhiyuancs.github.io/tags/视频摘要/"}]},{"title":"Hexo-Hueman Insight-Search配置","slug":"Hexo-Hueman-Insight-Search配置","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2019/09/09/Hexo-Hueman-Insight-Search配置/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/09/Hexo-Hueman-Insight-Search配置/","excerpt":"","text":"博客中的搜索功能一直无法使用，使用npm install -S hexo-generator-json-content安装插件后，仍然无法使用。 通过阅读hexo-generator-json-content的源码配置文件后得知，还需要对hexo的config文件做相应配置： 1234567891011121314151617181920212223242526272829303132333435363738jsonContent: meta: true dafts: false file: content.json keywords: undefined dateFormat: undefined pages: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: false text: true raw: false content: false author: true posts: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: false text: true raw: false content: false author: true categories: true tags: true","author":"Zhiyuan","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://Zhiyuancs.github.io/tags/Hexo/"}]},{"title":"Python3 while-else、//","slug":"Python3-while-else、","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2019/09/08/Python3-while-else、/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/08/Python3-while-else、/","excerpt":"","text":"在LeetCode-自除数答案中学到的几个语法和技巧， While-else: 1、在Python中，else 可以和 while 循环搭配使用，当 while 循环正常执行完的情况下，执行 else 输出； 2、如果当 while 循环中执行了跳出循环的语句，比如 break，将不执行 else 代码块的内容。 //:向下取整 12345678910class Solution: def selfDividingNumbers(self, left: int, right: int) -&gt; List[int]: ans = [] for num in range(left,right + 1): copy = num while copy &gt; 0: div, copy = copy % 10, copy // 10 if div == 0 or num % div != 0: break else: ans.append(num) # while … else 在循环条件为 false 时执行 else 语句块 return ans","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]},{"title":"Python3 Counter类、all()","slug":"Python3-Counter类、all","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2019/09/06/Python3-Counter类、all/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/06/Python3-Counter类、all/","excerpt":"","text":"Counter类(计数器) Counter类返回一个字典，统计每个元素出现次数，可以更新 123456import collectionsobj = collections.Counter(['11','22'])obj.update(['22','55'])print(obj)#输出：Counter(&#123;'22': 2, '11': 1, '55': 1&#125;) all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。 12345678910class Solution: def countCharacters(self, words: List[str], chars: str) -&gt; int: count=collections.Counter(chars) sumlen=0 for word in words: c=collections.Counter(word) #list类型作为参数 if all([count[i]&gt;=c[i] for i in word]): sumlen+=len(word) return sumlen dict.item()返回字典键值对组成的元组","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]},{"title":"yield from简单理解","slug":"yield-from简单理解","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2019/09/05/yield-from简单理解/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/05/yield-from简单理解/","excerpt":"","text":"yieldyield简单理解可以看成return，但是函数执行yield后会返回值但是不会终止。 123456789# yield返回值, 生成器def gen(): for x in [\"a\", \"b\", \"c\"]: yield xfor i in gen(): print(i)# a b c 在函数外部不能使用yield from（yield也不行）。 yield fromyield from用来调用生成器，可以用于递归函数中，或者调用的函数中包含yield语句 1234567891011121314#中序遍历树class Solution: def increasingBST(self, root): def inorder(node): if node: yield from inorder(node.left) yield node.val yield from inorder(node.right) ans = cur = TreeNode(None) for v in inorder(root): cur.right = TreeNode(v) cur = cur.right return ans.right 上例函数为生成器函数，生成器对象是一个可迭代对象，可以存储遍历结果","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]},{"title":"LeetCode-下一个更大元素1","slug":"LeetCode-下一个更大元素1","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2019/09/04/LeetCode-下一个更大元素1/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/04/LeetCode-下一个更大元素1/","excerpt":"","text":"题目地址 数据结构：栈、哈希表 思路：遍历nums2，哈希表存储每个元素后第一个大于它的元素。栈为递减栈，当遇到比栈顶元素大的元素，依次弹出元素，存入哈希表。最后遍历nums1，hash[nums[i]]组成的列表即为所求。 如 nums1 = [4,1,2], nums2 = [1,3,4,2]. stack=[1] hash[1]=3 hash[3]=-1(第一次出现该元素，hash值为-1) stack=[3] hash[3]=4 hash[4]=-1 stack=[4] stack=[4,2] hash[2]=-1 123456789101112131415class Solution(object): def nextGreaterElement(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: List[int] \"\"\" stack=[] hashmap=&#123;&#125; for num in nums2: while len(stack)&gt;0 and stack[-1]&lt;num : hashmap[stack.pop()]=num hashmap[num]=-1 stack.append(num) return [hashmap[i] for i in nums1]","author":"Zhiyuan","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/tags/LeetCode/"}]},{"title":"LeetCode-质数排列","slug":"LeetCode-质数排列","date":"un11fin11","updated":"un00fin00","comments":true,"path":"2019/09/02/LeetCode-质数排列/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/02/LeetCode-质数排列/","excerpt":"","text":"质数：质数是大于1的，且不能用小于它的两个正整数乘积表示。 首先求1-n中质数的个数 1234567891011def getnum(self,n:int) -&gt;int: num=0 for i in range(2,n+1): flag=True for j in range(2,int(i**0.5)+1): if i%j==0: flag=False break if flag==True: num+=1 return num 总的方案数就是质数排列数和非质数排列数的乘积 123456789101112def jiecheng(self,n:int) -&gt;int: sums=1 for i in range(1,n+1): sums*=i return sums%1000000007def numPrimeArrangements(self, n: int) -&gt; int: if n==1 or n==2: return 1 count=self.getnum(n) #调用类中的函数要使用self. num=self.jiecheng(count)*self.jiecheng(n-count) return num%1000000007","author":"Zhiyuan","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/tags/LeetCode/"},{"name":"数论","slug":"数论","permalink":"http://Zhiyuancs.github.io/tags/数论/"}]},{"title":"LeetCode-验证回文串","slug":"Python-回文字符串","date":"un55fin55","updated":"un11fin11","comments":true,"path":"2019/08/30/Python-回文字符串/","link":"","permalink":"http://Zhiyuancs.github.io/2019/08/30/Python-回文字符串/","excerpt":"","text":"filter(str.isalnum,s)1、filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。2、Python isalnum()方法isalnum() 方法检测字符串是否由字母和数字组成。","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]}]}