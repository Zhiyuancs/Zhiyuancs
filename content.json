{"meta":{"title":"Zhiyuan的博客","subtitle":null,"description":"东北大学，中国矿业大学","author":"Zhiyuan","url":"http://Zhiyuancs.github.io","root":"/"},"pages":[],"posts":[{"title":"Python3 while-else、//","slug":"Python3-while-else、","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2019/09/08/Python3-while-else、/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/08/Python3-while-else、/","excerpt":"","text":"在LeetCode-自除数答案中学到的几个语法和技巧， While-else: 1、在Python中，else 可以和 while 循环搭配使用，当 while 循环正常执行完的情况下，执行 else 输出； 2、如果当 while 循环中执行了跳出循环的语句，比如 break，将不执行 else 代码块的内容。 //:向下取整 12345678910class Solution: def selfDividingNumbers(self, left: int, right: int) -&gt; List[int]: ans = [] for num in range(left,right + 1): copy = num while copy &gt; 0: div, copy = copy % 10, copy // 10 if div == 0 or num % div != 0: break else: ans.append(num) # while … else 在循环条件为 false 时执行 else 语句块 return ans","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]},{"title":"Python3 Counter类、all()","slug":"Python3-Counter类、all","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2019/09/06/Python3-Counter类、all/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/06/Python3-Counter类、all/","excerpt":"","text":"Counter类(计数器) Counter类返回一个字典，统计每个元素出现次数，可以更新 123456import collectionsobj = collections.Counter(['11','22'])obj.update(['22','55'])print(obj)#输出：Counter(&#123;'22': 2, '11': 1, '55': 1&#125;) all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。 12345678910class Solution: def countCharacters(self, words: List[str], chars: str) -&gt; int: count=collections.Counter(chars) sumlen=0 for word in words: c=collections.Counter(word) #list类型作为参数 if all([count[i]&gt;=c[i] for i in word]): sumlen+=len(word) return sumlen dict.item()返回字典键值对组成的元组","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]},{"title":"yield from简单理解","slug":"yield-from简单理解","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2019/09/05/yield-from简单理解/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/05/yield-from简单理解/","excerpt":"","text":"yieldyield简单理解可以看成return，但是函数执行yield后会返回值但是不会终止。 123456789# yield返回值, 生成器def gen(): for x in [\"a\", \"b\", \"c\"]: yield xfor i in gen(): print(i)# a b c 在函数外部不能使用yield from（yield也不行）。 yield fromyield from用来调用生成器，可以用于递归函数中，或者调用的函数中包含yield语句 1234567891011121314#中序遍历树class Solution: def increasingBST(self, root): def inorder(node): if node: yield from inorder(node.left) yield node.val yield from inorder(node.right) ans = cur = TreeNode(None) for v in inorder(root): cur.right = TreeNode(v) cur = cur.right return ans.right 上例函数为生成器函数，生成器对象是一个可迭代对象，可以存储遍历结果","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]},{"title":"LeetCode-下一个更大元素1","slug":"LeetCode-下一个更大元素1","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2019/09/04/LeetCode-下一个更大元素1/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/04/LeetCode-下一个更大元素1/","excerpt":"","text":"题目地址 数据结构：栈、哈希表 思路：遍历nums2，哈希表存储每个元素后第一个大于它的元素。栈为递减栈，当遇到比栈顶元素大的元素，依次弹出元素，存入哈希表。最后遍历nums1，hash[nums[i]]组成的列表即为所求。 如 nums1 = [4,1,2], nums2 = [1,3,4,2]. stack=[1] hash[1]=3 hash[3]=-1(第一次出现该元素，hash值为-1) stack=[3] hash[3]=4 hash[4]=-1 stack=[4] stack=[4,2] hash[2]=-1 123456789101112131415class Solution(object): def nextGreaterElement(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: List[int] \"\"\" stack=[] hashmap=&#123;&#125; for num in nums2: while len(stack)&gt;0 and stack[-1]&lt;num : hashmap[stack.pop()]=num hashmap[num]=-1 stack.append(num) return [hashmap[i] for i in nums1]","author":"Zhiyuan","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/tags/LeetCode/"}]},{"title":"LeetCode-质数排列","slug":"LeetCode-质数排列","date":"un11fin11","updated":"un00fin00","comments":true,"path":"2019/09/02/LeetCode-质数排列/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/02/LeetCode-质数排列/","excerpt":"","text":"质数：质数是大于1的，且不能用小于它的两个正整数乘积表示。 首先求1-n中质数的个数 1234567891011def getnum(self,n:int) -&gt;int: num=0 for i in range(2,n+1): flag=True for j in range(2,int(i**0.5)+1): if i%j==0: flag=False break if flag==True: num+=1 return num 总的方案数就是质数排列数和非质数排列数的乘积 123456789101112def jiecheng(self,n:int) -&gt;int: sums=1 for i in range(1,n+1): sums*=i return sums%1000000007def numPrimeArrangements(self, n: int) -&gt; int: if n==1 or n==2: return 1 count=self.getnum(n) #调用类中的函数要使用self. num=self.jiecheng(count)*self.jiecheng(n-count) return num%1000000007","author":"Zhiyuan","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/tags/LeetCode/"},{"name":"数论","slug":"数论","permalink":"http://Zhiyuancs.github.io/tags/数论/"}]},{"title":"LeetCode-验证回文串","slug":"Python-回文字符串","date":"un55fin55","updated":"un11fin11","comments":true,"path":"2019/08/30/Python-回文字符串/","link":"","permalink":"http://Zhiyuancs.github.io/2019/08/30/Python-回文字符串/","excerpt":"","text":"filter(str.isalnum,s)1、filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。2、Python isalnum()方法isalnum() 方法检测字符串是否由字母和数字组成。","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/tags/LeetCode/"}]}]}