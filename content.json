{"meta":{"title":"Zhiyuan的博客","subtitle":null,"description":"东北大学，中国矿业大学","author":"Zhiyuan","url":"http://Zhiyuancs.github.io","root":"/"},"pages":[],"posts":[{"title":"JDBC连接池& JDBCTemplate","slug":"JDBC连接池","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2019/10/10/JDBC连接池/","link":"","permalink":"http://Zhiyuancs.github.io/2019/10/10/JDBC连接池/","excerpt":"","text":"数据库连接池 概念：其实就是一个容器(集合)，存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处： 节约资源 用户访问高效 实现： 标准接口：DataSource javax.sql包下的 方法： 获取连接：getConnection() 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 一般我们不去实现它，有数据库厂商来实现 C3P0：数据库连接池技术 Druid：数据库连接池实现技术，由阿里巴巴提供的 C3P0：数据库连接池技术 步骤： 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， 不要忘记导入数据库驱动jar包 定义配置文件： 名称： c3p0.properties 或者 c3p0-config.xml 路径：直接将文件放在src目录下即可。 创建核心对象 数据库连接池对象 ComboPooledDataSource 获取连接： getConnection 代码： //1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); //2. 获取连接对象 Connection conn = ds.getConnection(); Druid：数据库连接池实现技术，由阿里巴巴提供的 步骤： 导入jar包 druid-1.0.9.jar 定义配置文件： 是properties形式的 可以叫任意名称，可以放在任意目录下 加载配置文件。Properties 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 获取连接：getConnection 12345678910111213141516 * 代码： //3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(\"druid.properties\"); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection();2. 定义工具类 1. 定义一个类 JDBCUtils 2. 提供静态代码块加载配置文件，初始化连接池对象 3. 提供方法 1. 获取连接方法：通过数据库连接池获取连接 2. 释放资源 3. 获取连接池的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849* 代码： public class JDBCUtils &#123; //1.定义成员变量 DataSource private static DataSource ds ; static&#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\")); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; /** * 释放资源 */ public static void close(Statement stmt,Connection conn)&#123; /* if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;*/ close(null,stmt,conn); &#125; ​ 12345678910111213141516171819202122232425262728293031323334 public static void close(ResultSet rs , Statement stmt, Connection conn)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 获取连接池方法 */ public static DataSource getDataSource()&#123; return ds; &#125;&#125; Spring JDBC Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 步骤： 导入jar包 创建JdbcTemplate对象。依赖于数据源DataSource JdbcTemplate template = new JdbcTemplate(ds); 调用JdbcTemplate的方法来完成CRUD的操作 update():执行DML语句。增、删、改语句 queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 注意：这个方法查询的结果集长度只能是1 queryForList():查询结果将结果集封装为list集合 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 query():查询结果，将结果封装为JavaBean对象 query的参数：RowMapper 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) queryForObject：查询结果，将结果封装为对象 一般用于聚合函数的查询 123456789101112131415161718192021222324252627284. 练习： * 需求： 1. 修改1号数据的 salary 为 10000 2. 添加一条记录 3. 删除刚才添加的记录 4. 查询id为1的记录，将其封装为Map集合 5. 查询所有记录，将其封装为List 6. 查询所有记录，将其封装为Emp对象的List集合 7. 查询总记录数 * 代码： import cn.itcast.domain.Emp; import cn.itcast.utils.JDBCUtils; import org.junit.Test; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import java.sql.Date; import java.sql.ResultSet; import java.sql.SQLException; import java.util.List; import java.util.Map; public class JdbcTemplateDemo2 &#123; //Junit单元测试，可以让方法独立执行 ​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//1. 获取JDBCTemplate对象private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());/** * 1. 修改1号数据的 salary 为 10000 */@Testpublic void test1()&#123; //2. 定义sql String sql = \"update emp set salary = 10000 where id = 1001\"; //3. 执行sql int count = template.update(sql); System.out.println(count);&#125; /** * 2. 添加一条记录 */@Testpublic void test2()&#123; String sql = \"insert into emp(id,ename,dept_id) values(?,?,?)\"; int count = template.update(sql, 1015, \"郭靖\", 10); System.out.println(count); &#125; /** * 3.删除刚才添加的记录 */@Testpublic void test3()&#123; String sql = \"delete from emp where id = ?\"; int count = template.update(sql, 1015); System.out.println(count);&#125; /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */@Testpublic void test4()&#123; String sql = \"select * from emp where id = ? or id = ?\"; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125; &#125; /** * 5. 查询所有记录，将其封装为List */@Testpublic void test5()&#123; String sql = \"select * from emp\"; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) &#123; System.out.println(stringObjectMap); &#125;&#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Testpublic void test6()&#123; String sql = \"select * from emp\"; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123; @Override public Emp mapRow(ResultSet rs, int i) throws SQLException &#123; Emp emp = new Emp(); int id = rs.getInt(\"id\"); String ename = rs.getString(\"ename\"); int job_id = rs.getInt(\"job_id\"); int mgr = rs.getInt(\"mgr\"); Date joindate = rs.getDate(\"joindate\"); double salary = rs.getDouble(\"salary\"); double bonus = rs.getDouble(\"bonus\"); int dept_id = rs.getInt(\"dept_id\"); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; &#125; &#125;); ​ 123456789101112131415161718192021222324252627282930 for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2()&#123; String sql = \"select * from emp\"; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; /** * 7. 查询总记录数 */ @Test public void test7()&#123; String sql = \"select count(id) from emp\"; Long total = template.queryForObject(sql, Long.class); System.out.println(total); &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://Zhiyuancs.github.io/tags/JDBC/"}]},{"title":"JDBC基础","slug":"JDBC基础","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2019/10/10/JDBC基础/","link":"","permalink":"http://Zhiyuancs.github.io/2019/10/10/JDBC基础/","excerpt":"","text":"JDBC： 概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库 JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 快速入门： 步骤： 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 2.右键–&gt;Add As Library 注册驱动 获取数据库连接对象 Connection 定义sql 获取执行sql语句的对象 Statement 执行sql，接受返回结果 处理结果 释放资源 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140 * 代码实现： //1. 导入驱动jar包 //2.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db3\", \"root\", \"root\"); //4.定义sql语句 String sql = \"update account set balance = 500 where id = 1\"; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close();3. 详解各个对象： 1. DriverManager：驱动管理对象 * 功能： 1. 注册驱动：告诉程序该使用哪一个数据库驱动jar static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 写代码使用： Class.forName(\"com.mysql.jdbc.Driver\"); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(\"Can't register driver!\"); &#125; &#125; 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 2. 获取数据库连接： * 方法：static Connection getConnection(String url, String user, String password) * 参数： * url：指定连接的路径 * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 * 例子：jdbc:mysql://localhost:3306/db3 * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 * user：用户名 * password：密码 2. Connection：数据库连接对象 1. 功能： 1. 获取执行sql 的对象 * Statement createStatement() * PreparedStatement prepareStatement(String sql) 2. 管理事务： * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 * 提交事务：commit() * 回滚事务：rollback() 3. Statement：执行sql的对象 1. 执行sql 1. boolean execute(String sql) ：可以执行任意的sql 了解 2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 3. ResultSet executeQuery(String sql) ：执行DQL（select)语句 2. 练习： 1. account表 添加一条记录 2. account表 修改记录 3. account表 删除一条记录 代码： Statement stmt = null; Connection conn = null; try &#123; //1. 注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2. 定义sql String sql = \"insert into account values(null,'王五',3000)\"; //3.获取Connection对象 conn = DriverManager.getConnection(\"jdbc:mysql:///db3\", \"root\", \"root\"); //4.获取执行sql的对象 Statement stmt = conn.createStatement(); //5.执行sql int count = stmt.executeUpdate(sql);//影响的行数 //6.处理结果 System.out.println(count); if(count &gt; 0)&#123; System.out.println(\"添加成功！\"); &#125;else&#123; System.out.println(\"添加失败！\"); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //stmt.close(); //7. 释放资源 //避免空指针异常 if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 4. ResultSet：结果集对象,封装查询结果 * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true * getXxx(参数):获取数据 * Xxx：代表数据类型 如： int getInt() , String getString() * 参数： 1. int：代表列的编号,从1开始 如： getString(1) 2. String：代表列名称。 如： getDouble(\"balance\") * 注意： * 使用步骤： 1. 游标向下移动一行 2. 判断是否有数据 3. 获取数据 //循环判断游标是否是最后一行末尾。 while(rs.next())&#123; //获取数据 //6.2 获取数据 int id = rs.getInt(1); String name = rs.getString(\"name\"); double balance = rs.getDouble(3); System.out.println(id + \"---\" + name + \"---\" + balance); &#125; * 练习： * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。 1. 定义Emp类 2. 定义方法 public List&lt;Emp&gt; findAll()&#123;&#125; 3. 实现方法 select * from emp; PreparedStatement：执行sql SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 输入用户随便，输入密码：’a’ or ‘a’ = ‘a’ sql：select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’ 解决sql注入问题：使用PreparedStatement对象来解决 预编译的SQL：参数使用?作为占位符 步骤： 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 注册驱动 获取数据库连接对象 Connection 定义sql 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 给？赋值： 方法： setXxx(参数1,参数2) 参数1：？的位置编号 从1 开始 参数2：？的值 执行sql，接受返回结果，不需要传递sql语句 处理结果 释放资源 注意：后期都会使用PreparedStatement来完成增删改查的所有操作 可以防止SQL注入 效率更高 抽取JDBC工具类 ： JDBCUtils 目的：简化书写 分析： 注册驱动也抽取 抽取一个方法获取连接对象 需求：不想传递参数（麻烦），还得保证工具类的通用性。 解决：配置文件 jdbc.propertiesurl= user= password= 抽取一个方法释放资源 1234567891011121314151617181920212223242526272829303132333435363738* 代码实现：public class JDBCUtils &#123; private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块 */ static&#123; //读取资源文件，获取值。 try &#123; //1. 创建Properties集合类。 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(\"jdbc.properties\"); String path = res.getPath(); System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties //2. 加载文件 // pro.load(new FileReader(\"D:\\\\IdeaProjects\\\\itcast\\\\day04_jdbc\\\\src\\\\jdbc.properties\")); pro.load(new FileReader(path)); //3. 获取数据，赋值 url = pro.getProperty(\"url\"); user = pro.getProperty(\"user\"); password = pro.getProperty(\"password\"); driver = pro.getProperty(\"driver\"); //4. 注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; ​ 12345678910111213141516171819202122232425262728293031/** * 获取连接 * @return 连接对象 */public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, user, password);&#125;/** * 释放资源 * @param stmt * @param conn */public static void close(Statement stmt,Connection conn)&#123; if( stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if( conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 /** * 释放资源 * @param stmt * @param conn */ public static void close(ResultSet rs,Statement stmt, Connection conn)&#123; if( rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if( stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if( conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;* 练习： * 需求： 1. 通过键盘录入用户名和密码 2. 判断用户是否登录成功 * select * from user where username = \"\" and password = \"\"; * 如果这个sql有查询结果，则成功，反之，则失败 * 步骤： 1. 创建数据库表 user CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32), PASSWORD VARCHAR(32) ); INSERT INTO USER VALUES(NULL,'zhangsan','123'); INSERT INTO USER VALUES(NULL,'lisi','234'); 2. 代码实现： public class JDBCDemo9 &#123; public static void main(String[] args) &#123; //1.键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(\"请输入用户名：\"); String username = sc.nextLine(); System.out.println(\"请输入密码：\"); String password = sc.nextLine(); //2.调用方法 boolean flag = new JDBCDemo9().login(username, password); //3.判断结果，输出不同语句 if(flag)&#123; //登录成功 System.out.println(\"登录成功！\"); &#125;else&#123; System.out.println(\"用户名或密码错误！\"); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536 /** * 登录方法 */ public boolean login(String username ,String password)&#123; if(username == null || password == null)&#123; return false; &#125; //连接数据库判断是否登录成功 Connection conn = null; Statement stmt = null; ResultSet rs = null; //1.获取连接 try &#123; conn = JDBCUtils.getConnection(); //2.定义sql String sql = \"select * from user where username = '\"+username+\"' and password = '\"+password+\"' \"; //3.获取执行sql的对象 stmt = conn.createStatement(); //4.执行查询 rs = stmt.executeQuery(sql); //5.判断 /* if(rs.next())&#123;//如果有下一行，则返回true return true; &#125;else&#123; return false; &#125;*/ return rs.next();//如果有下一行，则返回true &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(rs,stmt,conn); &#125; return false; &#125;&#125; ​ JDBC控制事务： 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 操作： 开启事务 提交事务 回滚事务 使用Connection对象来管理事务 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 在执行sql之前开启事务 提交事务：commit() 当所有sql都执行完提交事务 回滚事务：rollback() 在catch中回滚事务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051524. 代码： public class JDBCDemo10 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement pstmt1 = null; PreparedStatement pstmt2 = null; try &#123; //1.获取连接 conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); //2.定义sql //2.1 张三 - 500 String sql1 = \"update account set balance = balance - ? where id = ?\"; //2.2 李四 + 500 String sql2 = \"update account set balance = balance + ? where id = ?\"; //3.获取执行sql对象 pstmt1 = conn.prepareStatement(sql1); pstmt2 = conn.prepareStatement(sql2); //4. 设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); //5.执行sql pstmt1.executeUpdate(); // 手动制造异常 int i = 3/0; pstmt2.executeUpdate(); //提交事务 conn.commit(); &#125; catch (Exception e) &#123; //事务回滚 try &#123; if(conn != null) &#123; conn.rollback(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); &#125; &#125; &#125; ​ ​","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://Zhiyuancs.github.io/tags/JDBC/"}]},{"title":"Go(三)","slug":"Go-三","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2019/10/03/Go-三/","link":"","permalink":"http://Zhiyuancs.github.io/2019/10/03/Go-三/","excerpt":"","text":"复合数据类型3.1 数组1234var a [3]intvar q [3]int = [3]int&#123;1, 2, 3&#125;q := [...]int&#123;1, 2, 3&#125; //长度由初始化值的个数来计算months := [...]string&#123;1: \"January\", /* ... */, 12: \"December\"&#125; //索引0自动初始化为空字符串 数组类型可以直接比较（==），只有当两个数组所有元素都是相等的时候数组才是相等的。 3.2 Slice一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。 slice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。 slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较： 1234567891011func equal(x, y []string) bool &#123; if len(x) != len(y) &#123; return false &#125; for i := range x &#123; if x[i] != y[i] &#123; return false &#125; &#125; return true&#125; slice唯一合法的比较操作是和nil比较，内置的make函数创建一个指定元素类型、长度和容量的slice。 123456var s []int // len(s) == 0, s == nils = nil // len(s) == 0, s == nils = []int(nil) // len(s) == 0, s == nils = []int&#123;&#125; // len(s) == 0, s != nilmake([]T, len) //返回整个数组make([]T, len, cap) // same as make([]T, cap)[:len] 3.3 append函数内置的append函数用于向slice追加元素 12345var runes []runefor _, r := range \"Hello, 世界\" &#123; runes = append(runes, r)&#125;fmt.Printf(\"%q\\n\", runes) // \"['H' 'e' 'l' 'l' 'o' ',' ' ' '世' '界']\" copy函数可以方便地将一个slice复制另一个相同类型的slice。copy函数的第一个参数是要复制的目标slice，第二个参数是源slice。copy(z, x) 12345var x []intx = append(x, 1)x = append(x, 2, 3)x = append(x, 4, 5, 6)x = append(x, x...) // append the slice x 一个slice可以用来模拟一个stack。最初给定的空slice对应一个空的stack，然后可以使用append函数将新的值压入stack： 123stack = append(stack, v) // push vtop := stack[len(stack)-1] // top of stackstack = stack[:len(stack)-1] // pop 要删除slice中间的某个元素并保存原有的元素顺序，可以通过内置的copy函数将后面的子slice向前依次移动一位完成： 123456789func remove(slice []int, i int) []int &#123; copy(slice[i:], slice[i+1:]) return slice[:len(slice)-1]&#125;func main() &#123; s := []int&#123;5, 6, 7, 8, 9&#125; fmt.Println(remove(s, 2)) // \"[5 6 8 9]\"&#125; 3.4 Map在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。 123456789ages := make(map[string]int) // mapping from strings to intsages := map[string]int&#123; \"alice\": 31, \"charlie\": 34,&#125;//创建空的mapmap[string]int&#123;&#125;//使用内置的delete函数可以删除元素delete(ages, \"alice\") // remove element ages[\"alice\"] map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作，原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。 1_ = &amp;ages[\"bob\"] // compile error: cannot take address of map element 遍历map 123for name, age := range ages &#123; fmt.Printf(\"%s\\t%d\\n\", name, age)&#125; Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。如果要按顺序遍历key/value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序。 12345678910import \"sort\"var names []stringfor name := range ages &#123; names = append(names, name)&#125;sort.Strings(names)for _, name := range names &#123; fmt.Printf(\"%s\\t%d\\n\", name, ages[name])&#125; 123age, ok := ages[\"bob\"]//在这种场景下，map的下标语法将产生两个值；第二个是一个布尔值，//用于报告元素是否真的存在。布尔变量一般命名为ok，特别适合马上用于if条件判断部分。 Go语言没有提供set类型，可以用map实现set类型， 12345678910111213141516func main() &#123; seen := make(map[string]bool) // a set of strings input := bufio.NewScanner(os.Stdin) for input.Scan() &#123; line := input.Text() if !seen[line] &#123; seen[line] = true fmt.Println(line) &#125; &#125; if err := input.Err(); err != nil &#123; fmt.Fprintf(os.Stderr, \"dedup: %v\\n\", err) os.Exit(1) &#125;&#125; 3.5 结构体12345678type Employee struct &#123; ID int Name string Address string DoB time.Time&#125;var dilbert Employee 结构体变量的成员可以通过点操作符访问，比如dilbert.Name和dilbert.DoB。赋值可以直接进行或者通过指针： 12name := &amp;dilbert.Name*name = \"Robin\" 点操作符也可以和指向结构体的指针一起工作： 1234var employeeOfTheMonth *Employee = &amp;dilbertemployeeOfTheMonth.Position += \" (proactive team player)\"//上面语句等价于(*employeeOfTheMonth).Position += \" (proactive team player)\" 结构体成员的输入顺序也有重要的意义。交换Name和Address出现的先后顺序，那样的话就是定义了不同的结构体类型。如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个命名为S的结构体类型将不能再包含S类型的成员，但是S类型的结构体可以包含*S指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。 3.5.1 结构体字面值1234type Point struct&#123; X, Y int &#125;p := Point&#123;1, 2&#125;q := Point&#123;X:1,Y:2&#125; 上面第一种写法，要求以结构体成员定义的顺序为每个结构体成员指定一个字面值。这个方法一般只在定义结构体的包内部使用，或者是在较小的结构体中使用。第二种方法是以成员名字和相应的值来初始化。结构体通常通过指针处理，可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址： 1234pp := &amp;Point&#123;1, 2&#125;//等价于pp := new(Point)*pp = Point&#123;1, 2&#125; 3.5.2 结构体比较如果结构体的全部成员都是可以比较的，那么这个结构体也是可以比较的，可以通过==或!=运算符进行比较。 123456type Point struct&#123; X, Y int &#125;p := Point&#123;1, 2&#125;q := Point&#123;2, 1&#125;fmt.Println(p.X == q.X &amp;&amp; p.Y == q.Y) // \"false\"fmt.Println(p == q) // \"false\" 可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型。 1234567type address struct &#123; hostname string port int&#125;hits := make(map[address]int)hits[address&#123;\"golang.org\", 443&#125;]++ 3.5.3 结构体嵌入和匿名变量123456789101112131415161718type Point struct &#123; X, Y int&#125;type Circle struct &#123; Center Point Radius int&#125;type Wheel struct &#123; Circle Circle Spokes int&#125;var w Wheelw.Circle.Center.X = 8w.Circle.Center.Y = 8w.Circle.Radius = 5w.Spokes = 20 Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。得意于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径： 123456789101112131415type Circle struct &#123; Point Radius int&#125;type Wheel struct &#123; Circle Spokes int&#125;var w Wheelw.X = 8 // equivalent to w.Circle.Point.X = 8w.Y = 8 // equivalent to w.Circle.Point.Y = 8w.Radius = 5 // equivalent to w.Circle.Radius = 5w.Spokes = 20//匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。 结构体字面值没有简短表示匿名成员的语法，所以必须遵循形状类型声明时的结构，按照以下方式赋值： 123456789w = Wheel&#123;Circle&#123;Point&#123;8, 8&#125;, 5&#125;, 20&#125;w = Wheel&#123; Circle: Circle&#123; Point: Point&#123;X: 8, Y: 8&#125;, Radius: 5, &#125;, Spokes: 20, // NOTE: trailing comma necessary here (and at Radius)&#125; 因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。同时，因为成员的名字是由其类型隐式地决定的，所有匿名成员也有可见性的规则约束。在上面的例子中，Point和Circle匿名成员都是导出的。即使它们不导出（比如改成小写字母开头的point和circle），我们依然可以用简短形式访问匿名成员嵌套的成员，但是在包外部，这是不允许的。 1w.X = 8 // equivalent to w.circle.point.X = 8 3.6 JSON(encoding/json包)12345678910111213141516type Movie struct &#123; Title string Year int `json:\"released\"` Color bool `json:\"color,omitempty\"` Actors []string&#125;var movies = []Movie&#123; &#123;Title: \"Casablanca\", Year: 1942, Color: false, Actors: []string&#123;\"Humphrey Bogart\", \"Ingrid Bergman\"&#125;&#125;, &#123;Title: \"Cool Hand Luke\", Year: 1967, Color: true, Actors: []string&#123;\"Paul Newman\"&#125;&#125;, &#123;Title: \"Bullitt\", Year: 1968, Color: true, Actors: []string&#123;\"Steve McQueen\", \"Jacqueline Bisset\"&#125;&#125;, // ...&#125; 结构体声明中，Year和Color成员后面的字符串面值是结构体成员的Tag。将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）。编组通过调用json.Marshal函数完成： 12345data, err := json.Marshal(movies)if err != nil &#123; log.Fatalf(\"JSON marshaling failed: %s\", err)&#125;fmt.Printf(\"%s\\n\", data) Marshal函数返还一个编码后的字节slice，包含很长的字符串，并且没有空白缩进。这种紧凑的表示形式虽然包含了全部的信息，但是很难阅读。为了生成便于阅读的格式，另一个json.MarshalIndent函数将产生整齐缩进的输出。该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进。 12345678910111213141516data, err := json.MarshalIndent(movies, \"\", \" \")if err != nil &#123; log.Fatalf(\"JSON marshaling failed: %s\", err)&#125;fmt.Printf(\"%s\\n\", data)//输出格式[ &#123; \"Title\": \"Casablanca\", \"released\": 1942, \"Actors\": [ \"Humphrey Bogart\", \"Ingrid Bergman\" ] &#125;, ……………… 其中Year名字的成员在编码后变成了released，还有Color成员编码后变成了小写字母开头的color。这是因为构体成员Tag所导致的。结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:”value”键值对序列；因为值中含义双引号字符，因此成员Tag一般用原生字符串面值的形式书写。json开头键名对应的值用于控制encoding/json包的编码和解码的行为，并且encoding/…下面其它的包也遵循这个约定。成员Tag中json对应值的第一部分用于指定JSON对象的名字，Color成员的Tag还带了一个额外的omitempty选项，表示当Go语言结构体成员为空或零值时不生成JSON对象，如Casablanca的color成员变量值为false（零值），所以没有输出color成员。 解码操作是将JSON数据解码成Go语言的数据结构，通过json.Unmarshal函数完成。下面的代码将JSON格式的电影数据解码为一个结构体slice，结构体中只有Title成员。通过定义合适的Go语言数据结构，我们可以选择性地解码JSON中感兴趣的成员。当Unmarshal函数调用返回，slice将被只含有Title信息值填充，其它JSON成员将被忽略。 12345var titles []struct&#123; Title string &#125;if err := json.Unmarshal(data, &amp;titles); err != nil &#123; log.Fatalf(\"JSON unmarshaling failed: %s\", err)&#125;fmt.Println(titles) // \"[&#123;Casablanca&#125; &#123;Cool Hand Luke&#125; &#123;Bullitt&#125;]\" 3.7 文本和HTML模板text\\template和html\\template提供了一个将变量值填充到文本或HTML格式的模板的机制。 一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的对象。大部分的字符串只是按字面值打印，但是对于actions部分将触发其它的行为。下面是一个简短的模板字符串。 1234567const templ = `&#123;&#123;.TotalCount&#125;&#125; issues:&#123;&#123;range .Items&#125;&#125;----------------------------------------Number: &#123;&#123;.Number&#125;&#125;User: &#123;&#123;.User.Login&#125;&#125;Title: &#123;&#123;.Title | printf \"%.64s\"&#125;&#125;Age: &#123;&#123;.CreatedAt | daysAgo&#125;&#125; days&#123;&#123;end&#125;&#125;` 1对于每一个action，都有一个当前值的概念，对应点操作符，写作“.”。模板中&#123;&#123;.TotalCount&#125;&#125;对应action将展开为结构体中TotalCount成员以默认的方式打印的值。模板中&#123;&#123;range .Items&#125;&#125;和&#123;&#123;end&#125;&#125;对应一个循环action，因此它们直接的内容可能会被展开多次，循环每次迭代的当前值对应当前的Items元素的值。 在一个action中，|操作符表示将前一个表达式的结果作为后一个函数的输入，在Title这一行的action中，第二个操作是一个printf函数，是一个基于fmt.Sprintf实现的内置函数，所有模板都可以直接使用。 生成模板：template.New先创建并返回一个模板；Funcs方法将daysAgo等自定义函数注册到模板中，并返回模板；最后调用Parse函数分析模板。 123456report, err := template.New(\"report\"). Funcs(template.FuncMap&#123;\"daysAgo\": daysAgo&#125;). Parse(templ)if err != nil &#123; log.Fatal(err)&#125; https://books.studygolang.com/gopl-zh/ch4/ch4-06.html","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://Zhiyuancs.github.io/tags/Go/"}]},{"title":"Go(四)","slug":"Go-四","date":"un22fin22","updated":"un44fin44","comments":true,"path":"2019/10/01/Go-四/","link":"","permalink":"http://Zhiyuancs.github.io/2019/10/01/Go-四/","excerpt":"","text":"函数4.1 函数声明函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。 123func name(parameter-list) (result-list) &#123; body&#125; 如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。 12func f(i, j, k int, s, t string) &#123; /* ... */ &#125;func f(i int, j int, k int, s string, t string) &#123; /* ... */ &#125; 123456789func add(x int, y int) int &#123;return x + y&#125;func sub(x, y int) (z int) &#123; z = x - y; return&#125;func first(x int, _ int) int &#123; return x &#125;func zero(int, int) int &#123; return 0 &#125;fmt.Printf(\"%T\\n\", add) // \"func(int, int) int\"fmt.Printf(\"%T\\n\", sub) // \"func(int, int) int\"fmt.Printf(\"%T\\n\", first) // \"func(int, int) int\"fmt.Printf(\"%T\\n\", zero) // \"func(int, int) int\" 在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。 遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符。 1func Sin(x float64) float //implemented in assembly language 4.2 递归Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题。 4.3 多返回值在Go中，一个函数可以返回多个值。我们已经在之前例子中看到，许多标准库中的函数返回2个值，一个是期望得到的返回值，另一个是函数出错时的错误信息。 调用多返回值函数时，返回给调用者的是一组值，调用者必须显式的将这些值分配给变量: 12links, err := findLinks(url)links, _ := findLinks(url) // errors ignored 当你调用接受多参数的函数时，可以将一个返回多参数的函数作为该函数的参数。虽然这很少出现在实际生产代码中，但这个特性在debug时很方便，我们只需要一条语句就可以输出所有的返回值。下面的代码是等价的。 123log.Println(findLinks(url))links, err := findLinks(url)log.Println(links, err) 如果一个函数所有的返回值都显示变量名，那么该函数的return语句可以省略操作数，称之为base return。 12345func Count(num1,num2 int) (count1,count2 int,err error)&#123; count1,count2:=num1,num2 err:=nil return &#125; 4.4 文件结尾错误EOFio包保证任何由文件结束引起的读取失败都返回同一个错误io.EOF，该错误在io包中定义： 123456package ioimport \"errors\"// EOF is the error returned by Read when no more input is available.var EOF = errors.New(\"EOF\") 调用者只需通过简单的比较，就可以检测出这个错误。 12345678910in := bufio.NewReader(os.Stdin)for &#123; r, _, err := in.ReadRune() if err == io.EOF &#123; break // finished reading &#125; if err != nil &#123; return fmt.Errorf(\"read failed:%v\", err) &#125;&#125; 4.5 函数值在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。 123func square(n int) int &#123; return n * n &#125;f := squarefmt.Println(f(3)) // \"9\" 函数类型的零值是nil。调用值为nil的函数值会引起panic错误。函数可以和nil比较，但是函数之间是不可以比较的，不可以作为map的key。 函数值作为函数的参数，下面strings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者。 1234func add1(r rune) rune &#123; return r + 1 &#125;//String.Map函数定义//func Map(mapping func(rune) rune, s string) stringfmt.Println(strings.Map(add1, \"HAL-9000\")) // \"IBM.:111\" 4.6 匿名函数函数值字面量是一种表达式，它的值被成为匿名函数（anonymous function）。函数字面量允许我们在使用函数时，再定义它。 1strings.Map(func(r rune) rune &#123; return r + 1 &#125;, \"HAL-9000\") 更为重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量： 1234567891011121314func squares() func() int &#123; var x int return func() int &#123; x++ return x * x &#125;&#125;func main() &#123; f := squares() fmt.Println(f()) // \"1\" fmt.Println(f()) // \"4\" fmt.Println(f()) // \"9\" fmt.Println(f()) // \"16\"&#125; squares的例子证明，函数值不仅仅是一串代码，还记录了状态，其中的变量生命周期不由它的作用域决定。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。 当匿名函数需要被递归调用时，我们必须首先声明一个变量，再将匿名函数赋值给这个变量。 12345visitAll := func(items []string) &#123; // ... visitAll(m[item]) // compile error: undefined: visitAll // ...&#125; 4.7 捕获迭代变量12345678910var rmdirs []func()for _, dir := range tempDirs() &#123; os.MkdirAll(dir, 0755) rmdirs = append(rmdirs, func() &#123; os.RemoveAll(dir) // NOTE: incorrect! &#125;)&#125;for _, rmdir := range rmdirs &#123; rmdir() // clean up&#125; 上面代码是错误的，在该循环中生成的所有函数值都共享相同的循环变量，需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。所以后续的迭代会不断更新dir的值，当删除操作执行时，for循环已完成，dir中存储的值等于最后一次迭代的值。 通常，为了解决这个问题，我们会引入一个与循环变量同名的局部变量，作为循环变量的副本。 1234for _, dir := range tempDirs() &#123; dir := dir // declares inner dir, initialized to outer dir // ...&#125; 4.8 可变参数参数数量可变的函数称为为可变参数函数。在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“…”，这表示该函数会接收任意数量的该类型参数。 12345678910func sum(vals...int) int &#123; total := 0 for _, val := range vals &#123; total += val &#125; return total&#125;fmt.Println(sum()) // \"0\"fmt.Println(sum(3)) // \"3\"fmt.Println(sum(1, 2, 3, 4)) // \"10\" 在上面的代码中，调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调函数。如果原始参数已经是切片类型，只需在最后一个参数后加上省略符。 12values := []int&#123;1, 2, 3, 4&#125;fmt.Println(sum(values...)) // \"10\" 4.9 Deferred函数在普通函数或方法前加上关键字defer，这时当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行。可以在一个函数中执行多条defer语句，他们执行顺序与声明顺序相反，类似于栈。 defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。 defer后的函数会在return或者异常后执行，可以用来记录函数返回值。同样可以避免函数出现异常返回，导致文件没有关闭，或者简化代码。 123456789101112131415func CopyFile(dstName, srcName string) (written int64, err error) &#123;src, err := os.Open(srcName)if err != nil &#123;return&#125;defer src.Close()dst, err := os.Create(dstName)if err != nil &#123;return&#125;defer dst.Close()return io.Copy(dst, src)&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://Zhiyuancs.github.io/tags/Go/"}]},{"title":"Go(二)","slug":"Go-二","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2019/09/26/Go-二/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/26/Go-二/","excerpt":"","text":"基础数据类型2.1 整形12345* / % &lt;&lt; &gt;&gt; &amp; &amp;^+ - | ^== != &lt; &lt;= &gt; &gt;=&amp;&amp;|| 二元运算符有五种优先级。在同一个优先级，使用左优先结合规则，但是使用括号可以明确优先顺序，使用括号也可以用于提升优先级。在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此-5%3和-5%-3结果都是-2。除法运算符/的行为则依赖于操作数是否为全为整数，比如5.0/4.0的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。 123456&amp; 位运算 AND| 位运算 OR^ 位运算 XOR&amp;^ 位清空 (AND NOT)&lt;&lt; 左移&gt;&gt; 右移 位操作运算符^作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反；位操作运算符&amp;^用于按位置零（AND NOT）：如果对应y中bit位为1的话, 表达式z = x &amp;^ y结果z的对应的bit位为0，否则z对应的bit位等于x相应的bit位的值。 任何大小的整数字面值都可以用以0开始的八进制格式书写，例如0666；或用以0x或0X开头的十六进制格式书写，例如0xdeadbeef。十六进制数字可以用大写或小写字母。 123456o := 0666fmt.Printf(\"%d %[1]o %#[1]o\\n\", o) // \"438 666 0666\"x := int64(0xdeadbeef)fmt.Printf(\"%d %[1]x %#[1]x %#[1]X\\n\", x)// Output:// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF 通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的[1]副词告诉Printf函数再次使用第一个操作数。第二，%后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。字符使用%c参数打印，或者是用%q参数打印带单引号的字符。 2.2 浮点数float32、float64 很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分。 1const Avogadro = 6.02214129e23 // 阿伏伽德罗常数 用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。所有的这三个打印形式都可以指定打印的宽度和控制打印精度。 1234567for x := 0; x &lt; 8; x++ &#123; fmt.Printf(\"x = %d e^x = %8.3f\\n\", x, math.Exp(float64(x)))&#125;x = 5 e^x = 148.413x = 6 e^x = 403.429x = 7 e^x = 1096.633 math包中有定义的特殊值：+Inf、-Inf、NAN（正负无穷，非数）。函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。 12nan := math.NaN()fmt.Println(nan == nan, nan &lt; nan, nan &gt; nan) // \"false false false\" 2.3 复数Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部： 12345var x complex128 = complex(1, 2) // 1+2ivar y complex128 = complex(3, 4) // 3+4ifmt.Println(x*y) // \"(-5+10i)\"fmt.Println(real(x*y)) // \"-5\"fmt.Println(imag(x*y)) // \"10\" math/cmplx包提供了复数处理的许多函数，例如求复数的平方根函数和求幂函数。 2.4 布尔值布尔值可以和&amp;&amp;（AND）和||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值。 &amp;&amp;的优先级比||高 布尔值并不会隐式转换为数字值0或1，反之亦然。 2.5 字符串支持切片，‘+’链接字符串，字符串是不可修改的，尝试修改字符串内部的字符是禁止的。 原生字符串使用反引号代替双引号，原生的字符串字面量多用于书写多行消息、HTML以及正则表达式。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行。 12345const GoUsage = `Go is a tool for managing Go source code.Usage: go command [arguments]...` strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。 1234567891011121314//strings包func Contains(s, substr string) boolfunc Count(s, sep string) intfunc Fields(s string) []stringfunc HasPrefix(s, prefix string) boolfunc Index(s, sep string) intfunc Join(a []string, sep string) string//bytes包func Contains(b, subslice []byte) boolfunc Count(s, sep []byte) intfunc Fields(s []byte) [][]bytefunc HasPrefix(s, prefix []byte) boolfunc Index(s, sep []byte) intfunc Join(s [][]byte, sep []byte) []byte bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效的： 1234var buf bytes.Bufferbuf.WriteByte('[')buf.WriteRune('中')buf.WriteString(\", d \") strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。 2.6 UTF-8UTF8编码使用1到4个字节来表示每个Unicode码点，ASCII部分字符只使用1个字节，常用字符部分使用2或3个字节表示。如果第一个字节的高端bit为0，则表示对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统的ASCII编码兼容。如果第一个字节的高端bit是110，则说明需要2个字节；后续的每个高端bit都以10开头。 12340xxxxxxx runes 0-127 (ASCII)110xxxxx 10xxxxxx 128-2047 (values &lt;128 unused)1110xxxx 10xxxxxx 10xxxxxx 2048-65535 (values &lt;2048 unused)11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 65536-0x10ffff (other values unused) 12345//Unicode转义字符让我们可以通过Unicode码点输入特殊的字符。下面是相同的字符串\"世界\"\"\\xe4\\xb8\\x96\\xe7\\x95\\x8c\"\"\\u4e16\\u754c\"\"\\U00004e16\\U0000754c\" 12345import \"unicode/utf8\"s := \"Hello, 世界\"fmt.Println(len(s)) // \"13\"fmt.Println(utf8.RuneCountInString(s)) // \"9\" Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串。 如果是将一个[]rune类型的Unicode字符slice或数组转为string，则对它们进行UTF8编码： 123456789s := \"プログラム\"fmt.Printf(\"% x\\n\", s) // \"e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0\"r := []rune(s)fmt.Printf(\"%x\\n\", r) // \"[30d7 30ed 30b0 30e9 30e0]\"fmt.Println(string(r)) // \"プログラム\"fmt.Println(string(65)) // \"A\", not \"65\"fmt.Println(string(0x4eac)) // \"京\"fmt.Println(string(1234567)) // \"�\"（无效字符）fmt.Println(rune('你'))//输出20320 rune在golang中是int32的别名，在各个方面都与int32相同。可以将rune理解为一个可以表示Unicode编码的int值，称为码点。参考java中的char类型（可以和int运算）。 在Go中，双引号是用来表示字符串string，本质是[]byte类型，单引号表示rune类型。 2.7 字符串和数字的转换将一个整数转为字符串，一种方法是用fmt.Sprintf返回一个格式化的字符串；另一个方法是用strconv.Itoa(“整数到ASCII”)： 123x := 123y := fmt.Sprintf(\"%d\", x)fmt.Println(y, strconv.Itoa(x)) // \"123 123\" FormatInt和FormatUint函数可以用不同的进制来格式化数字： 1fmt.Println(strconv.FormatInt(int64(x), 2)) // \"1111011\" fmt.Sprintf函数的%b、%d、%o和%x等参数提供功能往往比strconv包的Format函数方便很多，特别是在需要包含附加额外信息的时候： 1s := fmt.Sprintf(\"x=%b\", x) // \"x=1111011\" 如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数： 123x, err := strconv.Atoi(\"123\") // x is an inty, err := strconv.ParseInt(\"123\", 10, 64) // base 10, up to 64 bitsfunc ParseInt(s string, base int, bitSize int) (i int64, err error) ParseInt函数的第三个参数是用于指定返回整型数的大小；例如16表示int16，0则表示int。第二个参数为数字字符串的进制。 int随系统而定，32位系统为int32 2.8 常量批量声明 1234567const ( e = 2.7182818284590452 e1 pi = 3.1415926535897932 p3)//p3=pi,e1=e iota 常量生成器:在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。 123456789101112131415161718192021222324type Weekday intconst ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday)//周日将对应0，周一为1，如此等等const ( _ = 1 &lt;&lt; (10 * iota) KiB // 1024 MiB // 1048576 GiB // 1073741824 TiB // 1099511627776 (exceeds 1 &lt;&lt; 32) PiB // 1125899906842624 EiB // 1152921504606846976 ZiB // 1180591620717411303424 (exceeds 1 &lt;&lt; 64) YiB // 1208925819614629174706176) 2.9 无类型常量有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。 math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方： 123var x float32 = math.Pivar y float64 = math.Pivar z complex128 = math.Pi","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://Zhiyuancs.github.io/tags/Go/"}]},{"title":"Go(一)","slug":"Go-一","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2019/09/26/Go-一/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/26/Go-一/","excerpt":"","text":"1.1命名Go中函数名字的开头字母大小决定了该函数在包外的可见性：大写字母开头，这个函数在包外可以使用；小写字母开头不可以在包外部访问。Go语言程序员推荐使用 驼峰式 命名。 1.2声明var、const、type、func：变量、常量、类型、函数实体对象声明 包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句。在包一级声明的名字可以在整个包和引用了该包的源文件中访问。 1.3变量1var 变量名字 类型 = 表达式 go语言中所有变量定义时如果未赋值，都会初始化为一个默认值。 在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。 1234freq := rand.Float64() * 3.0t := 0.0i, j := 0, 1 //变量声明语句i, j = j, i // 交换 i 和 j 的值，赋值语句（元组赋值） 简短变量声明语句中必须至少要声明一个新的变量，否则不能编译通过。 1.4指针如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时*p表达式对应p指针指向的变量的值。一般*p表达式读取指针指向的变量的值，这里为int类型的值，同时因为*p对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。 123456x := 1p := &amp;x // p, of type *int, points to xfmt.Println(*p) // \"1\"*p = 2 // equivalent to x = 2fmt.Println(x) // \"2\"*p++ // x=3,p仍然指向x 指针的零值为nil，在Go语言中，返回函数中局部变量的地址也是安全的。 123456var p = f()func f() *int &#123; v := 1 return &amp;v&#125; 1.5 new 函数表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。 1234567891011p := new(int) // p, *int 类型, 指向匿名的 int 变量fmt.Println(*p) // \"0\"//下面两个函数功能相同func newInt() *int &#123; return new(int)&#125;func newInt() *int &#123; var dummy int return &amp;dummy&#125; 由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。下面由于new被定义为int类型的变量名，因此在delta函数内部是无法使用内置的new函数的。 1func delta(old, new int) int &#123; return new - old &#125; 了解go语言自动垃圾回收器。 1.6 类型123type 类型名字 底层类型type Celsius float64 // 摄氏温度 1.7下划线 ‘_’ 12345678910111213141516171819202122//用在import//引入包，会先调用包中的初始化函数，这种使用方式仅让导入的包做初始化，而不使用包中其他功能import _ \"net/http/pprof\"//用在返回值//表示忽略某个值。单函数有多个返回值，用来获取某个特定的值for _,v := range Slice&#123;&#125;_,err := func()//用在变量//上面用来判断 type T是否实现了I,用作类型断言，如果T没有实现借口I，则编译错误.type T struct&#123;&#125;var _ I = T&#123;&#125;其中 I为interface//用在函数定义中省略带名的参数func demo() ( int, int, string, int ,error)//返回多个参数时,尤其是类型相同的，不利于阅读，func demo() ( sumA int, sumB int, _ string, total int ,_ error)//返回参数 int 加了名字，对比上面,便于理解,但是 \"string\" 和 \"error\"没有名字，编译会报错，用下划线可以忽略命名 1.8 os.Args由os包实现，用于给出程序运行时的参数。os.Args的类型是 []string ，也就是字符串切片。所以可以在for循环的range中遍历，还可以用 len(os.Args) 来获取其数量。 123456789101112131415161718192021package mainimport ( \"fmt\" \"os\" \"strconv\")func main () &#123; for idx, args := range os.Args &#123; fmt.Println(\"参数\" + strconv.Itoa(idx) + \":\", args) &#125;&#125;//运行结果$go run main.go 1 3 -X ?参数0: /tmp/go-build116558042/command-line-arguments/_obj/exe/main参数1: 1参数2: 3参数3: -X参数4: ?//参数0为程序路径本身 1.9 flag包使用flag包，首先定义待解析命令行参数，也就是以”-“开头的参数，比如这里的 -b -s -help等。-help不需要特别指定，可以自动处理。 flag使用前，必须首先解析：flag.Parse() 。 参数中没有能够按照预定义的参数解析的部分，通过flag.Args()即可获取，是一个字符串切片。 通过flag.Bool和flag.String，建立了2个指针b和s，分别指向bool类型和string类型的变量。所以后续要通过 *b 和 *s 使用变量值。 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"flag\")//参数：命令行参数名称，默认值，提示字符串var b = flag.Bool(\"b\", false, \"bool类型参数\")var s = flag.String(\"s\", \"\", \"string类型参数\")func main() &#123; flag.Parse() fmt.Println(\"-b:\", *b) fmt.Println(\"-s:\", *s) fmt.Println(\"其他参数：\", flag.Args())&#125;------------------------------------$ go run main.go-b: false-s: 其他参数： []------------------------------------$ go run main.go -b-b: true-s: 其他参数： []------------------------------------$ go run main.go -b -s test others-b: true-s: test其他参数： [others]------------------------------------$ go run main.go -helpUsage of /tmp/go-build080353851/command-line-arguments/_obj/exe/main: -b bool类型参数 -s string string类型参数exit status 2 1.10 errerror类型是一个接口类型，定义如下： 123type error interface &#123; Error() string&#125; 可以通过实现error接口来生成错误信息，如果产生错误，就会生成一个non-nil的error对象，将此对象与nil比较，结果为true。 123456789101112func Sqrt(f float64) (float64, error) &#123; if f &lt; 0 &#123; return 0, errors.New(\"math: square root of negative number\") &#125; // 实现&#125;result, err:= Sqrt(-1)if err != nil &#123; fmt.Println(err)&#125; 1.11 包的初始化和标准输入输出func init() { /* ... */ } 初始化函数在包调用时自动执行。 1234567func main() &#123; input := bufio.NewScanner(os.Stdin)//初始化一个扫表对象 for input.Scan() &#123;//扫描输入内容 line := input.Text()//把输入内容转换为字符串 fmt.Println(line)//输出到标准输出 &#125;&#125; 1.12 作用域if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域。 12345678if x := f(); x == 0 &#123; fmt.Println(x)&#125; else if y := g(x); x == y &#123; fmt.Println(x, y)&#125; else &#123; fmt.Println(x, y)&#125;fmt.Println(x, y) // compile error: x and y are not visible here 在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归引用了自身，则会产生编译错误。 123456789var cwd string//使用声明语句，初始化的cwd为局部变量，导致全局变量cwd并未被初始化func init() &#123; cwd, err := os.Getwd() // NOTE: wrong! if err != nil &#123; log.Fatalf(\"os.Getwd failed: %v\", err) &#125; log.Printf(\"Working directory = %s\", cwd)&#125; 123456789var cwd string//将err先定义，再使用赋值方法func init() &#123; var err error cwd, err = os.Getwd() if err != nil &#123; log.Fatalf(\"os.Getwd failed: %v\", err) &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://Zhiyuancs.github.io/tags/Go/"}]},{"title":"java 正则表达式","slug":"java-正则表达式","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2019/09/22/java-正则表达式/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/22/java-正则表达式/","excerpt":"","text":"题目地址：https://leetcode-cn.com/problems/string-to-integer-atoi/ 1234567891011121314151617181920212223242526272829import java.util.regex.*;class Solution &#123; public static int myAtoi(String str) &#123; str=str.trim(); String pattern=\"^[\\\\+\\\\-\\\\d]\\\\d*\";//正则表达式，表示以正号或负号或数字开头，且后面是0个或多个数字 Pattern p=Pattern.compile(pattern); Matcher m=p.matcher(str); String res=\"\"; if(m.find())&#123;//能匹配到 res=str.substring(m.start(),m.end()); &#125;else&#123;//不能匹配到 return 0; &#125; //能匹配到但只有一个+-号，也返回0 if(res.length()==1&amp;&amp;(res.charAt(0)=='+'||res.charAt(0)=='-'))&#123; return 0; &#125; try&#123; int r=Integer.parseInt(res); return r; &#125;catch(Exception e)&#123; return res.charAt(0)=='-'?Integer.MIN_VALUE:Integer.MAX_VALUE; &#125; &#125;&#125; 在使用java正则表达式时要注意：java中”\\\\“表示”\\“,”\\\\+”表示”+”,因为”+”需要转义， lookingAt()lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返回true 12345Pattern p=Pattern.compile(\"\\\\d+\"); Matcher m=p.matcher(\"22bb23\"); m.lookingAt();//返回true,因为\\d+匹配到了前面的22 Matcher m2=p.matcher(\"aa2223\"); m2.lookingAt();//返回false,因为\\d+不能匹配前面的aa Mathcer.start()/ Matcher.end()/ Matcher.group()start()返回匹配到的子字符串在字符串中的索引位置.end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置.group()返回匹配到的子字符串 start(),end(),group()均有一个重载方法它们是start(int i),end(int i),group(int i)专用于分组操作,Mathcer类还有一个groupCount()用于返回有多少组. 12345678910111213141516171819202122Pattern p=Pattern.compile(\"\\\\d+\"); Matcher m=p.matcher(\"我的QQ是:456456 我的电话是:0532214 我的邮箱是:aaa123@aaa.com\"); while(m.find()) &#123; System.out.println(m.group()); &#125; 输出：456456 0532214 123 //或者 while(m.find()) &#123; System.out.println(m.group()); System.out.print(\"start:\"+m.start()); System.out.println(\" end:\"+m.end()); &#125; 输出：456456 start:6 end:12 0532214 start:19 end:26 123 start:36 end:39 可以看出，每执行一次find()，matcher对应的分组都会自动加一。start(),end(),group()三个方法的值都会改变,匹配到的子字符串的信息,以及它们的重载方法,也会改变成相应的信息. 后面遇到有关正则表达式问题再进行补充。","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"http://Zhiyuancs.github.io/tags/java/"}]},{"title":"Mysql学习笔记（三）","slug":"Mysql学习笔记（三）","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2019/09/21/Mysql学习笔记（三）/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/21/Mysql学习笔记（三）/","excerpt":"","text":"select 字段列表form 表名where 查询筛选条件group by 指定分组的列列表having 指定分组后的筛选条件order by 排序列的列表limit 起始索引值，要查询的记录条数 1、分组查询：group by分组函数（聚合函数）：将多行的值进行统计返回一行结果sum() ; avg(); min(); max(); count().注：分组函数不能和与分组无关的列一起使用；分组查询时，查询的列可以是分组的条件 123456789SELECT SUM(salary)，COUNT(eid)，did FROM t_employGROUP BY did;SELECT did,COUNT(eid)FROM t_employWHERE salary&gt;10000AND did IS NOT NULLGROUP BY did; 2、条件中需要使用分组后的结果:having作用和where一样，但是执行顺序在分组之后 1234SELECT AVG(salary)FROM t_employGROUP BY didHAVING AVG(salary)&gt;9000; 3、order by：降序排列desc，升序排列ascSELECT * FROM t_employ ORDER BY salary DESC, eid ASC; 4、分页查询：limit index，size 5、子查询：当前查询依赖另一个查询的结果 123SELECT * FROM t_employ WHERE did=( SELECT did FROM t_employ WHERE ename='罗宾')； 三种类型：1、将子查询结果当做where查询的条件；2、当做临时表再次查询；3、作为主查询的判断条件，决定数据是否查询。exists型子查询 6、复制表 复制表结构：CREATE TABLE t_emp AS(SELECT * FROM t_employ WHERE 1=2);复制表结构+指定数据：where 条件 7、单行函数：处理一行返回一行结果SELECT UPPER(email) FROM t_employ;password():mysql数据库在将数据库管理员的信息进行保存时，会将密码加密保存。SELECT PASSWORD(&#39;123456&#39;) FROM DUAL; (dual练习表)","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://Zhiyuancs.github.io/tags/Mysql/"}]},{"title":"Mysql学习笔记（二）","slug":"Mysql学习笔记（二）","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2019/09/21/Mysql学习笔记（二）/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/21/Mysql学习笔记（二）/","excerpt":"","text":"1、自增长：如果一列是主键，并且数据类型是int，则支持自动增长，每次插入数据时，会自动加一表定义时加上 id INT(11) PRIMARY KEY AUTO_INCREMENT； 2、给查询到的列取别名，表也可以取别名SELECT 列名 AS ‘别 名’，列名 别名，…… FROM 表名3、去重复：将查询到的所有列的重复筛选掉SELECT DISTINCT 列名 FROM 表名 4、查询时 进行计算支持数学运算符，逻辑运算符：xor异或比较运算符：=，&gt;,&lt;,&gt;=,&lt;=集合：in(值列表)范围：between min and max 5、模糊查询:like ‘模糊字符串’%:代表0~n个任意字符_：代表一个任意字符 6、使用 ifnull(字段，默认值) 方法解决null值计算问题 7、字符串拼接时的null值（sql中的+不能拼接字符串）concat（字段和字符串列表）：自动将方法内的所有字符串进行拼接处理 8、联合查询多表查询时，需要指定连接条件才能避免笛卡尔积：表名.列名（指定是哪个表的列）多表查询时，最少指定n-1个连接条件才能避免笛卡尔积 9、内连接（INNER JOIN）sql99推荐多表连接使用：表1 join 表2 on 连接条件 join 表3 on 连接条件INNER JOIN（只有满足条件的数据才能被查询） 10、外连接(左外连接：左表不满足条件的数据也查询出来，右外连接）LEFT OUTER JOIN全连接 11、自连接：当前表连接当前表，使用别名区分","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://Zhiyuancs.github.io/tags/Mysql/"}]},{"title":"Mysql学习笔记（一）","slug":"Mysql学习笔记（一）","date":"un66fin66","updated":"un33fin33","comments":true,"path":"2019/09/21/Mysql学习笔记（一）/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/21/Mysql学习笔记（一）/","excerpt":"","text":"DDL语句1、建库 1CREAT DATABASE 名字 不区分大小写，推荐关键字大写；单词间加‘_’mysql数据结构：char，varchar 12345CREATE TABLE tm_teammanager( id INT(11), 'name' VARCHAR(30),#通过飘号选中的字符会保留字符串本意，不会当成关键字，~ gender CHAR(2)) 2、查表结构 1DESC tm_teammanager 3、从删库到跑路备份为.sql文件 12DROP TABLE 表名 DROP DATABASE 4、修改表名 1ALTER TABLE oldname RENAME newname; 5、给表添加一列 1ALTER TABLE 表名 ADD COLUMN 名字 INT(3) (加上类型) 6、删除表一列 1ALTER TABLE 表名 DROP COLUMN 列名 7、给一列重命名change 1ALTER TABLE 表名 CHANGE 列名 新列名 数据类型 8、修改表列的数据类型modify 1ALTER TABLE 表名 MODIFY 列名 新数据类型 DML语句1、插入数据 12INSERT INTO 表名 VALUES(); #必须给所有列指定值 INSERT INTO 表名(id,列名……) VALUES(对应值); 2、查询 select 3、修改数据 update 1UPDATE 表名 SET 列名=值 WHERE id=2； 4、删除 delete 12DELETE FROM 表名 delete、drop、truncate区别 约束 constrains1、主键约束 primary key（字段值唯一非空）主键只能有一个1.1添加主键：创建表时添加约束CONSTRAINT PRIMARY KEY(列名)1.2 通过alter语句给表添加主键约束（表创建后添加） 123ALTER TABLE 表名 DROP PRIMARY KEY; #先删除原有主键约束 ALTER TABLE 表名 ADD PRIMARY KEY(列名) 或 ALTER TABLE 表名 MODIFY …… PRIMARY KEY 2、唯一键约束2.1 创建时添加2.2 修改表的指定列添加唯一键约束 1ALTER TABLE ^ MODIFY ^ ^ UNIQUE; 删除唯一键约束 1ALTER TABLE 表名 DROP INDEX 列名； 查看索引 SHOW INDEX FROM 表名 3、非空约束 not null3.1创建表时添加 123CREATE TABLE t_stu( &amp;emsp;&amp;emsp;id INT(11) NOT NULL; ); 删除非空约束 1alter table 表名 modify 列名 类型； 3.2修改列添加非空约束 1alter table 表名 modify 列名 类型 not null default “etc”； 4、默认值约束 default5、外键约束外键关联时，两张表建立外键的列数据类型必须相同，长度尽量一致 5.1修改表的指定列，添加外键约束 123ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY （当前表的指定列） references 关联的表名（指定要关联的列名）;ALTER TABLE t_stu ADD CONSTRAINT fk_cid FOREIGN KEY(cid) REFERENCES t_course(id); 删除外键约束：删除外键，然后才能删除外键对应的索引 12ALTER TEBLE 表名 DROP FOREIGN KEY(外键名) ALTER TABLE 表名 DROP INDEX 外键名； 索引需要删除，否则影响效率 5.2创建表时添加 1CONSTRAINT 外键名 FOREIGN KEY(列名) REFERENCES关联的表名（列名） 5.3删除被其他表关联的数据：当没有其他表引用该行数据可以删除5.4添加外键时指定级联删除或者级联置空","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://Zhiyuancs.github.io/tags/Mysql/"}]},{"title":"Unsupervised Video Summarization with Adversarial LSTM","slug":"3","date":"un66fin66","updated":"un66fin66","comments":true,"path":"2019/09/21/3/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/21/3/","excerpt":"","text":"&emsp;&emsp;本文提出一个由summarizer和discriminator组成的生成对抗框架。目的是选择视频的稀疏子集，使得视频和摘要的表示误差最小。 &emsp;&emsp;原始视频的特征是通过GAN和LSTM提取的，GAN以像素为基础提取特征，LSTM捕捉帧之间的长期依赖关系，得到深度特征向量。由于明确深度特征间的合适距离困难，所以由左边结构转换为右边的结构。 论文理论基础：Variational Autoencoder(VAE)，GAN Model Overview&emsp;&emsp;CNN输出的是视频帧的深度特征（deep features x），sLSTM（selector LSTM）在这些帧中选择一个子集，eLSTM(encoder LSTM)将选择的帧序列编码成向量 e 。sLSTM生成每一个帧的标准化重要性得分s，结合x，输入到eLSTM中。dLSTM(decoder LSTM)以e为输入，重构了输入视频的特征序列。鉴别器（discriminator）用来区分原始和摘要视频帧间的特征，用于估计两者之间的representation error。 &emsp;&emsp;本实验中使用二元序列分类器（a binary sequence classifier），所以鉴别器为cLSTM(classifier LSTM)，输出是二分类。 &emsp;&emsp;生成对抗训练的关键是引入一个额外的帧选择器Sp（基于先验分布的，例如均匀分布）。利用概率Sp选择一个子集作为eLSTM的输入，以相同的pipeline生成一系列值，用于计算误差。 Reconstruction loss Lreconst&emsp;&emsp;没有采用传统的欧式距离，而是基于cLSTM的隐藏层表示。cLSTM最后一个隐藏层的输出**表示一个紧凑的特征向量，它捕捉了x（特征序列）的长距离依赖关系。Lre是对数似然的期望。 Loss of GAN这里的先验分布使用均匀分布。 &emsp;&emsp;cLSTM(·)是一个二元的softmax输出。更新参数使用随机梯度变分bayes估计（Stochastic Gradient Variational Bayes estimation） 正则化训练Summary-Length Regularization M帧数量，*希望选择帧数量的百分比 Diversity Regularization 基于DPP 排斥正则化器（Repelling regularizer） Keyframe Regularization","author":"Zhiyuan","categories":[{"name":"AI","slug":"AI","permalink":"http://Zhiyuancs.github.io/categories/AI/"}],"tags":[{"name":"视频摘要","slug":"视频摘要","permalink":"http://Zhiyuancs.github.io/tags/视频摘要/"}]},{"title":"Deep Reinforcement Learning for Unsupervised V-S ","slug":"Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2019/09/15/Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/15/Deep-Reinforcement-Learning-for-Unsupervised-Video-Summarization/","excerpt":"","text":"Abstract&emsp;&emsp;本文创新点：1、构建DSN网络；2、设计一个新的奖励函数（基于帧的多样性和代表性）；3、设计一个端到端的、基于强化学习的框架来训练网络。 Introduction&emsp;&emsp;DPP-LSTM效果较好，但是视频摘要的评价时，人类具有更多的主观性，所以非监督方法很有必要。&emsp;&emsp;本文的DSN网络：encoder：CNN（在视频帧上进行特征提取）；decoder：BiLSTM（产生概率分布来选择帧）。RL（增强学习）：通过迭代方式训练agent。&emsp;&emsp;主要贡献：将无监督方法扩展到监督版本，以利用标签；首次将RL应用到无监督视频摘要上。 Model OverviewDeep Summarization Network&emsp;&emsp;采用encoder-decoder结构，CNN选用在ImageNet上预训练好的GoogLeNet，从它倒数第二层提取出视觉特征向量x_{t}。LSTM用来捕获视频帧之间的长时间依赖性。训练中只更新decoder。 &emsp;&emsp;将BiLSTM网络的正向和反向的隐藏层输出拼接作为相应的隐状态，网络输入为视觉特征向量。全连接层结束于sigmoid函数，得出每个帧选择的概率分布，帧是否选择服从二项分布。视频摘要由这些选择的帧组成。 Diversity-Representativeness Reward Function&emsp;&emsp;训练时DSN的目的是最大化奖励函数。&emsp;&emsp;Diversity reward:通过计算选择帧之间的差异性（取平均值）来度量多样性， &emsp;&emsp;公式3忽视了序列数据时间上的关联性，事实上，时间相距较大的两个相似帧对故事线的构筑都很重要。所以设置如下， 入控制时间距离。 &emsp;&emsp;Representativeness reward:视频摘要代表性的度量是一个k-medoids问题， &emsp;&emsp;reward function使用这两个相加，训练时，保持这两个数量级一致。 Training with Policy Gradient&emsp;&emsp;这里介绍使用的强化学习的训练方法，和一些tricks。&emsp;&emsp;因为选择更多的帧也能提高reward，所以加入正则项。和防止过拟合的改进。&emsp;&emsp;这里给出更新参数的公式和最优化算法（Adam），详情见论文。 Summary Generation&emsp;&emsp;通过最大化得分选择子热点，同时控制帧数量不超过总长度15%。热点得分是通过平均化同一个热点中帧的得分来计算的。时间分割算法使用KTS。","author":"Zhiyuan","categories":[{"name":"AI","slug":"AI","permalink":"http://Zhiyuancs.github.io/categories/AI/"}],"tags":[{"name":"视频摘要","slug":"视频摘要","permalink":"http://Zhiyuancs.github.io/tags/视频摘要/"}]},{"title":"Video Summarization with LSTM","slug":"Video-Summarization-with-Long-Short-term-Memory","date":"un00fin00","updated":"un44fin44","comments":true,"path":"2019/09/15/Video-Summarization-with-Long-Short-term-Memory/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/15/Video-Summarization-with-Long-Short-term-Memory/","excerpt":"","text":"Abstract&emsp;&emsp;这篇文章提出一个新奇的监督学习方法用来进行视频摘要，用来自动选择关键帧或者关键子热点。将这项任务看成一个结构预测问题（structured prediction problem），主要思路是用LSTM对帧的时间依赖性进行建模。 Introduction&emsp;&emsp;视频摘要如今有两个重要的方法：关键帧选择（keyframe selection，选择一些具有代表性的帧来组成摘要）；关键子热点选择（Key subshot selection，选择一系列在短时间类连续的帧组成摘要，即选择视频中具有代表性的每个时间点，将这些时间点的帧选择）。&emsp;&emsp;非监督学习方法：通过直观标准选择帧&emsp;&emsp;监督学习方法：通过视频帧的标注训练模型，使模型自动学习选择帧的标准。&emsp;&emsp;模型输入是视频的帧序列，输出是一个二元数组（表示这些帧是否选择）。由此得到启发使用LSTM。视频帧内部的依赖性是复杂且不均匀的。&emsp;&emsp;使用LSTM从时间上建立帧的联系，比从视觉上建立联系好（比如不同帧的相似性）。时间上相近的帧，包含的信息会冗余且相似。但是相似的帧包含的信息并不一定相同，且时间不一定相近。使用LSTM来学习时间线。&emsp;&emsp;这篇文章研究如何将LSTM及其变体应用到Video Summarization中。将LSTM与DPP（determinantalpoint process）结合，等一些改进方法。 Model OverviewvsLSTM网络结构： MLP（多层感知机）：输出为标量 使用SGD更新参数，这里是监督学习的方法，使用帧级别重要性得分（连续变量）或者选择的关键帧编码（二元向量） 由于LSTM（查全率高，查准率低），DPP（查准率高，查全率低），现在将这两个结合， DPP（行列式点过程）：DPP编码了从全集中选取任意一个子集的概率 z是子集,Z为全集，L为N*N的核矩阵（记录任意连个帧之间的相似性，实对称半正定方阵），det()为行列式的值，I是N*N的单位矩阵，子集z的概率与矩阵Lz的主子式行列式的值成正比。如果子集中有两个相同的元素时，det(Lz)将等于0。Lz是z在Z中标号对应元素组成的子方阵。 关于DDP的数学证明：https://blog.csdn.net/qq_23947237/article/details/90698325 dppLSTM： MLP是由256个sigmoid隐单元、sigmoid和线性输出单元组成的单层神经网络，两个MLP（第一个计算frame-level importance,第二个计算相似性） Learning： 参数的学习使用MLE（最大似然估计），采用阶段化优化策略：首先训练MLP1和LSTM（vsLSTM）；接下来通过最大化dpp模型指定关键帧的可能性来训练所有mlp和lstm层。 具体细节见论文及增刊","author":"Zhiyuan","categories":[{"name":"AI","slug":"AI","permalink":"http://Zhiyuancs.github.io/categories/AI/"}],"tags":[{"name":"视频摘要","slug":"视频摘要","permalink":"http://Zhiyuancs.github.io/tags/视频摘要/"}]},{"title":"Hexo-Hueman Insight-Search配置","slug":"Hexo-Hueman-Insight-Search配置","date":"un11fin11","updated":"un11fin11","comments":true,"path":"2019/09/09/Hexo-Hueman-Insight-Search配置/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/09/Hexo-Hueman-Insight-Search配置/","excerpt":"","text":"博客中的搜索功能一直无法使用，使用npm install -S hexo-generator-json-content安装插件后，仍然无法使用。 通过阅读hexo-generator-json-content的源码配置文件后得知，还需要对hexo的config文件做相应配置： 1234567891011121314151617181920212223242526272829303132333435363738jsonContent: meta: true dafts: false file: content.json keywords: undefined dateFormat: undefined pages: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: false text: true raw: false content: false author: true posts: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: false text: true raw: false content: false author: true categories: true tags: true","author":"Zhiyuan","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://Zhiyuancs.github.io/tags/Hexo/"}]},{"title":"Python3 while-else、//","slug":"Python3-while-else、","date":"un00fin00","updated":"un00fin00","comments":true,"path":"2019/09/08/Python3-while-else、/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/08/Python3-while-else、/","excerpt":"","text":"在LeetCode-自除数答案中学到的几个语法和技巧， While-else: 1、在Python中，else 可以和 while 循环搭配使用，当 while 循环正常执行完的情况下，执行 else 输出； 2、如果当 while 循环中执行了跳出循环的语句，比如 break，将不执行 else 代码块的内容。 //:向下取整 12345678910class Solution: def selfDividingNumbers(self, left: int, right: int) -&gt; List[int]: ans = [] for num in range(left,right + 1): copy = num while copy &gt; 0: div, copy = copy % 10, copy // 10 if div == 0 or num % div != 0: break else: ans.append(num) # while … else 在循环条件为 false 时执行 else 语句块 return ans","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]},{"title":"Python3 Counter类、all()","slug":"Python3-Counter类、all","date":"un55fin55","updated":"un55fin55","comments":true,"path":"2019/09/06/Python3-Counter类、all/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/06/Python3-Counter类、all/","excerpt":"","text":"Counter类(计数器) Counter类返回一个字典，统计每个元素出现次数，可以更新 123456import collectionsobj = collections.Counter(['11','22'])obj.update(['22','55'])print(obj)#输出：Counter(&#123;'22': 2, '11': 1, '55': 1&#125;) all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。 12345678910class Solution: def countCharacters(self, words: List[str], chars: str) -&gt; int: count=collections.Counter(chars) sumlen=0 for word in words: c=collections.Counter(word) #list类型作为参数 if all([count[i]&gt;=c[i] for i in word]): sumlen+=len(word) return sumlen dict.item()返回字典键值对组成的元组","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]},{"title":"yield from简单理解","slug":"yield-from简单理解","date":"un44fin44","updated":"un44fin44","comments":true,"path":"2019/09/05/yield-from简单理解/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/05/yield-from简单理解/","excerpt":"","text":"yieldyield简单理解可以看成return，但是函数执行yield后会返回值但是不会终止。 123456789# yield返回值, 生成器def gen(): for x in [\"a\", \"b\", \"c\"]: yield xfor i in gen(): print(i)# a b c 在函数外部不能使用yield from（yield也不行）。 yield fromyield from用来调用生成器，可以用于递归函数中，或者调用的函数中包含yield语句 1234567891011121314#中序遍历树class Solution: def increasingBST(self, root): def inorder(node): if node: yield from inorder(node.left) yield node.val yield from inorder(node.right) ans = cur = TreeNode(None) for v in inorder(root): cur.right = TreeNode(v) cur = cur.right return ans.right 上例函数为生成器函数，生成器对象是一个可迭代对象，可以存储遍历结果","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]},{"title":"LeetCode-下一个更大元素1","slug":"LeetCode-下一个更大元素1","date":"un33fin33","updated":"un33fin33","comments":true,"path":"2019/09/04/LeetCode-下一个更大元素1/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/04/LeetCode-下一个更大元素1/","excerpt":"","text":"题目地址 数据结构：栈、哈希表 思路：遍历nums2，哈希表存储每个元素后第一个大于它的元素。栈为递减栈，当遇到比栈顶元素大的元素，依次弹出元素，存入哈希表。最后遍历nums1，hash[nums[i]]组成的列表即为所求。 如 nums1 = [4,1,2], nums2 = [1,3,4,2]. stack=[1] hash[1]=3 hash[3]=-1(第一次出现该元素，hash值为-1) stack=[3] hash[3]=4 hash[4]=-1 stack=[4] stack=[4,2] hash[2]=-1 123456789101112131415class Solution(object): def nextGreaterElement(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: List[int] \"\"\" stack=[] hashmap=&#123;&#125; for num in nums2: while len(stack)&gt;0 and stack[-1]&lt;num : hashmap[stack.pop()]=num hashmap[num]=-1 stack.append(num) return [hashmap[i] for i in nums1]","author":"Zhiyuan","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/tags/LeetCode/"}]},{"title":"LeetCode-质数排列","slug":"LeetCode-质数排列","date":"un11fin11","updated":"un00fin00","comments":true,"path":"2019/09/02/LeetCode-质数排列/","link":"","permalink":"http://Zhiyuancs.github.io/2019/09/02/LeetCode-质数排列/","excerpt":"","text":"质数：质数是大于1的，且不能用小于它的两个正整数乘积表示。 首先求1-n中质数的个数 1234567891011def getnum(self,n:int) -&gt;int: num=0 for i in range(2,n+1): flag=True for j in range(2,int(i**0.5)+1): if i%j==0: flag=False break if flag==True: num+=1 return num 总的方案数就是质数排列数和非质数排列数的乘积 123456789101112def jiecheng(self,n:int) -&gt;int: sums=1 for i in range(1,n+1): sums*=i return sums%1000000007def numPrimeArrangements(self, n: int) -&gt; int: if n==1 or n==2: return 1 count=self.getnum(n) #调用类中的函数要使用self. num=self.jiecheng(count)*self.jiecheng(n-count) return num%1000000007","author":"Zhiyuan","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/tags/LeetCode/"},{"name":"数论","slug":"数论","permalink":"http://Zhiyuancs.github.io/tags/数论/"}]},{"title":"LeetCode-验证回文串","slug":"Python-回文字符串","date":"un55fin55","updated":"un11fin11","comments":true,"path":"2019/08/30/Python-回文字符串/","link":"","permalink":"http://Zhiyuancs.github.io/2019/08/30/Python-回文字符串/","excerpt":"","text":"filter(str.isalnum,s)1、filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。2、Python isalnum()方法isalnum() 方法检测字符串是否由字母和数字组成。","author":"Zhiyuan","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://Zhiyuancs.github.io/categories/学习笔记/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://Zhiyuancs.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"http://Zhiyuancs.github.io/tags/Python/"}]}]}