<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <url>%2F2020%2F04%2F19%2FHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[jdk1.8之后的HashMap源码分析： 1、类的属性//序列号 private static final long serialVersionUID = 362498820763181265L; //默认初始容量为16 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //最大容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //默认装载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; //超过该值，使用红黑树 static final int TREEIFY_THRESHOLD = 8; //小于该值，转化为链表 static final int UNTREEIFY_THRESHOLD = 6; //转化为红黑树时table的最小大小 static final int MIN_TREEIFY_CAPACITY = 64; //存储元素的数组，大小总为2的幂次方 transient Node&lt;K,V&gt;[] table; //存放具体元素的集合 transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; // 存放元素的个数，注意这个不等于数组的长度。 transient int size; // 每次扩容和更改map结构的计数器 transient int modCount; // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容 int threshold; // 加载因子 final float loadFactor 1.1 loadFactor加载因子loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密。 loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。 给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。 1.2 thresholdthreshold = capacity * loadFactor，是衡量数组是否需要扩容的标准，当数组存储元素数目大于阈值就需要扩容。 2、数据结构2.1 node节点static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { //哈希值，存放元素时用来比较的 final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + &quot;=&quot; + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } //重写 public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; } return false; } } 2.2 红黑树节点static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; { TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; //判断颜色 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) { super(hash, key, val, next); } /** * Returns root of tree containing this node. */ final TreeNode&lt;K,V&gt; root() { for (TreeNode&lt;K,V&gt; r = this, p;;) { if ((p = r.parent) == null) return r; r = p; } } } 3、源码分析3.1 构造函数// 默认构造函数。 public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } // 包含另一个“Map”的构造函数 public HashMap(Map&lt;? extends K, ? extends V&gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);//下面会分析到这个方法 } // 指定“容量大小”的构造函数 public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } // 指定“容量大小”和“加载因子”的构造函数 public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } 3.2 putMapEntries方法final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) { int s = m.size(); if (s &gt; 0) { //table未初始化 if (table == null) { // pre-size //计算给定负载因子下需要的元素容量 float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); //如果得到的t大于阈值，则初始化阈值 if (t &gt; threshold) threshold = tableSizeFor(t); } //如果大于阈值，则进行扩容 else if (s &gt; threshold) resize(); //将m的元素添加到该hashMap中 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) { K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); } } } 3.3 put方法 public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st //转化为红黑树，其中会判断table长度是否小于MIN_TREEIFY_CAPACITY，如果小于 //则扩容，不转为红黑树 treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); //插入后回调 afterNodeInsertion(evict); return null; } 3.4 get方法public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { // 数组元素相等 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 桶中不止一个节点 if ((e = first.next) != null) { // 在树中get if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 在链表中get do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 3.5 resizefinal Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 计算新的resize上限 if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } threshold = newThr; @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) { // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) { oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else { Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } // 原索引+oldCap else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) { loTail.next = null; newTab[j] = loHead; } // 原索引+oldCap放到bucket里 if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 参考1、https://snailclimb.gitee.io/javaguide/#/docs/java/collection/HashMap]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JAVA随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring学习笔记]]></title>
    <url>%2F2020%2F02%2F04%2FSpring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1. 基于XML的IOC配置1、在类的根路径下创建一个任意名称的xml文件,如bean.xml,添加依赖。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;/beans&gt; 2、让spring管理资源，在配置文件中配置service和dao &lt;!-- bean标签：用于配置让spring创建对象， 并且存入ioc容器之中 id属性：对象的唯一标识 class属性：指定要创建对象的全限定类名 --&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt;&lt;/bean&gt; 3、使用配置 //1.使用ApplicationContext接口，就是在获取spring容器 ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); //2.根据bean的id获取对象 IAccountService aService = (IAccountService) ac.getBean(&quot;accountService&quot;); 掌握Spring中工厂类的结构图。 2. Spring中IOC细节1、BeanFactory 和ApplicationContext 的区别 BeanFactory 是Spring 容器中的顶层接口。 ApplicationContext 是它的子接口。 BeanFactory 和ApplicationContext 的区别： 创建对象的时间点不一样。 ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。 BeanFactory：使用时创建对象。2、ApplicationContext 接口的实现类 ClassPathXmlApplicationContext： 它是从类的根路径下加载配置文件 推荐使用这种 FileSystemXmlApplicationContext： 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 AnnotationConfigApplicationContext: 当我们使用注解配置容器对象时，需要使用此类来创建spring 容器。它用来读取注解。@Test public void testUpdateAccount() { ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); IAccountService as = ac.getBean(&quot;accountService&quot;,IAccountService.class); Account account = as.findAccountById(1); account.setMoney(20301050f); as.updateAccount(account); } 3、bean标签和管理对象细节 作用：配置对象让Spring来创建，默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则无法创建。 属性： id：给对象在容器中提供一个唯一标志，用于获取对象 ​ class：指定类的全限定类名，用于反射创建对象。默认情况下调用无参构造函数。 ​ scope：指定对象的作用范围。 ​ singleton：默认值，单例 ​ prototype：多例 ​ request：WEB项目中,Spring创建一个Bean的对象,将对象存入到request域中. ​ session：WEB项目中,Spring创建一个Bean的对象,将对象存入到session域中. ​ global session：WEB项目中,应用在Portlet环境. ​ init-method：指定类中的初始化方法名称。 ​ destroy-method：指定类中销毁方法名称。 4、实例化Bean的三种方式 第一种方式：使用默认无参构造函数 &lt;!--在默认情况下： 它会根据默认无参构造函数来创建类对象。 如果bean中没有默认无参构造函数，将会创建失败。--&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;/&gt; 第二种方式：spring管理静态工厂-使用静态工厂的方法创建对象 /** * 模拟一个静态工厂，创建业务层实现类 */ public class StaticFactory { public static IAccountService createAccountService(){ return new AccountServiceImpl(); } } &lt;!-- 此种方式是: 使用StaticFactory类中的静态方法createAccountService创建对象，并存入spring容器 id属性：指定bean的id，用于从容器中获取 class属性：指定静态工厂的全限定类名 factory-method属性：指定生产对象的静态方法 --&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.factory.StaticFactory&quot; factory-method=&quot;createAccountService&quot;&gt; &lt;/bean&gt; 第三种方式：spring管理实例工厂-使用实例工厂的方法创建对象 /** * 模拟一个实例工厂，创建业务层实现类 * 此工厂创建对象，必须现有工厂实例对象，再调用方法 */ public class StaticFactory { public IAccountService createAccountService(){ return new AccountServiceImpl(); } } &lt;!-- 此种方式是： 先把工厂的创建交给spring来管理。 然后在使用工厂的bean来调用里面的方法 factory-bean属性：用于指定实例工厂bean的id。 factory-method属性：用于指定实例工厂中创建对象的方法。 --&gt; &lt;bean id=&quot;instancFactory&quot; class=&quot;com.itheima.factory.InstanceFactory&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;accountService&quot; factory-bean=&quot;instancFactory&quot; factory-method=&quot;createAccountService&quot;&gt;&lt;/bean&gt; 3. Spring的依赖注入3.1 构造函数注入使用构造函数注入需要在类中提供一个对应参数列表的构造函数。涉及标签为constructor-arg，属性为index指定参数在构造函数参数列表的索引位置，type指定参数在构造函数中的数据类型，name指定参数在构造函数中的名称，value赋值的为基本数据类型和String类型，ref赋值为其他bean类型，即在配置文件中配置过的bean。 &lt;bean id=&quot;accountService&quot; class=&quot;com.neu.service.impl.AccountServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt; 3.2 set方法注入使用set方法给bean属性传值需要先在类中方法定义set方法，涉及标签为property，属性为name，ref，value。 &lt;bean id=&quot;accountService&quot; class=&quot;com.neu.service.impl……&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;test&quot;&gt;&lt;/property&gt; …… &lt;/bean&gt; 3.3 使用p名称空间注入数据此种方式是通过在xml中导入p名称空间，使用p:propertyName来注入数据，它的本质仍然是调用类中的set方法实现注入功能。 &lt;bean id=&quot;accountService&quot; class=&quot;……&quot; p:name=&quot;test&quot; p:age=&quot;21&quot; p:birthday-ref=&quot;now&quot;/&gt; 3.4 注入集合属性给类中的集合成员传值，它用的也是set方法注入的方式，只不过变量的数据类型都是集合。我们这里介绍注入数组，List,Set,Map,Properties。 &lt;!-- List结构：array,list,set Map结构：map,entry,props,prop --&gt; &lt;bean id=&quot;accountService&quot; class=&quot;……&quot;&gt; &lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt; &lt;!-- 给数组注入数据 --&gt; &lt;property name=&quot;myStrs&quot;&gt; &lt;set&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- 注入Map数据 --&gt; &lt;property name=&quot;myMap&quot;&gt; &lt;props&gt; &lt;prop key=&quot;testA&quot;&gt;aaa&lt;/prop&gt; &lt;prop key=&quot;testB&quot;&gt;bbb&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 4. 基于注解的IOC配置基于注解整合时，导入约束时需要多导入一个context名称空间下的约束。同时需要告知spring创建容器时需要扫描的包。 &lt;!-- 告知spring创建容器时要扫描的包 --&gt; &lt;context:component-scan base-package=&quot;com.neu&quot;&gt;&lt;/context:component-scan&gt; 4.1 用于创建对象的相当于&lt;bean id=&quot;&quot; class=&quot;&quot;&gt; 4.1.1 @Component作用：把资源让spring来管理，相当于xml中配置一个bean 属性：value：指定bean的id。如果不指定value属性，默认bean的id是当前类的类名。首字母小写。 4.1.2 @Controller @Service @Repository为@Component的衍生注解。 @Controller:一般用于表现层注解 @Service：一般用于业务层注解 @Repository:一般用于持久层注解 属性：value 4.2 用于注入数据的相当于&lt;property name=&quot;&quot; ref=&quot;&quot;&gt; 4.2.1 @Autowired作用：自动按照类型注入，当有多个类型匹配时，使用要注入的对象变量名称作为bean的id，在spring容器查找，找到了也可以注入成功。 4.2.2 @Qualifier在自动按照类型注入的基础之上，再按照Bean的id注入。它在给字段注入时不能独立使用，必须和@Autowire一起使用；但是给方法参数注入时，可以独立使用。 属性：value：指定bean的id。 4.2.3 @Resource根据名称注入，属性name 4.2.4 @Value注入基本数据类型和String数据类型，value用于指定值 4.3 用于改变作用范围的相当于：&lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;&quot;&gt; 4.3.1 @Scope作用：指定bean的作用范围 属性：value：指定范围的值（singleton，prototype……） 4.4 和生命周期相关相当于&lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;&quot; destroy-method=&quot;&quot;/&gt; 4.4.1 @PostConstruct指定初始化方法 4.4.2 @PreDestroy用于指定销毁方法 4.5 更多注解4.5.1 @Configuration用于指定当前类是一个spring配置类，当创建容器时会从该类上加载注解。获取容器时需要使用AnnotationApplicationContext(有@Configuration注解的类.class)。 属性： value：用于指定配置类的字节码 @Configuration @ComponentScan(&quot;com.neu&quot;) public class SpringConfiguration { } 把配置文件用类来代替 4.5.2 @ComponentScan指定Spring在初始化容器时要扫描的包，属性：basePackage：用于指定要扫描的包。 4.5.3 @Bean该注解只能写在方法上，表名使用此方法创建一个对象，并放入spring容器。 属性：name：给当前@Bean注解方法创建一个指定的名称（即bean的id） 使用该类对象时，可以直接用name代替。 4.5.4 @PropertySource用于加载.properties文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到properties配置文件中，就可以使用此注解指定properties配置文件的位置。 属性： value[]：用于指定properties文件位置。如果是在类路径下，需要写上classpath: @Value(&quot;${jdbc.driver}&quot;) private String driver;4.5.5 @Import用于导入其他配置类，属性value()，用于指定其他配置类的字节码。 @Configuration @ComponentScan(basePackages=&quot;com.neu&quot;) //将其他配置类与这个配置类合并 @Import({JdbcConfig.class}) public class SpringConfigruation{ } @Configuration @PropertySource(&quot;classpath:jdbc.properties&quot;) public class JdbcConfig{ } 4.6 通过注解获取容器ApplicationContext ac= new AnnotationConfigApplicationContext(SpringConfiguration.class); 5. Spring整合JUnit1、使用@RunWith注解替换原有的运行器 @RunWith(SpringJUnit4ClassRunner.class) public class AccountServiceTest{ } 2、使用@ContextConfiguration指定spring配置文件的位置。 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations= {&quot;classpath:bean.xml&quot;}) public class AccountServiceTest { } 3、使用@Autowired给测试类中的变量注入数据 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations= {&quot;classpath:bean.xml&quot;}) public class AccountServiceTest { @Autowired private IAccountService as ; } 6. AOP6.1 AOP简介作用：在程序运行期间，不修改源码对已有方法进行增强。 优势：减少重复代码，提高开发效率，维护方便。 实现方式：动态代理技术 Joinpoint(连接点)：指那些被拦截到的点，在Spring中指的是方法，Spring只支持方法类型的连接点。通过动态代理技术对这些方法添加额外的操作。 Pointcut(切入点)：指对连接点进行拦截的定义。 Advice(通知/增强)：指拦截到Joinpoint之后所要做的事情就是通知，通知的类型：前置通知、后置通知、异常通知、最终通知、环绕通知。 Introduction(引介)：引介是一种特殊的通知，在不修改代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Field。 Target(目标对象)：代理的目标对象。 Weaving(织入)：是指把增强应用到目标对象来创建新的代理对象的过程。Spring采用动态代理织入。 Proxy(代理)：一个类AOP织入增强后，就产生一个结果代理类。 Aspect(切面)：切入点和通知的结合。 6.2 步骤1、抽取公共代码制作成通知。 2、把通知类用bean标签配置起来。 &lt;bean id=&quot;txManager&quot; class=&quot;com.neu.utils.TransactionManager&quot;&gt; &lt;property name=&quot;dbAssit&quot; ref=&quot;dbAssit&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 3、使用aop:config声明aop配置。 &lt;aop:config&gt; &lt;!--配置的代码都写在此处--&gt; &lt;/aop:config&gt; 4、使用aop:aspect配置切面。 &lt;!-- id:给切面提供唯一标志 ref:引用配置好的通知类bean的id --&gt; &lt;aop:aspect id=&quot;txAdvice&quot; ref=&quot;txManager&quot;&gt; &lt;!--配置通知的类型写在此处--&gt; &lt;/aop:aspect&gt; 5、使用aop:pointcut配置切入点表达式。 作用：配置切入点表达式，就是指定对哪些类的方法进行增强。 属性：expression：用于定义切入点表达式； id：用于给切入点表达式提供一个唯一标识 &lt;aop:pointcut expression=&quot;execution( public void com.neu.service.impl.AccountServiceImpl.transfer( java.lang.String,java.lang.String,java.lang.Float))&quot; id=&quot;pt1&quot;/&gt; 6、使用aop:xxx配置对应的通知类型。 aop:before 作用：用于配置前置通知，指定增强的方法在切入点之间执行。 属性：method：用于指定通知类中的增强方法名称 pointcut-ref：用于指定切入点表达式的引用 pointcut:用于指定切入点表达式 &lt;aop:before method=&quot;beginTransaction&quot; pointcut-ref=&quot;pt1&quot;/&gt; aop:after-returning 作用：用于配置后置通知 执行时间点：切入点方法正常执行之后，它和异常通知只能有一个执行 &lt;aop:after-returning method=&quot;commit&quot; pointcut-ref=&quot;pt1&quot;/&gt; aop:after-throwing 作用：用于配置异常通知 执行时间点：切入点方法执行异常之后执行，它和后置通知只能执行一个 &lt;aop:after-throwing method=&quot;rollback&quot; pointcut-ref=&quot;pt1&quot;/&gt; aop:after 作用：用于配置最终通知 执行时间点：无论切入点方法是否有异常，它都会在其后面执行 &lt;aop:after method=&quot;release&quot; pointcut-ref=&quot;pt1&quot;/&gt; 6.3 切入点表达式说明execution(表达式) 表达式语法：execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 写法说明： 1.全匹配方式： 2.访问修饰符可以省略 3.返回值可以使用*号，表示任意返回值 4.包名可以使用*号，表示任意包，但是有几级包，需要写几个* * *.*.*.*.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 5.使用..来表示当前包，及其子包 * com..AccountServiceImpl.saveAccount(com.itheima.domain.Account) 6.类名可以使用*号，表示任意类 7.方法名可以使用*号，表示任意方法 8.参数列表可以使用*，表示参数可以是任意数据类型，但是必须有参数 * com..*.*(*) 9.参数列表可以使用..表示有无参数均可，有参数可以是任意类型 * com..*.*(..) 10.全通配方式： * *..*.*(..) 注：通常情况下，我们都是对业务层的方法进行增强，所以切入点表达式都是切到业务层实现类。 execution(* com.itheima.service.impl.*.*(..))6.4 环绕通知aop:around： 作用： 用于配置环绕通知 属性： method：指定通知中方法的名称。 pointct：定义切入点表达式 pointcut-ref：指定切入点表达式的引用 说明： 它是spring框架为我们提供的一种可以在代码中手动控制增强代码什么时候执行的方式。 注意： 通常情况下，环绕通知都是独立使用的。 &lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution (* com.itheima.service.impl.*.*(..))&quot; id=&quot;pt1&quot;/&gt; &lt;aop:aspect id=&quot;txAdvice&quot; ref=&quot;txManager&quot;&gt; &lt;!-- 配置环绕通知 --&gt; &lt;aop:around method=&quot;transactionAround&quot; pointcut-ref=&quot;pt1&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; //spring框架为我们提供了一个接口：ProceedingJoinPoint，它可以作为环绕通知的方法参数。 //在环绕通知执行时，spring框架会为我们提供该接口的实现类对象，我们直接使用就行。 public Object transactionAround(ProceedingJoinPoint pjp) { //定义返回值 Object rtValue = null; try { //获取方法执行所需的参数 Object[] args = pjp.getArgs(); //前置通知：开启事务 beginTransaction(); //执行方法 rtValue = pjp.proceed(args); //后置通知：提交事务 commit(); }catch(Throwable e) { //异常通知：回滚事务 rollback(); e.printStackTrace(); }finally { //最终通知：释放资源 release(); } return rtValue; } 6.5 基于注解的AOP1、在通知类上使用@Aspect注解声明为切面 2、在增强的方法上使用注解配置通知 //开启事务 //value:用于指定切入点表达式 @Before(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;) public void beginTransaction() { try { dbAssit.getCurrentConnection().setAutoCommit(false); } catch (SQLException e) { e.printStackTrace(); } } //后置通知 @AfterReturning //异常通知 @AfterThrowing //最终通知 @After 3、在spring配置文件中开启spring对注解AOP的支持 &lt;!-- 开启spring对注解AOP的支持 --&gt; &lt;aop:aspectj-autoproxy/&gt; 4、环绕通知注解配置 @Around 作用： 把当前方法看成是环绕通知。 @Around(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;) public Object transactionAround(ProceedingJoinPoint pjp) { } 5、切入点表达式注解 @Pointcut 作用： 指定切入点表达式 @Pointcut(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;) private void pt1() {} //引用方式，注意括号 @Around(&quot;pt1()&quot;) 6、不使用XML配置 @Configuration @ComponentScan(basePackages=&quot;com.itheima&quot;) @EnableAspectJAutoProxy public class SpringConfiguration { }]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习笔记]]></title>
    <url>%2F2020%2F02%2F01%2FMybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.mybatis简单应用1.1步骤：1.编写实体类User，建立数据库表对应的对象（变量及其get、set方法）； 2.编写持久层接口IUserDao，数据库操作的接口，如（List&lt;User&gt; findall()）; 3.编写持久层接口的映射文件IUserDao.xml，要求：必须和持久层接口在相同的包中，必须以持久层接口名称命名文件名； &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt; &lt;!-- 配置查询所有操作 --&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; 4.编写SqlMapConfig.xml; &lt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;!-- mybatis的主配置文件 --&gt; &lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=&quot;mysql&quot;&gt; &lt;!-- 配置mysql的环境--&gt; &lt;environment id=&quot;mysql&quot;&gt; &lt;!-- 配置事务的类型--&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/eesy_mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;1234&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/itheima/dao/IUserDao.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 1.2 基于注解的mybatis使用1.在持久层接口中添加注解； public interface IUserDao{ @Select(&quot;select * from user&quot;) List&lt;User&gt; findAll(); } 2.修改SqlMapConfig.xml，此时不需要IUserDao.xml。 &lt;mappers&gt; &lt;mapper class=&quot;com.neu.dao.IUserDao&quot;/&gt; &lt;/mappers&gt; 2.基于代理Dao实现CRUD操作使用要求： 1、持久层接口和持久层接口的映射配置必须在相同的包下； 2、持久层映射配置中mapper标签的namespace属性取值必须是持久层接口的全限定类名； 3、SQL语句的配置标签&lt;select&gt;,&lt;insert&gt;,&lt;delete&gt;,&lt;update&gt;的id属性必须和持久层接口的方法名相同。 &lt;!-- 根据id查询用户 --&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultMap=&quot;com.neu.domain.User&quot;&gt; select * from user where id = #{uid} &lt;/select&gt; &lt;!-- sql语句中使用#{}，表示占位符，用于替换具体数据，相当于jdbc中的？ --&gt; &lt;!-- 插入用户--&gt; &lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.neu.domain.User&quot;&gt; insert into user(username,birthday,sex) values(#{username},#{birthday},#{sex}) &lt;/insert&gt; //测试类 public class MybatisTest { private InputStream in; private SqlSession sqlSession; private IUserDao userDao; @Before//用于在测试方法执行之前执行 public void init()throws Exception{ //1.读取配置文件，生成字节输入流 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2.获取SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.获取SqlSession对象 sqlSession = factory.openSession(); //4.获取dao的代理对象 userDao = sqlSession.getMapper(IUserDao.class); } @After//用于在测试方法执行之后执行 public void destroy()throws Exception{ //提交事务 sqlSession.commit(); //6.释放资源 sqlSession.close(); in.close(); } @Test public void testFindOne() { //执行操作 User user = userDao.findById(41); System.out.println(user); } 3. Mybatis参数parameterType 配置参数： 1、基本类型和String我们可以直接写类型名称，也可以使用包名.类名的方式，例如：java.lang.String。 2、实体类类型，目前我们只能使用全限定类名。原因是mybaits在加载时已经把常用的数据类型注册了别名，从而我们在使用时可以不写包名，而我们的是实体类并没有注册别名，所以必须写全限定类名。 4.Mybatis输出结果封装当实体类属性和数据库表的列名不一致时，是无法将查询结果封装到实体类对象的，可以使用别名查询解决。 &lt;!-- 别名与实体类属性名一致--&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.neu.domain.User&quot;&gt; select id as userId,username as userName,sex as userSex from user &lt;/select&gt; resultMap结果类型resultMap标签可以建立查询的列名和实体类的属性名称不一致时建立对应关系。从而实现封装。 1、定义resultMap &lt;!-- 建立User实体和数据库表的对应关系 type属性：指定实体类的全限定类名 id属性：给定一个唯一标识，是给查询select标签引用用的。 --&gt; &lt;resultMap type=&quot;com.neu.domain.User&quot; id=&quot;userMap&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;userId&quot;/&gt; &lt;result column=&quot;usermane&quot; property=&quot;userName&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;userSex&quot;/&gt; &lt;/resultMap&gt; &lt;!-- id标签：用于指定主键字段 result标签：用于指定非主键字段 column标签：用于指定数据库列名 property标签：用于指定实体类属性名称 --&gt; 2、映射配置 &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt; select * from user; &lt;/select&gt; 5. SqlMapConfig.xml配置文件5.1 SqlMapConfig.xml中配置的内容和顺序-properties(属性) --property -settings(全局配置参数) --setting -typeAliases(类型别名) --typeAliase --package -typerHandlers(类型处理器) -objectFactory(对象工厂) -plugins(插件) -environments(环境集合属性对象) --environment(环境子属性对象) ---transactionManager(事务管理) ---dataSource(数据源) -mappers(映射器) --mapper --package5.2 properties5.2.1 第一种配置方式&lt;properties&gt; &lt;property name=&quot;jdbc.driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbc.url&quot; value=&quot;jdbc:mysql://localhost/3306/ssm&quot;/&gt; …… &lt;/properties&gt; 5.2.2 第二种方式1.在classpath下定义db.properties文件 jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/eesy_mybatis jdbc.username=root jdbc.password=12342.properties标签配置 &lt;!-- 配置properties--&gt; &lt;properties url=&quot;绝对路径&quot;&gt;&lt;/properties&gt; &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt; &lt;!--配置连接池--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt; &lt;/dataSource&gt; 5.3 typeAliases类型别名自定义别名 &lt;typeAliases&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias=&quot;user&quot; type=&quot;com.neu.dao.User&quot;/&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --&gt; &lt;package name=&quot;com.neu.domain&quot;/&gt; &lt;package name=&quot;其他包&quot;/&gt; &lt;/typeAliases&gt; 5.4 mappers1.&lt;mapper resource=&quot;&quot; /&gt; 使用相对于类路径的资源 &lt;mapper resource=&quot;com/neu/dao/IUserDao.xml&quot;/&gt;2.&lt;mapper class=&quot;&quot; /&gt; 使用mapper接口类路径 &lt;mapper class=&quot;com.neu.dao.UserDao&quot;/&gt; 注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。3.&lt;package name=&quot;&quot; /&gt; 注册指定包下的所有mapper接口 &lt;package name=&quot;cn.itcast.mybatis.mapper&quot;/&gt; 注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。6. Mybatis的事务控制Mybatis中需要手动进行事务的提交，原因是在连接池中取出的连接都会调用connection.setAutoCommit(false)方法，所以要加上sqlSession.commit()提交事务。 可以通过设置实现自动提交。 @Before//用于在测试方法执行之前执行 public void init()throws Exception{ //1.读取配置文件 in = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); //2.获取SqlSessionFactory SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); //3.获取SqlSession对象(实现自动提交，查看源码，参数含有autocommit) sqlSession = factory.openSession(true); //4.获取dao的代理对象 userDao = sqlSession.getMapper(IUserDao.class); } 7. 动态SQL通过 if, choose, when, otherwise, trim, where, set, foreach等标签，可组合成非常灵活的SQL语句。 7.1 &lt;if&gt;标签&lt;select id=&quot;findByUser&quot; resultType=&quot;user&quot; parameterType=&quot;user&quot;&gt; select * from user where 1=1 &lt;if test=&quot;username!=null and username!=&#39; &#39; &quot;&gt; and username like #{username} &lt;/if&gt; &lt;if test=&quot;address!= null&quot;&gt; and address like #{address} &lt;/if&gt; &lt;/select&gt; &lt;!-- test属性中写的是为对象的属性名及其条件， 符合条件的，在sql语句中加上标签内的语句 --&gt; 7.2 &lt;where&gt;标签为了简化上面where 1=1的条件拼装，可以使用where标签简化。 &lt;!-- sql重用 --&gt; &lt;sql id=&quot;defaultSql&quot;&gt; select * from user &lt;/sql&gt; &lt;select id=&quot;findByUser&quot; resultType=&quot;user&quot; parameterType=&quot;user&quot;&gt; &lt;include refid=&quot;defaultSql&quot;/&gt; &lt;where&gt; &lt;if test=&quot;username!=null and username!=&#39; &#39; &quot;&gt; username like #{username} &lt;/if&gt; &lt;!-- where标签会自动插入where，如果开头为and，会剔除掉and --&gt; &lt;if test=&quot;address!= null&quot;&gt; and address like #{address} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 7.3 &lt;foreach&gt;标签&lt;!-- 查询所有用户在id的集合之中 --&gt; &lt;!-- select * from user where id in (1,2,3,4,5); --&gt; &lt;select id=&quot;findInIds&quot; resultType=&quot;user&quot; parameterType=&quot;queryvo&quot;&gt; &lt;include refid=&quot;defaultSql&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;!-- ids为queryvo中的属性名，为list --&gt; &lt;if test=&quot;ids != null and ids.size() &gt; 0&quot;&gt; &lt;foreach collection=&quot;ids&quot; open=&quot;id in (&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #{uid} &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; collection:代表要遍历的集合 open：语句的开始部分 item：代表遍历集合的每个元素，生成的变量名 sperator：分隔符 8. 多表查询一对一 &lt;resultMap type=&quot;com.neu.domain.User&quot; id=&quot;userMap&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;userId&quot;/&gt; &lt;result column=&quot;usermane&quot; property=&quot;userName&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;userSex&quot;/&gt; &lt;association property=&quot; &quot; javaType=&quot; &quot;&gt; &lt;!-- 指定从表方的引用实体属性 --&gt; &lt;/association&gt; &lt;/resultMap&gt; 一对多（左外连接） &lt;!-- collection是用于建立一对多中集合属性的对应关系 ofType用于指定集合元素的数据类型 --&gt; &lt;!-- 如一个用户可以有多个账户，分用户表、账户表， 在User对象中加入账户集合 --&gt; &lt;resultMap type=&quot;com.neu.domain.User&quot; id=&quot;userMap&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;userId&quot;/&gt; &lt;result column=&quot;usermane&quot; property=&quot;userName&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;userSex&quot;/&gt; &lt;!-- property:关联查询结果存储在User对象的属性名称 --&gt; &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot;&gt; &lt;id column=&quot;aid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;uid&quot; property=&quot;uid&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; 9. 延迟加载延迟加载就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载。在多表查询中，即将其分成多次单表查询，resultMap中会加入其他表的对象，association和collection有select和column属性。SqlMapConfig.xml需要配置setting信息。 &lt;settings&gt; &lt;!-- 打开延迟加载的开关 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 将积极加载改为消极加载，即延迟加载 --&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;/settings&gt; 10. Mybatis缓存10.1 一级缓存一级缓存是SqlSession级别的缓存，只要SqlSession没有关闭，就一直存在。 10.2 二级缓存二级缓存是mapper映射级别的缓存，多个SqlSession去操作同一个Mapper映射的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。 1、需要在SqlMapConfig.xml文件中开启二级缓存。 2、配置相关的Mapper映射文件。&lt;cache&gt;&lt;/cache&gt; 3、配置statement上的useCache属性。 当我们在使用二级缓存时，所缓存的类一定要实现java.io.Serializable接口，这种就可以使用序列化方式来保存对象。 11. 注解方式11.1 常用注解@Insert:实现新增 @Update:实现更新 @Delete:实现删除 @Select:实现查询 @Result:实现结果集封装 @Results:可以与@Result一起使用，封装多个结果集 @ResultMap:实现引用@Results定义的封装 @One:实现一对一结果集封装 @Many:实现一对多结果集封装 @SelectProvider: 实现动态SQL映射 @CacheNamespace:实现注解二级缓存的使用11.2 注解说明@Results注解 代替标签&lt;resultMap&gt; 该注解中可以使用单个@Result注解，也可以使用@Result集合 @Result注解 代替了&lt;id&gt;标签和&lt;result&gt;标签 属性：id 是否是主键字段 column 数据库的列名 property需要装配的属性名 one 需要使用的@One注解（@Result（one=@One）（））） many 需要使用的@Many注解（@Result（many=@many）（））） @One注解（一对一） 代替了&lt;assocation&gt;标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。 @One注解属性介绍： select 指定用来多表查询的sqlmapper fetchType会覆盖全局的配置参数lazyLoadingEnabled @Result(column=&quot; &quot;,property=&quot;&quot;,one=@One(select=&quot;&quot;)) @Many注解（多对一） 代替了&lt;Collection&gt;标签,是多表查询的关键，在注解中用来指定子查询返回对象集合。 @Result(property=&quot;&quot;,column=&quot;&quot;,many=@Many(select=&quot;&quot;))11.3 基于注解的二级缓存1、在SqlMapConfig中开启二级缓存支持； &lt;!-- 配置二级缓存 --&gt; &lt;settings&gt; &lt;!-- 开启二级缓存的支持 --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; 2、在持久层接口中使用注解配置二级缓存； @CacheNamespace(blocking=true)//mybatis基于注解方式实现配置二级缓存 public interface IUserDao {}]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树]]></title>
    <url>%2F2019%2F12%2F26%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[线段树节点数据结构： class SegmentTree{ int l,r; //每个区间的左右端点 int sum; //区间数据 //其他附加信息 } 建树以完全二叉树建树，可以使用父子二倍标记法，子节点下标为父节点下标值的两倍。 //递归建树 //p:当前父节点，sak为节点数组 void build(int p,int l,int r){ sak[p].l=l;sak[p].r=r; if(l==r){ sak[p].sum=a[l]; return; } int mid = (l+r)/2; //依次建立左右子树 build(2*p,l,mid); build(2*p+1,mid+1,r); sak[p].sum = sak[2*p].sum+sak[2*p+1].sum; } 单点修改每次操作都是从根节点开始遍历，递归找到需要修改的节点。 //p:当前节点 x:目标节点 val:修改值 void change(int p,int x,int val){ if(sak[p].l==sak[p].r){ sak[p].sum = val; return; } int mid = (l+r)/2; if(x &lt;= mid) change(p*2,x,val); else change(p*2+1,x,val); sak[p].sum = sak[p*2].sum + sak[p*2+1].sum; } 区间查询 若当前节点所表示的区间已经被询问区间所完全覆盖，则立即回溯，并传回该点的信息。 若当前节点的左儿子所表示的区间已经被询问区间所完全覆盖，就递归访问它的左儿子。 若当前节点的右儿子所表示的区间已经被询问区间所完全覆盖，就递归访问它的右儿子。 int ask(int p,int l,int r){ if(l &lt;= sak[p].l &amp;&amp; r &gt;= sak[p].r) return sak[p].sum; int val = 0 ; int mid = (sak[p].l + sak[p].r)/2; if(l&lt;=mid) val+=ask(2*p,l,r); if(r&gt;mid) val+=ask(2*p+1,l,r); return val; }]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2019%2F12%2F05%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。可以求解一些图相关的问题（连通分量）。 并查集森林是一种将每一个集合以树的形式表示的数据结构，其中每个结点都保存着到他父节点的引用。在并查集森林中，每个集合的代表即是集合的根节点。“查找”根据其父节点的引用向根行进直到到底树根。“联合”将两棵树合并到一起，这通过将一棵树的根连接到另一棵树的根。 class UnionSet{ int[] parent; //初始化并查集,每个结点自成一个集合 void UnionSet(int n){ parent=new int[n]; for(int i=0;i&lt;n;i++){ parent[i]=i; } } //递归查找根节点 int find(int x){ if(parent[x]==x) return x; else return find(parent[x]); } //将x,y所在集合合并 void union(int x,int y){ int xRoot = find(x); int yRoot = find(y); parent[xRoot] = yRoot; } } 上述方法可能会导致严重的不平衡，下面介绍优化的方法。 按秩合并按秩合并总是将更小的树连接到更大的树上，秩代表树的深度，单元素的树秩为0，当两颗秩为r的树合并时秩为r+1. class UnionSet{ int[] parent; int[] rank; void UnionSet(int n){ parent=new int[n]; rank=new int[n]; for(int i=0;i&lt;n;i++){ parent[i]=i; } } int find(int x){ //操作相同 } void union(int x,int y){ int xRoot = find(x); int yRoot = find(y); if(rank[xRoot] &gt; rank[yRoot]){ parent[yRoot] = xRoot; }else if(rank[xRoot] &lt; rank[yRoot]){ parent[xRoot] = yRoot; }else{ parent[xRoot] = yRoot; rank[yRoot] += 1; } } } 路径压缩将每个结点直接连接到根节点上 int find(int x){ if(parent[x]!=x){ parent[x]=find(parent[x]); } return parent[x]; }]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成随机字符串]]></title>
    <url>%2F2019%2F12%2F05%2F%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[11月一直在准备考试和各种结课作业，停滞了很长时间没有学习新技术了。最近在stackoverflow上看到一些有趣的问题，就自己做了相关总结。 https://stackoverflow.com/questions/41107/how-to-generate-a-random-alpha-numeric-string 问题：生成伪随机的字母-数字字符串。For example, a generated string of length 12 might look something like &quot;AEYGF7K0DM1X&quot;. 类的逻辑较为简单，不过使用了一些之前没接触过的库函数。 1、java.util.concurrent.ThreadLocalRandom Random虽然是线程安全的，但是在多线程环境下效率很低，而且Random产生的随机数序列可以预测，顾不适合作为验证码类随机数产生。（思考：图片验证码产生是不是根据产生的随机数从数据库中选出相应的图片作为验证码？） System.out.println(&quot;-----------产生1到10之间的随机数----------------&quot;); // 返回当前线程的 ThreadLocalRandom // 每个线程都有一个独立的生成器 ThreadLocalRandom threadRandom = ThreadLocalRandom.current(); System.out.println(threadRandom.nextInt(10)); System.out.println(&quot;-----------产生两个数之间的随机数----------------&quot;); System.out.println(threadRandom.nextInt(10,100)); 2、Random类默认使用当前系统时钟作为种子，种子相同生成的随机数序列也相同，所以不安全。操作系统收集了一些随机事件，比如鼠标点击，键盘点击等等，SecureRandom 使用这些随机事件作为种子。安全性很高。具体原理感兴趣可以研究。 import java.security.SecureRandom; import java.util.Locale; import java.util.Objects; import java.util.Random; import java.util.concurrent.ThreadLocalRandom; public class RandomString { /** * Generate a random string. */ public String nextString() { for (int idx = 0; idx &lt; buf.length; ++idx) buf[idx] = symbols[random.nextInt(symbols.length)]; return new String(buf); } public static final String upper = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; // Local.ROOT 获取系统的语言环境 public static final String lower = upper.toLowerCase(Locale.ROOT); public static final String digits = &quot;0123456789&quot;; public static final String alphanum = upper + lower + digits; private final Random random; private final char[] symbols; private final char[] buf; // length 生成随机字符串长度 // symbols 用于生成随机字符串的字符列表 public RandomString(int length, Random random, String symbols) { if (length &lt; 1) throw new IllegalArgumentException(); if (symbols.length() &lt; 2) throw new IllegalArgumentException(); this.random = Objects.requireNonNull(random); this.symbols = symbols.toCharArray(); this.buf = new char[length]; } /** * Create an alphanumeric string generator. */ public RandomString(int length, Random random) { //该this方法是调用上面的RandomString构造方法 this(length, random, alphanum); } /** * Create an alphanumeric strings from a secure generator. */ public RandomString(int length) { this(length, new SecureRandom()); } /** * Create session identifiers. */ public RandomString() { this(21); } } 补充：java提供了一个生成随机文件名的包(java.util.UUID)，主要用于web中产生的一些文件。 import java.util.UUID; public class randomStringGenerator { public static void main(String[] args) { System.out.println(generateString()); } public static String generateString() { String uuid = UUID.randomUUID().toString(); return &quot;uuid = &quot; + uuid; } }]]></content>
      <categories>
        <category>StackOverflow</category>
      </categories>
      <tags>
        <tag>JAVA随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java随笔--断言、日志]]></title>
    <url>%2F2019%2F11%2F06%2Fjava%E9%9A%8F%E7%AC%94-%E6%96%AD%E8%A8%80%E3%80%81%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[断言断言机制允许在测试期间向代码中插入一些检查语句，当代码发布时，这些插入的检测语句会被自动地移走。Java语言引入了关键字assert，有两种形式： assert 条件; assert 条件:表达式; 这两种形式都会对条件进行检测， 如果结果为false, 则抛出一个AssertionError 异常。在第二种形式中，表达式将被传人AssertionError 的构造器， 并转换成一个消息字符串。 在默认情况下， 断言被禁用。可以在运行程序时启用断言，断言的启用和禁用不必重新编译程序。启用或禁用断言是类加载器( class loader ) 的功能。当断言被禁用时， 类加载器将跳过断言代码， 因此，不会降低程序运行的速度。 java -enableassertions MyApp不应该使用断言向程序的其他部分通告发生了可恢复性的错误， 或者，不应该作为程序向用户通告问题的手段。断言只应该用于在测试阶段确定程序内部的错误位置。 日志日志可以替换测试代码中使用的System.out.println()，不像输出语句测试完还需要删除。 //基本日志 Logger.getGlobal().info(&quot;File-&gt;OPen menu item selected&quot;); //如果在适当的地方（如main开始）调用，会取消所有日志 Logger.getGlobal().setLevel(Level.OFF); //高级日志（目前学习阶段用不到，以后需要再进行补充）]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JAVA随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java随笔--lambda表达式]]></title>
    <url>%2F2019%2F11%2F06%2Fjava%E9%9A%8F%E7%AC%94-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[lambda表达式lambda表达式形式：参数，箭头(-&gt;)以及一个表达式，也可以将操作放在代码块{}中。 (String first,String second)-&gt; { if(first.length()&gt;second.length()) return 1; else if(first.length()&lt;second.length()) return -1; else return 0; } () -&gt; System.out.pringln(&quot;i&quot;); 对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。这种接口称为函数式接口。Comparator 就是只有一个方法的接口， 所以可以提供一个lambda 表达式： 函数式接口中可以包含静态方法（已经实现了的方法），默认方法（default），java.lang.Object里的public方法。 Arrays.sort (words , (first , second) -&gt; first.length() - second.length()) ; 方法引用Timer t = new Timer(1000, event -&gt; System.out.println(event))； //等价于 Timer t = new Timer(1000, System.out::println); 表达式System.out::println是一个方法引用，等价于前面的lambda表达式。主要有3中形式： //System.out.println == x-&gt;System.out.println(x) object::instanceMethod //Math.pow(x,y) == (x,y)-&gt;Math.pow(x,y) Class::staticMethod //String::compareToIgnoreCase == (x,y)-&gt;x.compareToIgnoreCase(y) Class::instanceMethod]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JAVA随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java随笔--一些注意点和tricks]]></title>
    <url>%2F2019%2F11%2F05%2Fjava%E9%9A%8F%E7%AC%94-%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9%E5%92%8Ctricks%2F</url>
    <content type="text"><![CDATA[split()String类下的split()方法在根据正则表达式对字符串进行分割时会产生空字符串，在处理时需要进行判断。 //1、空字符串不会被解析 public class test { public static void main(String[] args) { String str = &quot;1,2,3,4,,,&quot;; String[] arr = str.split(&quot;,&quot;); for (String string : arr) { System.out.println(&quot;str&quot;+string); } System.out.println(arr.length); } } //输出：str1,str2,str3,str4 4 //2、最后一个分隔符被分的字符串不为空时，其余空字符串可被解析。 public class test { public static void main(String[] args) { String str = &quot;1,2,3,4,,,5&quot;; String[] arr = str.split(&quot;,&quot;); for (String string : arr) { System.out.println(&quot;str&quot;+string); } System.out.println(arr.length); } } //输出：str1,str2……str4,str,str,str5 7 //3、limit参数为整数时，只会截取前几个；为0时，正常截取； // 为负数时，即使是第一种情况，也会输出空字符串 String[] s = str.split(&quot;,&quot;,-1); s.equals(s1)判断字符串s是否等于s1，应该使用equals方法，不可以通过“==”进行判断。 HashSet如何检查重复当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals()方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。 所以Set中存储自己定义的对象时，需要重写hashCode()和equals()方法。 //Person类(name,age两个属性) //重写hashCode public int hashCode(){ final int prime = 31; int result = 1; result = prime * result + ((age == null) ? 0 : age.hashCode()); result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; } //重写equals public boolean equals(Person obj){ } hashCode方法如果重写equals()方法，就必须重新定义hashCode方法，以便用户可以将对象插入到散列表(自定义对象的HashMap)。hashCode 方法应该返回一个整型数值（也可以是负数)，并合理地组合实例域的散列码,以便能够让各个不同的对象产生的散列码更加均匀。下面是一个重写hashCode的例子。 public class Employee{ public int hashCode(){ return 7*name.hashCode() + 11*new Double(salary).hashCode() + 13*hireDay.hashCode(); } } //如果参数为null,安全起见使用下面的方法 public int hashCode(){ return 7*Objects.hashCode(name) + 11*Double.hashCode(salary) + 13*Objects.hashCode(hireDay); } //组合多个散列值时可以采用更好的方法 public int hashCode(){ return Objects.hash(name,salary,hireDay); } Equals与hashCode的定义必须一致：如果x.equals(y) 返回true, 那么x.hashCode( ) 就必须与y.hashCode( ) 具有相同的值。例如， 如果用定义的Employee.equals 比较雇员的ID， 那么hashCode 方法就需要散列ID，而不是雇员的姓名或存储地址。 静态导入import语句不仅可以导入类，还可以导入静态方法和静态域，如： import static java.lang.System.* //可以使用System类的静态方法和静态域，而不必加类名前缀 out.println(&quot;hello&quot;); //省略了System.out exit(0);]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JAVA随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java随笔--PriorityQueue]]></title>
    <url>%2F2019%2F10%2F30%2Fjava%E9%9A%8F%E7%AC%94-PriorityQueue%2F</url>
    <content type="text"><![CDATA[java的PriorityQueue是基于堆的优先队列。下面是其构造方法： //如果Collection已排序，则根据它的顺序进行排序 PriorityQueue(Collection&lt;? extends E&gt; c) //自定义一个比较器，根据比较器进行优先级判断 PriorityQueue(Comparator&lt;? super E&gt; comparator) 第二种构造方法使用的较多，比较器的创建可以使用匿名内部类的方法指定。通过重写Comparator的compare方法来实现。下面通过例子来解释： https://leetcode-cn.com/problems/top-k-frequent-elements/ public List&lt;Integer&gt; topKFrequent(int[] nums, int k) { List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); if(nums.length==1){ list.add(nums[0]); return list; } Map&lt;Integer,Integer&gt; hashmap=new HashMap&lt;Integer,Integer&gt;(); for(int i:nums){ if(!hashmap.containsKey(i)){ hashmap.put(i,1); }else{ int k1=hashmap.get(i)+1; hashmap.replace(i,k1); } } //new Comparator&lt;T&gt;() 实现接口的匿名内部类 //泛型不可以省略 PriorityQueue&lt;Integer&gt; queue=new PriorityQueue&lt;Integer&gt;(new Comparator&lt;Integer&gt;(){ /* public修饰符不可以省略 原因未知 这里是小根堆，使用自然排序（从小到大），当n1&gt;n2，返回1 */ public int compare(Integer n1,Integer n2){ if(hashmap.get(n1)&gt;hashmap.get(n2)) return 1; else if(hashmap.get(n1)==hashmap.get(n2)) return 0; else return -1; } }); for(Integer num:hashmap.keySet()){ queue.add(num); if(queue.size()&gt;k){ queue.poll(); } } while(queue.size()&gt;=1){ list.add(queue.poll()); } //逆转 Collections.reverse(list); return list; } //使用lambda表达式初始化 //(x, y) -&gt; x – y 接受2个参数(数字),并返回他们的差值 PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; hashmap.get(n1) - hashmap.get(n2));]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JAVA随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树]]></title>
    <url>%2F2019%2F10%2F19%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[https://leetcode-cn.com/problems/unique-binary-search-trees-ii/ 给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 递归：我们从序列 1 ..n 中取出数字 i，作为当前树的树根。于是，剩余 i - 1 个元素可用于左子树，n - i 个元素用于右子树。通过递归构建所有的子树。 public List&lt;TreeNode&gt; generateTrees(int n) { if(n==0) return new ArrayList&lt;TreeNode&gt;(); return createTree(1,n); } //每次递归应该返回可能的子树列表 List&lt;TreeNode&gt; createTree(int start,int end){ List&lt;TreeNode&gt; list=new ArrayList&lt;&gt;(); if(start&gt;end){ list.add(null); return list; } for(int i=start;i&lt;=end;i++){ List&lt;TreeNode&gt; leftList=createTree(start,i-1); List&lt;TreeNode&gt; rightList=createTree(i+1,end); //将左右子树连接 for(TreeNode left:leftList){ for(TreeNode right:rightList){ TreeNode root=new TreeNode(i); root.left=left; root.right=right; list.add(root); } } } return list; }]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java随笔--内部类]]></title>
    <url>%2F2019%2F10%2F19%2Fjava%E9%9A%8F%E7%AC%94-%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一、成员内部类​ 内部类可以用来实现多继承。成员内部类可以访问外部类的所有成员变量，包括private修饰的。 ​ 内部类跟外部类有一个很重要区别：内部类可以用private修饰，而外部类是不能使用private修饰的。如果内部类仅仅在类内部使用时，使用private修饰后，就可以更好的隐藏内部信息。 ​ 当需要使用到内部类的时候，还是推荐使用getInnerInstance的方式来获取，特别是当内部类只有无参构造器的时候 public class Outer { private int num; private Inner inner; Outer(){ num = 1; inner = new Inner(); } public void print(){ System.out.println(&quot;Outer.print()&quot;); System.out.println(inner.num); System.out.println(num); } //获取内部类对象 public Inner getInnerInstance() { return new Inner(); } class Inner{ private int num; Inner(){ num = 2; } public void print(){ System.out.println(&quot;Inner.print()&quot;); System.out.println(this.num); System.out.println(Outer.this.num); } } } public class Test { public static void main(String[] args) { Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); outer.print(); inner.print(); } } ​ 外部类访问内部类是先生成内部类实例，然后就能访问所有方法和属性，内部类访问外部类方法和属性则直接使用Outer.属性/方法名 即可。 二、局部内部类局部内部类就是定义在代码块、方法体内、作用域（使用花括号“{}”括起来的一段代码）内的类。局部内部类有以下特性： 局部内部类只能在代码代码块、方法体内和作用域中使用。 局部内部类同样可以无限制调用外部类的方法和属性。 可以使用abstract修饰，声明为抽象类。 public class Outer { public static final int TOTAL_NUMBER = 5; public int id = 123; public void func() { final int age = 15; String str = &quot;http://www.weixueyuan.net&quot;; class Inner { public void innerTest() { System.out.println(TOTAL_NUMBER); System.out.println(id); // System.out.println(str);不合法，只能访问本地方法的final变量 System.out.println(age); } } new Inner().innerTest(); } public static void main(String[] args) { Outer outer = new Outer(); outer.func(); } } 三、匿名内部类new 父类（参数列表）|实现接口（） { //匿名内部类的内部定义 } public class AnonymousTest { public static void main(String[] args) { new Thread(new Runnable() { public void run() { for (int i = 0; i &lt; 10; i++) { try { sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(i); } } }).start(); } } 这里创建了一个继承于Thread的匿名内部类，覆盖了其中的 run方法，并创建了一个实例返回给了t，然后再调用run方法，可以看到，匿名内部类只能存在一个实例对象，因为new过一次就无法再创建了。匿名内部类不仅可以继承于类，也可以实现于接口： public class AnonymousTest { public static void main(String[] args) { new Thread(new Runnable() { public void run() { …… }).start(); } } 当我们创建的类只需要一个实例的时候可以使用匿名内部类，比如说在多线程中，要使用多线程，一般先继承Thread类或者实现Runnable接口，然后再去调用它的方法，而每个任务一般都不一样，每次都新建一个类显然会很难管理，因为每个类只用一次就丢掉了，这个时候使用匿名内部类就很方便了，不仅不需要管理一堆一次性类，而且创建起来简单粗暴。 使用匿名内部类还是有很多限制的： 1、匿名内部类必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也 只能继承一个类或者实现一个接口。 2、匿名内部类不能定义构造函数。 3、匿名内部类中不能存在任何的静态成员变量和静态方法。 4、匿名内部类是特殊的局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。 5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。//通过初始化块来实现匿名内部类的初始化 //匿名内部类只能定义在方法等内部 public class AnonymousTest{ public static void main(String[] args){ Human human = new Human(){ private String name; { name=&quot;human&quot;; } @Override public void walk(){……} }; human.walk(); } } 注意，如果匿名内部类需要使用外部的参数或者变量，那么必须使用final修饰，因为内部类使用的其实是参数的拷贝，并不是参数本身，为了更明显的表明参数不可变，编译器会要求使用final关键字来修饰需要使用的变量。 public class AnonymousTest { public static void main(String[] args) { Human human = new AnonymousTest().getHumanInstance(&quot;Frank&quot;); human.walk(); } public Human getHumanInstance(final String name){ return new Human() { private String nameA; { nameA = name; } @Override public void walk() { System.out.println(nameA + &quot; walk.&quot;); } }; } } 四、静态内部类它的创建不依赖外部类，创建内部类的实例不需要像普通内部类一样先创建外部类实例才能创建。它不能无限制访问外部类的方法和成员变量，只能访问静态成员变量和静态方法。 public class Caculate { //定义一个pair类来将两个数捆绑 static class Pair{ private int first; private int second; public Pair(int first, int second) { this.first = first; this.second = second; } public int getFirst() { return first; } public int getSecond() { return second; } } //获取一个int数组中的最大和最小值 public static Pair getMaxMin(int[] values){ int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; for (int i:values){ if (min &gt; i) min = i; if (max &lt; i) max = i; } return new Pair(min,max); } public static void main(String[] args){ int[] list = {1,3,5,2,77,23,25}; Caculate.Pair pair = Caculate.getMaxMin(list); System.out.println(pair.getFirst()); System.out.println(pair.getSecond()); System.out.println(pair.first); System.out.println(pair.second); } }]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JAVA随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找细节详解]]></title>
    <url>%2F2019%2F10%2F17%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%BB%86%E8%8A%82%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1、基本二分查找//常见场景：查找一个数 int binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 注意 while(left &lt;= right) { int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; // 注意 else if (nums[mid] &gt; target) right = mid - 1; // 注意 } return -1; } 1、为什么 while 循环的条件中是 &lt;=，而不是 &lt; ？ 答：因为初始化 right 的赋值是 nums.length-1，即最后一个元素的索引，而不是 nums.length。这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。 我们这个算法中使用的是前者 [left, right] 两端都闭的区间。这个区间其实就是每次进行搜索的区间，我们不妨称为「搜索区间」。 2、寻找左侧边界的二分查找//对于注意点，主要从搜索区间和终止条件方面考虑 int left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left &lt; right) { // 注意 int mid = (left + right) / 2; if (nums[mid] == target) { right = mid; } else if (nums[mid] &lt; target) { left = mid + 1; } else if (nums[mid] &gt; target) { right = mid; // 注意 } } return left; } 1、为什么 left = mid + 1，right = mid ？和之前的算法不一样？ 答：因为我们的「搜索区间」是 [left, right) 左闭右开，所以当 nums[mid] 被检测之后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right)。（搜索区间格式不变） 2、为什么该算法能够搜索左侧边界？ 答：关键在于对于 nums[mid] == target 这种情况的处理：找到target值时不直接返回，而是缩小搜索上边界。 3、为什么返回 left 而不是 right？ 答：都是一样的，因为 while 终止的条件是 left == right。 3、寻找右侧边界的二分查找int right_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0, right = nums.length; while (left &lt; right) { int mid = (left + right) / 2; if (nums[mid] == target) { left = mid + 1; // 注意 } else if (nums[mid] &lt; target) { left = mid + 1; } else if (nums[mid] &gt; target) { right = mid; } } return left - 1; // 注意 } https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/ class Solution { public int[] searchRange(int[] nums, int target) { int[] index={-1,-1}; if(nums.length&lt;1) return index; int right,left; //左右边界 //寻找左侧边界 int low=0,high=nums.length; int mid; while(low&lt;high){ mid=(low+high)/2; if(nums[mid]==target){ high=mid; }else if(nums[mid]&gt;target){ high=mid; }else{ low=mid+1; } } //没有找到直接返回(比所有数都大或者最后的数不等于目标值) if(low==nums.length||nums[low]!=target) return index; left=low; //寻找右侧边界 low=0;high=nums.length; while(low&lt;high){ mid=(low+high)/2; if(nums[mid]==target){ low=mid+1; }else if(nums[mid]&gt;target){ high=mid; }else{ low=mid+1; } } right=low-1; index[0]=left;index[1]=right; return index; } }]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java随笔--对象的克隆]]></title>
    <url>%2F2019%2F10%2F17%2FJava%E9%9A%8F%E7%AC%94-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%8B%E9%9A%86%2F</url>
    <content type="text"><![CDATA[java的引用类型（包括类、接口、数组等复杂类型）是无法通过等号直接赋值的。 public class GoodsTest { public static void main(String[] args){ Goods goodsA = new Goods(&quot;GoodsA&quot;,20); Goods goodsB = goodsA; System.out.println(&quot;Before Change:&quot;); goodsA.print(); goodsB.print(); goodsB.setTitle(&quot;GoodsB&quot;); goodsB.setPrice(50); System.out.println(&quot;After Change:&quot;); goodsA.print(); goodsB.print(); } } //修改goodsB,goodsA也会发生变化，两个变量指向同一个地址 如果要实现对象的复制，需要重写clone方法，所有类都继承自Object类，该类有一个protected的clone方法。 //要使用克隆方法需要实现Cloneable接口 public class Goods implements Cloneable{ private String title; private double price; public Goods(String aTitle, double aPrice){ title = aTitle; price = aPrice; } //这里重载了接口的clone方法 @Override protected Object clone(){ Goods g = null; try{ //使用super来引用父类的成分，用this来引用当前对象 g = (Goods)super.clone(); }catch (CloneNotSupportedException e){ System.out.println(e.toString()); } return g; } 如果一个类的成员变量包含另一个类的对象，使用上述方法只能克隆该类的非引用类型，引用类型仍然指向同一个地址。解决这个问题需要使用深克隆（序列化、反序列化）。下面例子中Cart和Goods类都需要实现Serializable接口。 import java.io.*; public class Cart implements Serializable{ //实例域 Goods goodsList = new Goods(&quot;&quot;,0);//简单起见，这里只放了一个商品 double budget = 0.0;//预算 //构造函数 public Cart(double aBudget){ budget = aBudget; } public Object deepClone() throws IOException, OptionalDataException,ClassNotFoundException { // 将对象写到流里 ByteArrayOutputStream bo = new ByteArrayOutputStream(); ObjectOutputStream oo = new ObjectOutputStream(bo); oo.writeObject(this); // 从流里读出来 ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray()); ObjectInputStream oi = new ObjectInputStream(bi); return (oi.readObject()); } } public class Goods implements Serializable{……}]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JAVA随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合总数]]></title>
    <url>%2F2019%2F10%2F17%2F%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0%2F</url>
    <content type="text"><![CDATA[https://leetcode-cn.com/problems/combination-sum/solution/hui-shuo-suan-fa-di-gui-java-by-longchenghuang/ 总结：回溯主要是通过递归对所有情况进行遍历，通过剪枝降低复杂度。难点在于如何通过剪枝降低系统栈深度，降低时间复杂度？ 后面选取的数不能比前面选的数还要小，即 “更深层的边上的数值不能比它上层的边上的数值小”，本题通过这种方式降低复杂度。 List&lt;List&lt;Integer&gt;&gt; set=new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { //排序 Arrays.sort(candidates); List&lt;Integer&gt; list=new ArrayList&lt;Integer&gt;(); trace(0,list,candidates,target); return set; } public void trace(int index,List&lt;Integer&gt; list,int[] candidates,int tempTarget){ if(tempTarget==0) { //引用类型，需要创建新的对象 List&lt;Integer&gt; num=new ArrayList&lt;Integer&gt;(list); set.add(num); return; } if(index&gt;=candidates.length||tempTarget&lt;candidates[index]) return; //以index为起点，就是考虑了去重的问题，且考虑到了数字可以多次使用的条件 //通过这种方式，迭代会一直从同一个下标开始，直到不符合条件，下标加一， //对比i从零开始的情况 for(int i=index;i&lt;candidates.length;i++){ list.add(candidates[i]); trace(i,list,candidates,tempTarget-candidates[i]); //回溯的关键，进行同一层的下一步时，需要先删除这一层上一步的元素 list.remove(list.size()-1); } }]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电话号码的字母组合]]></title>
    <url>%2F2019%2F10%2F12%2F%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/ 思路：DFS、回溯（没有剪枝，解空间即为答案） 改进：字符串相加可以使用StringBuffer。 class Solution { //两个大括号的方式初始化(本质上是匿名内部类 + 实例化代码块儿) Map&lt;String,String&gt; hashMap=new HashMap&lt;String,String&gt;(){{ put("2","abc"); put("3","def"); put("4","ghi"); put("5","jkl"); put("6","mno"); put("7","pqrs"); put("8","tuv"); put("9","wxyz"); }}; public List&lt;String&gt; letterCombinations(String digits) { List&lt;String&gt; list=new ArrayList&lt;String&gt;(); if(digits.length()&lt;1||digits==null) return list; String str=String.valueOf(digits.charAt(0)); for(int i=0;i&lt;hashMap.get(str).length();i++){ String s=String.valueOf(hashMap.get(str).charAt(i)); backTrace(list,s,digits,1); } return list; } //dep为深度，这里指字符的索引;s为前面映射的字符串 public void backTrace(List&lt;String&gt; list,String s,String digits,int dep){ if(digits.length()==dep){ list.add(s); return; } String str=String.valueOf(digits.charAt(dep)); for(int i=0;i&lt;hashMap.get(str).length();i++){ String s1=s+String.valueOf(hashMap.get(str).charAt(i)); backTrace(list,s1,digits,dep+1); } } }]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长回文字符串]]></title>
    <url>%2F2019%2F10%2F11%2F%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[https://leetcode-cn.com/problems/longest-palindromic-substring/solution/ 方法一：中心扩展法 遍历字符串，以每个字符为中心，判断以其为中心的最长回文串长度。记录最长回文串的起始位置。注意回文串长度分奇偶两种情况。 class Solution { public String longestPalindrome(String s) { if(s==null||s.length()&lt;1) return s; //回文串左右位置 int left=0;int right=0; for(int i=0;i&lt;s.length();i++){ //回文串长度为奇数 int len1=lengthOfHuiwen(s,i,i); //长度为偶数 int len2=lengthOfHuiwen(s,i,i+1); int len=Math.max(len1,len2); if(len&gt;right-left){ left=i-(len+1)/2+1; right=i+len/2; } } return s.substring(left,right+1); } //left,right为中心字符串左右位置 public int lengthOfHuiwen(String s,int left,int right){ int L=left,R=right; while(L&gt;=0&amp;&amp;R&lt;s.length()&amp;&amp;s.charAt(L)==s.charAt(R)){ L--; R++; } return R-L-1; } } 方法二：动态规划 （一）状态 f[i][j]表示s的第 i 个字符到第 j 个字符组成的子串，是否为回文串 （二）转移方程 如果s的第 i 个字符和第 j 个字符相同的话，且 i + 1, 到 j - 1 的子串也是回文串的话，f[i][j] 也为回文串 f[i][j] = f[i + 1][j - 1] and s[i] == s[j] 稍微要注意的是，如果 i == j 或者 i + 1 == j 的时候，也就是单个字符的子串和两个相邻字符的子串，就不需要f[i + 1][j - 1]了 注意遍历顺序，i 从最后一个字符开始往前遍历，j 从 i 开始往后遍历，这样可以保证每个子问题都已经算好了。class Solution { public String longestPalindrome(String s) { int n=s.length(); if(n&lt;1||s==null) return s; String res=&quot;&quot;; boolean[][] flag=new boolean[n][n]; for(int i=n-1;i&gt;=0;i--){ for(int j=i;j&lt;n;j++){ if(s.charAt(i)==s.charAt(j)&amp;&amp;(j-i&lt;=1||flag[i+1][j-1])){ flag[i][j]=true; if(res.length()&lt;j-i+1) res=s.substring(i,j+1); } } } return res; } }]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC连接池& JDBCTemplate]]></title>
    <url>%2F2019%2F10%2F10%2FJDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[数据库连接池 概念：其实就是一个容器(集合)，存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处： 节约资源 用户访问高效 实现： 标准接口：DataSource javax.sql包下的 方法： 获取连接：getConnection() 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 一般我们不去实现它，有数据库厂商来实现 C3P0：数据库连接池技术 Druid：数据库连接池实现技术，由阿里巴巴提供的 C3P0：数据库连接池技术 步骤： 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， 不要忘记导入数据库驱动jar包 定义配置文件： 名称： c3p0.properties 或者 c3p0-config.xml 路径：直接将文件放在src目录下即可。 创建核心对象 数据库连接池对象 ComboPooledDataSource 获取连接： getConnection 代码： //1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); //2. 获取连接对象 Connection conn = ds.getConnection(); Druid：数据库连接池实现技术，由阿里巴巴提供的 步骤： 导入jar包 druid-1.0.9.jar 定义配置文件： 是properties形式的 可以叫任意名称，可以放在任意目录下 加载配置文件。Properties 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 获取连接：getConnection * 代码： //3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection(); 2. 定义工具类 1. 定义一个类 JDBCUtils 2. 提供静态代码块加载配置文件，初始化连接池对象 3. 提供方法 1. 获取连接方法：通过数据库连接池获取连接 2. 释放资源 3. 获取连接池的方法 * 代码： public class JDBCUtils { //1.定义成员变量 DataSource private static DataSource ds ; static{ try { //1.加载配置文件 Properties pro = new Properties(); pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); //2.获取DataSource ds = DruidDataSourceFactory.createDataSource(pro); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } } /** * 获取连接 */ public static Connection getConnection() throws SQLException { return ds.getConnection(); } /** * 释放资源 */ public static void close(Statement stmt,Connection conn){ /* if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } }*/ close(null,stmt,conn); } ​ public static void close(ResultSet rs , Statement stmt, Connection conn){ if(rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close();//归还连接 } catch (SQLException e) { e.printStackTrace(); } } } /** * 获取连接池方法 */ public static DataSource getDataSource(){ return ds; } } Spring JDBC Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 步骤： 导入jar包 创建JdbcTemplate对象。依赖于数据源DataSource JdbcTemplate template = new JdbcTemplate(ds); 调用JdbcTemplate的方法来完成CRUD的操作 update():执行DML语句。增、删、改语句 queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 注意：这个方法查询的结果集长度只能是1 queryForList():查询结果将结果集封装为list集合 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 query():查询结果，将结果封装为JavaBean对象 query的参数：RowMapper 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) queryForObject：查询结果，将结果封装为对象 一般用于聚合函数的查询 4. 练习： * 需求： 1. 修改1号数据的 salary 为 10000 2. 添加一条记录 3. 删除刚才添加的记录 4. 查询id为1的记录，将其封装为Map集合 5. 查询所有记录，将其封装为List 6. 查询所有记录，将其封装为Emp对象的List集合 7. 查询总记录数 * 代码： import cn.itcast.domain.Emp; import cn.itcast.utils.JDBCUtils; import org.junit.Test; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.jdbc.core.RowMapper; import java.sql.Date; import java.sql.ResultSet; import java.sql.SQLException; import java.util.List; import java.util.Map; public class JdbcTemplateDemo2 { //Junit单元测试，可以让方法独立执行 ​ //1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 1. 修改1号数据的 salary 为 10000 */ @Test public void test1(){ //2. 定义sql String sql = &quot;update emp set salary = 10000 where id = 1001&quot;; //3. 执行sql int count = template.update(sql); System.out.println(count); } /** * 2. 添加一条记录 */ @Test public void test2(){ String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;; int count = template.update(sql, 1015, &quot;郭靖&quot;, 10); System.out.println(count); } /** * 3.删除刚才添加的记录 */ @Test public void test3(){ String sql = &quot;delete from emp where id = ?&quot;; int count = template.update(sql, 1015); System.out.println(count); } /** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4(){ String sql = &quot;select * from emp where id = ? or id = ?&quot;; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20} } /** * 5. 查询所有记录，将其封装为List */ @Test public void test5(){ String sql = &quot;select * from emp&quot;; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) { System.out.println(stringObjectMap); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6(){ String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() { @Override public Emp mapRow(ResultSet rs, int i) throws SQLException { Emp emp = new Emp(); int id = rs.getInt(&quot;id&quot;); String ename = rs.getString(&quot;ename&quot;); int job_id = rs.getInt(&quot;job_id&quot;); int mgr = rs.getInt(&quot;mgr&quot;); Date joindate = rs.getDate(&quot;joindate&quot;); double salary = rs.getDouble(&quot;salary&quot;); double bonus = rs.getDouble(&quot;bonus&quot;); int dept_id = rs.getInt(&quot;dept_id&quot;); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; } }); ​ for (Emp emp : list) { System.out.println(emp); } } /** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2(){ String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) { System.out.println(emp); } } /** * 7. 查询总记录数 */ @Test public void test7(){ String sql = &quot;select count(id) from emp&quot;; Long total = template.queryForObject(sql, Long.class); System.out.println(total); } }]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC基础]]></title>
    <url>%2F2019%2F10%2F10%2FJDBC%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JDBC： 概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库 JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 快速入门： 步骤： 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 2.右键–&gt;Add As Library 注册驱动 获取数据库连接对象 Connection 定义sql 获取执行sql语句的对象 Statement 执行sql，接受返回结果 处理结果 释放资源 {r tidy=FALSE} * 代码实现： //1. 导入驱动jar包 //2.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;); //4.定义sql语句 String sql = &quot;update account set balance = 500 where id = 1&quot;; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close(); 3. 详解各个对象： 1. DriverManager：驱动管理对象 * 功能： 1. 注册驱动：告诉程序该使用哪一个数据库驱动jar static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 写代码使用： Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(&quot;Can&#39;t register driver!&quot;); } } 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 2. 获取数据库连接： * 方法：static Connection getConnection(String url, String user, String password) * 参数： * url：指定连接的路径 * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 * 例子：jdbc:mysql://localhost:3306/db3 * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称 * user：用户名 * password：密码 2. Connection：数据库连接对象 1. 功能： 1. 获取执行sql 的对象 * Statement createStatement() * PreparedStatement prepareStatement(String sql) 2. 管理事务： * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 * 提交事务：commit() * 回滚事务：rollback() 3. Statement：执行sql的对象 1. 执行sql 1. boolean execute(String sql) ：可以执行任意的sql 了解 2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 3. ResultSet executeQuery(String sql) ：执行DQL（select)语句 2. 练习： 1. account表 添加一条记录 2. account表 修改记录 3. account表 删除一条记录 代码： Statement stmt = null; Connection conn = null; try { //1. 注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 定义sql String sql = &quot;insert into account values(null,&#39;王五&#39;,3000)&quot;; //3.获取Connection对象 conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;); //4.获取执行sql的对象 Statement stmt = conn.createStatement(); //5.执行sql int count = stmt.executeUpdate(sql);//影响的行数 //6.处理结果 System.out.println(count); if(count &gt; 0){ System.out.println(&quot;添加成功！&quot;); }else{ System.out.println(&quot;添加失败！&quot;); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); }finally { //stmt.close(); //7. 释放资源 //避免空指针异常 if(stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if(conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } 4. ResultSet：结果集对象,封装查询结果 * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true * getXxx(参数):获取数据 * Xxx：代表数据类型 如： int getInt() , String getString() * 参数： 1. int：代表列的编号,从1开始 如： getString(1) 2. String：代表列名称。 如： getDouble(&quot;balance&quot;) * 注意： * 使用步骤： 1. 游标向下移动一行 2. 判断是否有数据 3. 获取数据 //循环判断游标是否是最后一行末尾。 while(rs.next()){ //获取数据 //6.2 获取数据 int id = rs.getInt(1); String name = rs.getString(&quot;name&quot;); double balance = rs.getDouble(3); System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance); } * 练习： * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。 1. 定义Emp类 2. 定义方法 public List&lt;Emp&gt; findAll(){} 3. 实现方法 select * from emp; PreparedStatement：执行sql SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 输入用户随便，输入密码：’a’ or ‘a’ = ‘a’ sql：select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’ 解决sql注入问题：使用PreparedStatement对象来解决 预编译的SQL：参数使用?作为占位符 步骤： 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 注册驱动 获取数据库连接对象 Connection 定义sql 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?; 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 给？赋值： 方法： setXxx(参数1,参数2)* 参数1：？的位置编号 从1 开始 * 参数2：？的值 执行sql，接受返回结果，不需要传递sql语句 处理结果 释放资源 注意：后期都会使用PreparedStatement来完成增删改查的所有操作 可以防止SQL注入 效率更高 抽取JDBC工具类 ： JDBCUtils 目的：简化书写 分析： 注册驱动也抽取 抽取一个方法获取连接对象 需求：不想传递参数（麻烦），还得保证工具类的通用性。 解决：配置文件 jdbc.properties url= user= password= 抽取一个方法释放资源 * 代码实现： public class JDBCUtils { private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块 */ static{ //读取资源文件，获取值。 try { //1. 创建Properties集合类。 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(&quot;jdbc.properties&quot;); String path = res.getPath(); System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties //2. 加载文件 // pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;)); pro.load(new FileReader(path)); //3. 获取数据，赋值 url = pro.getProperty(&quot;url&quot;); user = pro.getProperty(&quot;user&quot;); password = pro.getProperty(&quot;password&quot;); driver = pro.getProperty(&quot;driver&quot;); //4. 注册驱动 Class.forName(driver); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } ​ /** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException { return DriverManager.getConnection(url, user, password); } /** * 释放资源 * @param stmt * @param conn */ public static void close(Statement stmt,Connection conn){ if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } ​ /** * 释放资源 * @param stmt * @param conn */ public static void close(ResultSet rs,Statement stmt, Connection conn){ if( rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if( stmt != null){ try { stmt.close(); } catch (SQLException e) { e.printStackTrace(); } } if( conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } * 练习： * 需求： 1. 通过键盘录入用户名和密码 2. 判断用户是否登录成功 * select * from user where username = &quot;&quot; and password = &quot;&quot;; * 如果这个sql有查询结果，则成功，反之，则失败 * 步骤： 1. 创建数据库表 user CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32), PASSWORD VARCHAR(32) ); INSERT INTO USER VALUES(NULL,&#39;zhangsan&#39;,&#39;123&#39;); INSERT INTO USER VALUES(NULL,&#39;lisi&#39;,&#39;234&#39;); 2. 代码实现： public class JDBCDemo9 { public static void main(String[] args) { //1.键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入用户名：&quot;); String username = sc.nextLine(); System.out.println(&quot;请输入密码：&quot;); String password = sc.nextLine(); //2.调用方法 boolean flag = new JDBCDemo9().login(username, password); //3.判断结果，输出不同语句 if(flag){ //登录成功 System.out.println(&quot;登录成功！&quot;); }else{ System.out.println(&quot;用户名或密码错误！&quot;); } } /** * 登录方法 */ public boolean login(String username ,String password){ if(username == null || password == null){ return false; } //连接数据库判断是否登录成功 Connection conn = null; Statement stmt = null; ResultSet rs = null; //1.获取连接 try { conn = JDBCUtils.getConnection(); //2.定义sql String sql = &quot;select * from user where username = &#39;&quot;+username+&quot;&#39; and password = &#39;&quot;+password+&quot;&#39; &quot;; //3.获取执行sql的对象 stmt = conn.createStatement(); //4.执行查询 rs = stmt.executeQuery(sql); //5.判断 /* if(rs.next()){//如果有下一行，则返回true return true; }else{ return false; }*/ return rs.next();//如果有下一行，则返回true } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtils.close(rs,stmt,conn); } return false; } } ​ JDBC控制事务： 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 操作： 开启事务 提交事务 回滚事务 使用Connection对象来管理事务 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 在执行sql之前开启事务 提交事务：commit() 当所有sql都执行完提交事务 回滚事务：rollback() 在catch中回滚事务 4. 代码： public class JDBCDemo10 { public static void main(String[] args) { Connection conn = null; PreparedStatement pstmt1 = null; PreparedStatement pstmt2 = null; try { //1.获取连接 conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); //2.定义sql //2.1 张三 - 500 String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;; //2.2 李四 + 500 String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;; //3.获取执行sql对象 pstmt1 = conn.prepareStatement(sql1); pstmt2 = conn.prepareStatement(sql2); //4. 设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); //5.执行sql pstmt1.executeUpdate(); // 手动制造异常 int i = 3/0; pstmt2.executeUpdate(); //提交事务 conn.commit(); } catch (Exception e) { //事务回滚 try { if(conn != null) { conn.rollback(); } } catch (SQLException e1) { e1.printStackTrace(); } e.printStackTrace(); }finally { JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); } } } ​ ​]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go(三)]]></title>
    <url>%2F2019%2F10%2F03%2FGo-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[复合数据类型3.1 数组var a [3]int var q [3]int = [3]int{1, 2, 3} q := [...]int{1, 2, 3} //长度由初始化值的个数来计算 months := [...]string{1: &quot;January&quot;, /* ... */, 12: &quot;December&quot;} //索引0自动初始化为空字符串 数组类型可以直接比较（==），只有当两个数组所有元素都是相等的时候数组才是相等的。 3.2 Slice一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。 slice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。 slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较： func equal(x, y []string) bool { if len(x) != len(y) { return false } for i := range x { if x[i] != y[i] { return false } } return true } slice唯一合法的比较操作是和nil比较，内置的make函数创建一个指定元素类型、长度和容量的slice。 var s []int // len(s) == 0, s == nil s = nil // len(s) == 0, s == nil s = []int(nil) // len(s) == 0, s == nil s = []int{} // len(s) == 0, s != nil make([]T, len) //返回整个数组 make([]T, len, cap) // same as make([]T, cap)[:len] 3.3 append函数内置的append函数用于向slice追加元素 var runes []rune for _, r := range &quot;Hello, 世界&quot; { runes = append(runes, r) } fmt.Printf(&quot;%q\n&quot;, runes) // &quot;[&#39;H&#39; &#39;e&#39; &#39;l&#39; &#39;l&#39; &#39;o&#39; &#39;,&#39; &#39; &#39; &#39;世&#39; &#39;界&#39;]&quot; copy函数可以方便地将一个slice复制另一个相同类型的slice。copy函数的第一个参数是要复制的目标slice，第二个参数是源slice。copy(z, x) var x []int x = append(x, 1) x = append(x, 2, 3) x = append(x, 4, 5, 6) x = append(x, x...) // append the slice x 一个slice可以用来模拟一个stack。最初给定的空slice对应一个空的stack，然后可以使用append函数将新的值压入stack： stack = append(stack, v) // push v top := stack[len(stack)-1] // top of stack stack = stack[:len(stack)-1] // pop 要删除slice中间的某个元素并保存原有的元素顺序，可以通过内置的copy函数将后面的子slice向前依次移动一位完成： func remove(slice []int, i int) []int { copy(slice[i:], slice[i+1:]) return slice[:len(slice)-1] } func main() { s := []int{5, 6, 7, 8, 9} fmt.Println(remove(s, 2)) // &quot;[5 6 8 9]&quot; } 3.4 Map在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。 ages := make(map[string]int) // mapping from strings to ints ages := map[string]int{ &quot;alice&quot;: 31, &quot;charlie&quot;: 34, } //创建空的map map[string]int{} //使用内置的delete函数可以删除元素 delete(ages, &quot;alice&quot;) // remove element ages[&quot;alice&quot;] map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作，原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。 _ = &amp;ages[&quot;bob&quot;] // compile error: cannot take address of map element 遍历map for name, age := range ages { fmt.Printf(&quot;%s\t%d\n&quot;, name, age) } Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。如果要按顺序遍历key/value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序。 import &quot;sort&quot; var names []string for name := range ages { names = append(names, name) } sort.Strings(names) for _, name := range names { fmt.Printf(&quot;%s\t%d\n&quot;, name, ages[name]) } age, ok := ages[&quot;bob&quot;] //在这种场景下，map的下标语法将产生两个值；第二个是一个布尔值， //用于报告元素是否真的存在。布尔变量一般命名为ok，特别适合马上用于if条件判断部分。 Go语言没有提供set类型，可以用map实现set类型， func main() { seen := make(map[string]bool) // a set of strings input := bufio.NewScanner(os.Stdin) for input.Scan() { line := input.Text() if !seen[line] { seen[line] = true fmt.Println(line) } } if err := input.Err(); err != nil { fmt.Fprintf(os.Stderr, &quot;dedup: %v\n&quot;, err) os.Exit(1) } } 3.5 结构体type Employee struct { ID int Name string Address string DoB time.Time } var dilbert Employee 结构体变量的成员可以通过点操作符访问，比如dilbert.Name和dilbert.DoB。赋值可以直接进行或者通过指针： name := &amp;dilbert.Name *name = &quot;Robin&quot; 点操作符也可以和指向结构体的指针一起工作： var employeeOfTheMonth *Employee = &amp;dilbert employeeOfTheMonth.Position += &quot; (proactive team player)&quot; //上面语句等价于 (*employeeOfTheMonth).Position += &quot; (proactive team player)&quot; 结构体成员的输入顺序也有重要的意义。交换Name和Address出现的先后顺序，那样的话就是定义了不同的结构体类型。如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个命名为S的结构体类型将不能再包含S类型的成员，但是S类型的结构体可以包含*S指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。 3.5.1 结构体字面值type Point struct{ X, Y int } p := Point{1, 2} q := Point{X:1,Y:2} 上面第一种写法，要求以结构体成员定义的顺序为每个结构体成员指定一个字面值。这个方法一般只在定义结构体的包内部使用，或者是在较小的结构体中使用。第二种方法是以成员名字和相应的值来初始化。结构体通常通过指针处理，可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址： pp := &amp;Point{1, 2} //等价于 pp := new(Point) *pp = Point{1, 2} 3.5.2 结构体比较如果结构体的全部成员都是可以比较的，那么这个结构体也是可以比较的，可以通过==或!=运算符进行比较。 type Point struct{ X, Y int } p := Point{1, 2} q := Point{2, 1} fmt.Println(p.X == q.X &amp;&amp; p.Y == q.Y) // &quot;false&quot; fmt.Println(p == q) // &quot;false&quot; 可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型。 type address struct { hostname string port int } hits := make(map[address]int) hits[address{&quot;golang.org&quot;, 443}]++ 3.5.3 结构体嵌入和匿名变量type Point struct { X, Y int } type Circle struct { Center Point Radius int } type Wheel struct { Circle Circle Spokes int } var w Wheel w.Circle.Center.X = 8 w.Circle.Center.Y = 8 w.Circle.Radius = 5 w.Spokes = 20 Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。得意于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径： type Circle struct { Point Radius int } type Wheel struct { Circle Spokes int } var w Wheel w.X = 8 // equivalent to w.Circle.Point.X = 8 w.Y = 8 // equivalent to w.Circle.Point.Y = 8 w.Radius = 5 // equivalent to w.Circle.Radius = 5 w.Spokes = 20 //匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。 结构体字面值没有简短表示匿名成员的语法，所以必须遵循形状类型声明时的结构，按照以下方式赋值： w = Wheel{Circle{Point{8, 8}, 5}, 20} w = Wheel{ Circle: Circle{ Point: Point{X: 8, Y: 8}, Radius: 5, }, Spokes: 20, // NOTE: trailing comma necessary here (and at Radius) } 因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。同时，因为成员的名字是由其类型隐式地决定的，所有匿名成员也有可见性的规则约束。在上面的例子中，Point和Circle匿名成员都是导出的。即使它们不导出（比如改成小写字母开头的point和circle），我们依然可以用简短形式访问匿名成员嵌套的成员，但是在包外部，这是不允许的。 w.X = 8 // equivalent to w.circle.point.X = 8 3.6 JSON(encoding/json包)type Movie struct { Title string Year int `json:&quot;released&quot;` Color bool `json:&quot;color,omitempty&quot;` Actors []string } var movies = []Movie{ {Title: &quot;Casablanca&quot;, Year: 1942, Color: false, Actors: []string{&quot;Humphrey Bogart&quot;, &quot;Ingrid Bergman&quot;}}, {Title: &quot;Cool Hand Luke&quot;, Year: 1967, Color: true, Actors: []string{&quot;Paul Newman&quot;}}, {Title: &quot;Bullitt&quot;, Year: 1968, Color: true, Actors: []string{&quot;Steve McQueen&quot;, &quot;Jacqueline Bisset&quot;}}, // ... } 结构体声明中，Year和Color成员后面的字符串面值是结构体成员的Tag。将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）。编组通过调用json.Marshal函数完成： data, err := json.Marshal(movies) if err != nil { log.Fatalf(&quot;JSON marshaling failed: %s&quot;, err) } fmt.Printf(&quot;%s\n&quot;, data) Marshal函数返还一个编码后的字节slice，包含很长的字符串，并且没有空白缩进。这种紧凑的表示形式虽然包含了全部的信息，但是很难阅读。为了生成便于阅读的格式，另一个json.MarshalIndent函数将产生整齐缩进的输出。该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进。 data, err := json.MarshalIndent(movies, &quot;&quot;, &quot; &quot;) if err != nil { log.Fatalf(&quot;JSON marshaling failed: %s&quot;, err) } fmt.Printf(&quot;%s\n&quot;, data) //输出格式 [ { &quot;Title&quot;: &quot;Casablanca&quot;, &quot;released&quot;: 1942, &quot;Actors&quot;: [ &quot;Humphrey Bogart&quot;, &quot;Ingrid Bergman&quot; ] }, ……………… 其中Year名字的成员在编码后变成了released，还有Color成员编码后变成了小写字母开头的color。这是因为构体成员Tag所导致的。结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:”value”键值对序列；因为值中含义双引号字符，因此成员Tag一般用原生字符串面值的形式书写。json开头键名对应的值用于控制encoding/json包的编码和解码的行为，并且encoding/…下面其它的包也遵循这个约定。成员Tag中json对应值的第一部分用于指定JSON对象的名字，Color成员的Tag还带了一个额外的omitempty选项，表示当Go语言结构体成员为空或零值时不生成JSON对象，如Casablanca的color成员变量值为false（零值），所以没有输出color成员。 解码操作是将JSON数据解码成Go语言的数据结构，通过json.Unmarshal函数完成。下面的代码将JSON格式的电影数据解码为一个结构体slice，结构体中只有Title成员。通过定义合适的Go语言数据结构，我们可以选择性地解码JSON中感兴趣的成员。当Unmarshal函数调用返回，slice将被只含有Title信息值填充，其它JSON成员将被忽略。 var titles []struct{ Title string } if err := json.Unmarshal(data, &amp;titles); err != nil { log.Fatalf(&quot;JSON unmarshaling failed: %s&quot;, err) } fmt.Println(titles) // &quot;[{Casablanca} {Cool Hand Luke} {Bullitt}]&quot; 3.7 文本和HTML模板text\template和html\template提供了一个将变量值填充到文本或HTML格式的模板的机制。 一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的对象。大部分的字符串只是按字面值打印，但是对于actions部分将触发其它的行为。下面是一个简短的模板字符串。 const templ = `{{.TotalCount}} issues: {{range .Items}}---------------------------------------- Number: {{.Number}} User: {{.User.Login}} Title: {{.Title | printf "%.64s"}} Age: {{.CreatedAt | daysAgo}} days {{end}}` 对于每一个action，都有一个当前值的概念，对应点操作符，写作“.”。模板中{{.TotalCount}}对应action将展开为结构体中TotalCount成员以默认的方式打印的值。模板中{{range .Items}}和{{end}}对应一个循环action，因此它们直接的内容可能会被展开多次，循环每次迭代的当前值对应当前的Items元素的值。在一个action中，|操作符表示将前一个表达式的结果作为后一个函数的输入，在Title这一行的action中，第二个操作是一个printf函数，是一个基于fmt.Sprintf实现的内置函数，所有模板都可以直接使用。 生成模板：template.New先创建并返回一个模板；Funcs方法将daysAgo等自定义函数注册到模板中，并返回模板；最后调用Parse函数分析模板。 report, err := template.New(&quot;report&quot;). Funcs(template.FuncMap{&quot;daysAgo&quot;: daysAgo}). Parse(templ) if err != nil { log.Fatal(err) } https://books.studygolang.com/gopl-zh/ch4/ch4-06.html]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go(四)]]></title>
    <url>%2F2019%2F10%2F01%2FGo-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[函数4.1 函数声明函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。 func name(parameter-list) (result-list) { body } 如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。 func f(i, j, k int, s, t string) { /* ... */ } func f(i int, j int, k int, s string, t string) { /* ... */ } func add(x int, y int) int {return x + y} func sub(x, y int) (z int) { z = x - y; return} func first(x int, _ int) int { return x } func zero(int, int) int { return 0 } fmt.Printf(&quot;%T\n&quot;, add) // &quot;func(int, int) int&quot; fmt.Printf(&quot;%T\n&quot;, sub) // &quot;func(int, int) int&quot; fmt.Printf(&quot;%T\n&quot;, first) // &quot;func(int, int) int&quot; fmt.Printf(&quot;%T\n&quot;, zero) // &quot;func(int, int) int&quot; 在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。 遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数标识符。 func Sin(x float64) float //implemented in assembly language 4.2 递归Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题。 4.3 多返回值在Go中，一个函数可以返回多个值。我们已经在之前例子中看到，许多标准库中的函数返回2个值，一个是期望得到的返回值，另一个是函数出错时的错误信息。 调用多返回值函数时，返回给调用者的是一组值，调用者必须显式的将这些值分配给变量: links, err := findLinks(url) links, _ := findLinks(url) // errors ignored 当你调用接受多参数的函数时，可以将一个返回多参数的函数作为该函数的参数。虽然这很少出现在实际生产代码中，但这个特性在debug时很方便，我们只需要一条语句就可以输出所有的返回值。下面的代码是等价的。 log.Println(findLinks(url)) links, err := findLinks(url) log.Println(links, err) 如果一个函数所有的返回值都显示变量名，那么该函数的return语句可以省略操作数，称之为base return。 func Count(num1,num2 int) (count1,count2 int,err error){ count1,count2:=num1,num2 err:=nil return } 4.4 文件结尾错误EOFio包保证任何由文件结束引起的读取失败都返回同一个错误io.EOF，该错误在io包中定义： package io import &quot;errors&quot; // EOF is the error returned by Read when no more input is available. var EOF = errors.New(&quot;EOF&quot;) 调用者只需通过简单的比较，就可以检测出这个错误。 in := bufio.NewReader(os.Stdin) for { r, _, err := in.ReadRune() if err == io.EOF { break // finished reading } if err != nil { return fmt.Errorf(&quot;read failed:%v&quot;, err) } } 4.5 函数值在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。 func square(n int) int { return n * n } f := square fmt.Println(f(3)) // &quot;9&quot; 函数类型的零值是nil。调用值为nil的函数值会引起panic错误。函数可以和nil比较，但是函数之间是不可以比较的，不可以作为map的key。 函数值作为函数的参数，下面strings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者。 func add1(r rune) rune { return r + 1 } //String.Map函数定义 //func Map(mapping func(rune) rune, s string) string fmt.Println(strings.Map(add1, &quot;HAL-9000&quot;)) // &quot;IBM.:111&quot; 4.6 匿名函数函数值字面量是一种表达式，它的值被成为匿名函数（anonymous function）。函数字面量允许我们在使用函数时，再定义它。 strings.Map(func(r rune) rune { return r + 1 }, &quot;HAL-9000&quot;) 更为重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量： func squares() func() int { var x int return func() int { x++ return x * x } } func main() { f := squares() fmt.Println(f()) // &quot;1&quot; fmt.Println(f()) // &quot;4&quot; fmt.Println(f()) // &quot;9&quot; fmt.Println(f()) // &quot;16&quot; } squares的例子证明，函数值不仅仅是一串代码，还记录了状态，其中的变量生命周期不由它的作用域决定。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。 当匿名函数需要被递归调用时，我们必须首先声明一个变量，再将匿名函数赋值给这个变量。 visitAll := func(items []string) { // ... visitAll(m[item]) // compile error: undefined: visitAll // ... } 4.7 捕获迭代变量var rmdirs []func() for _, dir := range tempDirs() { os.MkdirAll(dir, 0755) rmdirs = append(rmdirs, func() { os.RemoveAll(dir) // NOTE: incorrect! }) } for _, rmdir := range rmdirs { rmdir() // clean up } 上面代码是错误的，在该循环中生成的所有函数值都共享相同的循环变量，需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。所以后续的迭代会不断更新dir的值，当删除操作执行时，for循环已完成，dir中存储的值等于最后一次迭代的值。 通常，为了解决这个问题，我们会引入一个与循环变量同名的局部变量，作为循环变量的副本。 for _, dir := range tempDirs() { dir := dir // declares inner dir, initialized to outer dir // ... } 4.8 可变参数参数数量可变的函数称为为可变参数函数。在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“…”，这表示该函数会接收任意数量的该类型参数。 func sum(vals...int) int { total := 0 for _, val := range vals { total += val } return total } fmt.Println(sum()) // &quot;0&quot; fmt.Println(sum(3)) // &quot;3&quot; fmt.Println(sum(1, 2, 3, 4)) // &quot;10&quot; 在上面的代码中，调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调函数。如果原始参数已经是切片类型，只需在最后一个参数后加上省略符。 values := []int{1, 2, 3, 4} fmt.Println(sum(values...)) // &quot;10&quot; 4.9 Deferred函数在普通函数或方法前加上关键字defer，这时当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行。可以在一个函数中执行多条defer语句，他们执行顺序与声明顺序相反，类似于栈。 defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。 defer后的函数会在return或者异常后执行，可以用来记录函数返回值。同样可以避免函数出现异常返回，导致文件没有关闭，或者简化代码。 func CopyFile(dstName, srcName string) (written int64, err error) { src, err := os.Open(srcName) if err != nil { return } defer src.Close() dst, err := os.Create(dstName) if err != nil { return } defer dst.Close() return io.Copy(dst, src) }]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go(二)]]></title>
    <url>%2F2019%2F09%2F26%2FGo-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[基础数据类型2.1 整形* / % &lt;&lt; &gt;&gt; &amp; &amp;^ + - | ^ == != &lt; &lt;= &gt; &gt;= &amp;&amp; || 二元运算符有五种优先级。在同一个优先级，使用左优先结合规则，但是使用括号可以明确优先顺序，使用括号也可以用于提升优先级。在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此-5%3和-5%-3结果都是-2。除法运算符/的行为则依赖于操作数是否为全为整数，比如5.0/4.0的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。 &amp; 位运算 AND | 位运算 OR ^ 位运算 XOR &amp;^ 位清空 (AND NOT) &lt;&lt; 左移 &gt;&gt; 右移 位操作运算符^作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反；位操作运算符&amp;^用于按位置零（AND NOT）：如果对应y中bit位为1的话, 表达式z = x &amp;^ y结果z的对应的bit位为0，否则z对应的bit位等于x相应的bit位的值。 任何大小的整数字面值都可以用以0开始的八进制格式书写，例如0666；或用以0x或0X开头的十六进制格式书写，例如0xdeadbeef。十六进制数字可以用大写或小写字母。 o := 0666 fmt.Printf(&quot;%d %[1]o %#[1]o\n&quot;, o) // &quot;438 666 0666&quot; x := int64(0xdeadbeef) fmt.Printf(&quot;%d %[1]x %#[1]x %#[1]X\n&quot;, x) // Output: // 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF 通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的[1]副词告诉Printf函数再次使用第一个操作数。第二，%后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。字符使用%c参数打印，或者是用%q参数打印带单引号的字符。 2.2 浮点数float32、float64 很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分。 const Avogadro = 6.02214129e23 // 阿伏伽德罗常数 用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。所有的这三个打印形式都可以指定打印的宽度和控制打印精度。 for x := 0; x &lt; 8; x++ { fmt.Printf(&quot;x = %d e^x = %8.3f\n&quot;, x, math.Exp(float64(x))) } x = 5 e^x = 148.413 x = 6 e^x = 403.429 x = 7 e^x = 1096.633 math包中有定义的特殊值：+Inf、-Inf、NAN（正负无穷，非数）。函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。 nan := math.NaN() fmt.Println(nan == nan, nan &lt; nan, nan &gt; nan) // &quot;false false false&quot; 2.3 复数Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部： var x complex128 = complex(1, 2) // 1+2i var y complex128 = complex(3, 4) // 3+4i fmt.Println(x*y) // &quot;(-5+10i)&quot; fmt.Println(real(x*y)) // &quot;-5&quot; fmt.Println(imag(x*y)) // &quot;10&quot; math/cmplx包提供了复数处理的许多函数，例如求复数的平方根函数和求幂函数。 2.4 布尔值布尔值可以和&amp;&amp;（AND）和||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值。 &amp;&amp;的优先级比||高 布尔值并不会隐式转换为数字值0或1，反之亦然。 2.5 字符串支持切片，‘+’链接字符串，字符串是不可修改的，尝试修改字符串内部的字符是禁止的。 原生字符串使用反引号代替双引号，原生的字符串字面量多用于书写多行消息、HTML以及正则表达式。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行。 const GoUsage = `Go is a tool for managing Go source code. Usage: go command [arguments] ...` strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。 //strings包 func Contains(s, substr string) bool func Count(s, sep string) int func Fields(s string) []string func HasPrefix(s, prefix string) bool func Index(s, sep string) int func Join(a []string, sep string) string //bytes包 func Contains(b, subslice []byte) bool func Count(s, sep []byte) int func Fields(s []byte) [][]byte func HasPrefix(s, prefix []byte) bool func Index(s, sep []byte) int func Join(s [][]byte, sep []byte) []byte bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效的： var buf bytes.Buffer buf.WriteByte(&#39;[&#39;) buf.WriteRune(&#39;中&#39;) buf.WriteString(&quot;, d &quot;) strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。 2.6 UTF-8UTF8编码使用1到4个字节来表示每个Unicode码点，ASCII部分字符只使用1个字节，常用字符部分使用2或3个字节表示。如果第一个字节的高端bit为0，则表示对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统的ASCII编码兼容。如果第一个字节的高端bit是110，则说明需要2个字节；后续的每个高端bit都以10开头。 0xxxxxxx runes 0-127 (ASCII) 110xxxxx 10xxxxxx 128-2047 (values &lt;128 unused) 1110xxxx 10xxxxxx 10xxxxxx 2048-65535 (values &lt;2048 unused) 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 65536-0x10ffff (other values unused) //Unicode转义字符让我们可以通过Unicode码点输入特殊的字符。下面是相同的字符串 &quot;世界&quot; &quot;\xe4\xb8\x96\xe7\x95\x8c&quot; &quot;\u4e16\u754c&quot; &quot;\U00004e16\U0000754c&quot; import &quot;unicode/utf8&quot; s := &quot;Hello, 世界&quot; fmt.Println(len(s)) // &quot;13&quot; fmt.Println(utf8.RuneCountInString(s)) // &quot;9&quot; Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串。 如果是将一个[]rune类型的Unicode字符slice或数组转为string，则对它们进行UTF8编码： s := &quot;プログラム&quot; fmt.Printf(&quot;% x\n&quot;, s) // &quot;e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0&quot; r := []rune(s) fmt.Printf(&quot;%x\n&quot;, r) // &quot;[30d7 30ed 30b0 30e9 30e0]&quot; fmt.Println(string(r)) // &quot;プログラム&quot; fmt.Println(string(65)) // &quot;A&quot;, not &quot;65&quot; fmt.Println(string(0x4eac)) // &quot;京&quot; fmt.Println(string(1234567)) // &quot;�&quot;（无效字符） fmt.Println(rune(&#39;你&#39;))//输出20320 rune在golang中是int32的别名，在各个方面都与int32相同。可以将rune理解为一个可以表示Unicode编码的int值，称为码点。参考java中的char类型（可以和int运算）。 在Go中，双引号是用来表示字符串string，本质是[]byte类型，单引号表示rune类型。 2.7 字符串和数字的转换将一个整数转为字符串，一种方法是用fmt.Sprintf返回一个格式化的字符串；另一个方法是用strconv.Itoa(“整数到ASCII”)： x := 123 y := fmt.Sprintf(&quot;%d&quot;, x) fmt.Println(y, strconv.Itoa(x)) // &quot;123 123&quot; FormatInt和FormatUint函数可以用不同的进制来格式化数字： fmt.Println(strconv.FormatInt(int64(x), 2)) // &quot;1111011&quot; fmt.Sprintf函数的%b、%d、%o和%x等参数提供功能往往比strconv包的Format函数方便很多，特别是在需要包含附加额外信息的时候： s := fmt.Sprintf(&quot;x=%b&quot;, x) // &quot;x=1111011&quot; 如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数： x, err := strconv.Atoi(&quot;123&quot;) // x is an int y, err := strconv.ParseInt(&quot;123&quot;, 10, 64) // base 10, up to 64 bits func ParseInt(s string, base int, bitSize int) (i int64, err error) ParseInt函数的第三个参数是用于指定返回整型数的大小；例如16表示int16，0则表示int。第二个参数为数字字符串的进制。 int随系统而定，32位系统为int32 2.8 常量批量声明 const ( e = 2.7182818284590452 e1 pi = 3.1415926535897932 p3 ) //p3=pi,e1=e iota 常量生成器:在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。 type Weekday int const ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday ) //周日将对应0，周一为1，如此等等 const ( _ = 1 &lt;&lt; (10 * iota) KiB // 1024 MiB // 1048576 GiB // 1073741824 TiB // 1099511627776 (exceeds 1 &lt;&lt; 32) PiB // 1125899906842624 EiB // 1152921504606846976 ZiB // 1180591620717411303424 (exceeds 1 &lt;&lt; 64) YiB // 1208925819614629174706176 ) 2.9 无类型常量有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。 math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方： var x float32 = math.Pi var y float64 = math.Pi var z complex128 = math.Pi]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go(一)]]></title>
    <url>%2F2019%2F09%2F26%2FGo-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1.1命名Go中函数名字的开头字母大小决定了该函数在包外的可见性：大写字母开头，这个函数在包外可以使用；小写字母开头不可以在包外部访问。Go语言程序员推荐使用 驼峰式 命名。 1.2声明var、const、type、func：变量、常量、类型、函数实体对象声明 包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句。在包一级声明的名字可以在整个包和引用了该包的源文件中访问。 1.3变量var 变量名字 类型 = 表达式 go语言中所有变量定义时如果未赋值，都会初始化为一个默认值。 在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。 freq := rand.Float64() * 3.0 t := 0.0 i, j := 0, 1 //变量声明语句 i, j = j, i // 交换 i 和 j 的值，赋值语句（元组赋值） 简短变量声明语句中必须至少要声明一个新的变量，否则不能编译通过。 1.4指针如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时*p表达式对应p指针指向的变量的值。一般*p表达式读取指针指向的变量的值，这里为int类型的值，同时因为*p对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。 x := 1 p := &amp;x // p, of type *int, points to x fmt.Println(*p) // &quot;1&quot; *p = 2 // equivalent to x = 2 fmt.Println(x) // &quot;2&quot; *p++ // x=3,p仍然指向x 指针的零值为nil，在Go语言中，返回函数中局部变量的地址也是安全的。 var p = f() func f() *int { v := 1 return &amp;v } 1.5 new 函数表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T。 p := new(int) // p, *int 类型, 指向匿名的 int 变量 fmt.Println(*p) // &quot;0&quot; //下面两个函数功能相同 func newInt() *int { return new(int) } func newInt() *int { var dummy int return &amp;dummy } 由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。下面由于new被定义为int类型的变量名，因此在delta函数内部是无法使用内置的new函数的。 func delta(old, new int) int { return new - old } 了解go语言自动垃圾回收器。 1.6 类型type 类型名字 底层类型 type Celsius float64 // 摄氏温度 1.7下划线 ‘_’ //用在import //引入包，会先调用包中的初始化函数，这种使用方式仅让导入的包做初始化，而不使用包中其他功能 import _ &quot;net/http/pprof&quot; //用在返回值 //表示忽略某个值。单函数有多个返回值，用来获取某个特定的值 for _,v := range Slice{} _,err := func() //用在变量 //上面用来判断 type T是否实现了I,用作类型断言，如果T没有实现借口I，则编译错误. type T struct{} var _ I = T{} 其中 I为interface //用在函数定义中省略带名的参数 func demo() ( int, int, string, int ,error) //返回多个参数时,尤其是类型相同的，不利于阅读， func demo() ( sumA int, sumB int, _ string, total int ,_ error) //返回参数 int 加了名字，对比上面,便于理解,但是 &quot;string&quot; 和 &quot;error&quot;没有名字，编译会报错，用下划线可以忽略命名 1.8 os.Args由os包实现，用于给出程序运行时的参数。os.Args的类型是 []string ，也就是字符串切片。所以可以在for循环的range中遍历，还可以用 len(os.Args) 来获取其数量。 package main import ( &quot;fmt&quot; &quot;os&quot; &quot;strconv&quot; ) func main () { for idx, args := range os.Args { fmt.Println(&quot;参数&quot; + strconv.Itoa(idx) + &quot;:&quot;, args) } } //运行结果 $go run main.go 1 3 -X ? 参数0: /tmp/go-build116558042/command-line-arguments/_obj/exe/main 参数1: 1 参数2: 3 参数3: -X 参数4: ? //参数0为程序路径本身 1.9 flag包使用flag包，首先定义待解析命令行参数，也就是以”-“开头的参数，比如这里的 -b -s -help等。-help不需要特别指定，可以自动处理。 flag使用前，必须首先解析：flag.Parse() 。 参数中没有能够按照预定义的参数解析的部分，通过flag.Args()即可获取，是一个字符串切片。 通过flag.Bool和flag.String，建立了2个指针b和s，分别指向bool类型和string类型的变量。所以后续要通过 *b 和 *s 使用变量值。 package main import ( &quot;fmt&quot; &quot;flag&quot; ) //参数：命令行参数名称，默认值，提示字符串 var b = flag.Bool(&quot;b&quot;, false, &quot;bool类型参数&quot;) var s = flag.String(&quot;s&quot;, &quot;&quot;, &quot;string类型参数&quot;) func main() { flag.Parse() fmt.Println(&quot;-b:&quot;, *b) fmt.Println(&quot;-s:&quot;, *s) fmt.Println(&quot;其他参数：&quot;, flag.Args()) } ------------------------------------ $ go run main.go -b: false -s: 其他参数： [] ------------------------------------ $ go run main.go -b -b: true -s: 其他参数： [] ------------------------------------ $ go run main.go -b -s test others -b: true -s: test 其他参数： [others] ------------------------------------ $ go run main.go -help Usage of /tmp/go-build080353851/command-line-arguments/_obj/exe/main: -b bool类型参数 -s string string类型参数 exit status 2 1.10 errerror类型是一个接口类型，定义如下： type error interface { Error() string } 可以通过实现error接口来生成错误信息，如果产生错误，就会生成一个non-nil的error对象，将此对象与nil比较，结果为true。 func Sqrt(f float64) (float64, error) { if f &lt; 0 { return 0, errors.New(&quot;math: square root of negative number&quot;) } // 实现 } result, err:= Sqrt(-1) if err != nil { fmt.Println(err) } 1.11 包的初始化和标准输入输出func init() { /* ... */ } 初始化函数在包调用时自动执行。 func main() { input := bufio.NewScanner(os.Stdin)//初始化一个扫表对象 for input.Scan() {//扫描输入内容 line := input.Text()//把输入内容转换为字符串 fmt.Println(line)//输出到标准输出 } } 1.12 作用域if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域。 if x := f(); x == 0 { fmt.Println(x) } else if y := g(x); x == y { fmt.Println(x, y) } else { fmt.Println(x, y) } fmt.Println(x, y) // compile error: x and y are not visible here 在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归引用了自身，则会产生编译错误。 var cwd string //使用声明语句，初始化的cwd为局部变量，导致全局变量cwd并未被初始化 func init() { cwd, err := os.Getwd() // NOTE: wrong! if err != nil { log.Fatalf(&quot;os.Getwd failed: %v&quot;, err) } log.Printf(&quot;Working directory = %s&quot;, cwd) } var cwd string //将err先定义，再使用赋值方法 func init() { var err error cwd, err = os.Getwd() if err != nil { log.Fatalf(&quot;os.Getwd failed: %v&quot;, err) } }]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java随笔--正则表达式]]></title>
    <url>%2F2019%2F09%2F22%2Fjava-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[题目地址：https://leetcode-cn.com/problems/string-to-integer-atoi/ import java.util.regex.*; class Solution { public static int myAtoi(String str) { str=str.trim(); String pattern=&quot;^[\\+\\-\\d]\\d*&quot;;//正则表达式，表示以正号或负号或数字开头，且后面是0个或多个数字 Pattern p=Pattern.compile(pattern); Matcher m=p.matcher(str); String res=&quot;&quot;; if(m.find()){//能匹配到 res=str.substring(m.start(),m.end()); }else{//不能匹配到 return 0; } //能匹配到但只有一个+-号，也返回0 if(res.length()==1&amp;&amp;(res.charAt(0)==&#39;+&#39;||res.charAt(0)==&#39;-&#39;)){ return 0; } try{ int r=Integer.parseInt(res); return r; }catch(Exception e){ return res.charAt(0)==&#39;-&#39;?Integer.MIN_VALUE:Integer.MAX_VALUE; } } } 在使用java正则表达式时要注意：java中”\\“表示”\“,”\\+”表示”+”,因为”+”需要转义， lookingAt()lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返回true Pattern p=Pattern.compile(&quot;\\d+&quot;); Matcher m=p.matcher(&quot;22bb23&quot;); m.lookingAt();//返回true,因为\d+匹配到了前面的22 Matcher m2=p.matcher(&quot;aa2223&quot;); m2.lookingAt();//返回false,因为\d+不能匹配前面的aa Mathcer.start()/ Matcher.end()/ Matcher.group()start()返回匹配到的子字符串在字符串中的索引位置.end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置.group()返回匹配到的子字符串 start(),end(),group()均有一个重载方法它们是start(int i),end(int i),group(int i)专用于分组操作,Mathcer类还有一个groupCount()用于返回有多少组. Pattern p=Pattern.compile(&quot;\\d+&quot;); Matcher m=p.matcher(&quot;我的QQ是:456456 我的电话是:0532214 我的邮箱是:aaa123@aaa.com&quot;); while(m.find()) { System.out.println(m.group()); } 输出： 456456 0532214 123 //或者 while(m.find()) { System.out.println(m.group()); System.out.print(&quot;start:&quot;+m.start()); System.out.println(&quot; end:&quot;+m.end()); } 输出： 456456 start:6 end:12 0532214 start:19 end:26 123 start:36 end:39 可以看出，每执行一次find()，matcher对应的分组都会自动加一。start(),end(),group()三个方法的值都会改变,匹配到的子字符串的信息,以及它们的重载方法,也会改变成相应的信息. 后面遇到有关正则表达式问题再进行补充。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JAVA随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql学习笔记（三）]]></title>
    <url>%2F2019%2F09%2F21%2FMysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[select 字段列表form 表名where 查询筛选条件group by 指定分组的列列表having 指定分组后的筛选条件order by 排序列的列表limit 起始索引值，要查询的记录条数 1、分组查询：group by分组函数（聚合函数）：将多行的值进行统计返回一行结果sum() ; avg(); min(); max(); count().注：分组函数不能和与分组无关的列一起使用；分组查询时，查询的列可以是分组的条件 SELECT SUM(salary)，COUNT(eid)，did FROM t_employ GROUP BY did; SELECT did,COUNT(eid) FROM t_employ WHERE salary&gt;10000 AND did IS NOT NULL GROUP BY did; 2、条件中需要使用分组后的结果:having作用和where一样，但是执行顺序在分组之后 SELECT AVG(salary) FROM t_employ GROUP BY did HAVING AVG(salary)&gt;9000;3、order by：降序排列desc，升序排列ascSELECT * FROM t_employ ORDER BY salary DESC, eid ASC; 4、分页查询：limit index，size 5、子查询：当前查询依赖另一个查询的结果 SELECT * FROM t_employ WHERE did=( SELECT did FROM t_employ WHERE ename=&#39;罗宾&#39; )；三种类型：1、将子查询结果当做where查询的条件；2、当做临时表再次查询；3、作为主查询的判断条件，决定数据是否查询。exists型子查询 6、复制表 复制表结构：CREATE TABLE t_emp AS(SELECT * FROM t_employ WHERE 1=2);复制表结构+指定数据：where 条件 7、单行函数：处理一行返回一行结果SELECT UPPER(email) FROM t_employ;password():mysql数据库在将数据库管理员的信息进行保存时，会将密码加密保存。SELECT PASSWORD(&#39;123456&#39;) FROM DUAL; (dual练习表)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql学习笔记（二）]]></title>
    <url>%2F2019%2F09%2F21%2FMysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、自增长：如果一列是主键，并且数据类型是int，则支持自动增长，每次插入数据时，会自动加一表定义时加上 id INT(11) PRIMARY KEY AUTO_INCREMENT； 2、给查询到的列取别名，表也可以取别名SELECT 列名 AS ‘别 名’，列名 别名，…… FROM 表名3、去重复：将查询到的所有列的重复筛选掉SELECT DISTINCT 列名 FROM 表名 4、查询时 进行计算支持数学运算符，逻辑运算符：xor异或比较运算符：=，&gt;,&lt;,&gt;=,&lt;=集合：in(值列表)范围：between min and max 5、模糊查询:like ‘模糊字符串’%:代表0~n个任意字符_：代表一个任意字符 6、使用 ifnull(字段，默认值) 方法解决null值计算问题 7、字符串拼接时的null值（sql中的+不能拼接字符串）concat（字段和字符串列表）：自动将方法内的所有字符串进行拼接处理 8、联合查询多表查询时，需要指定连接条件才能避免笛卡尔积：表名.列名（指定是哪个表的列）多表查询时，最少指定n-1个连接条件才能避免笛卡尔积 9、内连接（INNER JOIN）sql99推荐多表连接使用：表1 join 表2 on 连接条件 join 表3 on 连接条件INNER JOIN（只有满足条件的数据才能被查询） 10、外连接(左外连接：左表不满足条件的数据也查询出来，右外连接）LEFT OUTER JOIN全连接 11、自连接：当前表连接当前表，使用别名区分]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql学习笔记（一）]]></title>
    <url>%2F2019%2F09%2F21%2FMysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[DDL语句1、建库 CREAT DATABASE 名字不区分大小写，推荐关键字大写；单词间加‘_’mysql数据结构：char，varchar CREATE TABLE tm_teammanager( id INT(11), &#39;name&#39; VARCHAR(30),#通过飘号选中的字符会保留字符串本意，不会当成关键字，~ gender CHAR(2) )2、查表结构 DESC tm_teammanager3、从删库到跑路备份为.sql文件 DROP TABLE 表名 DROP DATABASE 4、修改表名 ALTER TABLE oldname RENAME newname;5、给表添加一列 ALTER TABLE 表名 ADD COLUMN 名字 INT(3) (加上类型)6、删除表一列 ALTER TABLE 表名 DROP COLUMN 列名7、给一列重命名change ALTER TABLE 表名 CHANGE 列名 新列名 数据类型8、修改表列的数据类型modify ALTER TABLE 表名 MODIFY 列名 新数据类型DML语句1、插入数据 INSERT INTO 表名 VALUES(); #必须给所有列指定值 INSERT INTO 表名(id,列名……) VALUES(对应值);2、查询 select 3、修改数据 update UPDATE 表名 SET 列名=值 WHERE id=2；4、删除 delete DELETE FROM 表名 delete、drop、truncate区别约束 constrains1、主键约束 primary key（字段值唯一非空）主键只能有一个1.1添加主键：创建表时添加约束CONSTRAINT PRIMARY KEY(列名)1.2 通过alter语句给表添加主键约束（表创建后添加） ALTER TABLE 表名 DROP PRIMARY KEY; #先删除原有主键约束 ALTER TABLE 表名 ADD PRIMARY KEY(列名) 或 ALTER TABLE 表名 MODIFY …… PRIMARY KEY2、唯一键约束2.1 创建时添加2.2 修改表的指定列添加唯一键约束 ALTER TABLE ^ MODIFY ^ ^ UNIQUE; 删除唯一键约束 ALTER TABLE 表名 DROP INDEX 列名； 查看索引 SHOW INDEX FROM 表名 3、非空约束 not null3.1创建表时添加 CREATE TABLE t_stu( &amp;emsp;&amp;emsp;id INT(11) NOT NULL; ); 删除非空约束 alter table 表名 modify 列名 类型；3.2修改列添加非空约束 alter table 表名 modify 列名 类型 not null default “etc”； 4、默认值约束 default5、外键约束外键关联时，两张表建立外键的列数据类型必须相同，长度尽量一致 5.1修改表的指定列，添加外键约束 ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY （当前表的指定列） references 关联的表名（指定要关联的列名）; ALTER TABLE t_stu ADD CONSTRAINT fk_cid FOREIGN KEY(cid) REFERENCES t_course(id);删除外键约束：删除外键，然后才能删除外键对应的索引 ALTER TEBLE 表名 DROP FOREIGN KEY(外键名) ALTER TABLE 表名 DROP INDEX 外键名； 索引需要删除，否则影响效率 5.2创建表时添加 CONSTRAINT 外键名 FOREIGN KEY(列名) REFERENCES关联的表名（列名）5.3删除被其他表关联的数据：当没有其他表引用该行数据可以删除5.4添加外键时指定级联删除或者级联置空]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unsupervised Video Summarization with Adversarial LSTM]]></title>
    <url>%2F2019%2F09%2F21%2F3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文提出一个由summarizer和discriminator组成的生成对抗框架。目的是选择视频的稀疏子集，使得视频和摘要的表示误差最小。 &emsp;&emsp;原始视频的特征是通过GAN和LSTM提取的，GAN以像素为基础提取特征，LSTM捕捉帧之间的长期依赖关系，得到深度特征向量。由于明确深度特征间的合适距离困难，所以由左边结构转换为右边的结构。 论文理论基础：Variational Autoencoder(VAE)，GAN Model Overview&emsp;&emsp;CNN输出的是视频帧的深度特征（deep features x），sLSTM（selector LSTM）在这些帧中选择一个子集，eLSTM(encoder LSTM)将选择的帧序列编码成向量 e 。sLSTM生成每一个帧的标准化重要性得分s，结合x，输入到eLSTM中。dLSTM(decoder LSTM)以e为输入，重构了输入视频的特征序列。鉴别器（discriminator）用来区分原始和摘要视频帧间的特征，用于估计两者之间的representation error。 &emsp;&emsp;本实验中使用二元序列分类器（a binary sequence classifier），所以鉴别器为cLSTM(classifier LSTM)，输出是二分类。 &emsp;&emsp;生成对抗训练的关键是引入一个额外的帧选择器Sp（基于先验分布的，例如均匀分布）。利用概率Sp选择一个子集作为eLSTM的输入，以相同的pipeline生成一系列值，用于计算误差。 Reconstruction loss Lreconst&emsp;&emsp;没有采用传统的欧式距离，而是基于cLSTM的隐藏层表示。cLSTM最后一个隐藏层的输出**表示一个紧凑的特征向量，它捕捉了x（特征序列）的长距离依赖关系。Lre是对数似然的期望。 Loss of GAN这里的先验分布使用均匀分布。 &emsp;&emsp;cLSTM(·)是一个二元的softmax输出。更新参数使用随机梯度变分bayes估计（Stochastic Gradient Variational Bayes estimation） 正则化训练Summary-Length Regularization M帧数量，*希望选择帧数量的百分比 Diversity Regularization 基于DPP 排斥正则化器（Repelling regularizer） Keyframe Regularization]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>视频摘要</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deep Reinforcement Learning for Unsupervised V-S]]></title>
    <url>%2F2019%2F09%2F15%2FDeep-Reinforcement-Learning-for-Unsupervised-Video-Summarization%2F</url>
    <content type="text"><![CDATA[Abstract&emsp;&emsp;本文创新点：1、构建DSN网络；2、设计一个新的奖励函数（基于帧的多样性和代表性）；3、设计一个端到端的、基于强化学习的框架来训练网络。 Introduction&emsp;&emsp;DPP-LSTM效果较好，但是视频摘要的评价时，人类具有更多的主观性，所以非监督方法很有必要。&emsp;&emsp;本文的DSN网络：encoder：CNN（在视频帧上进行特征提取）；decoder：BiLSTM（产生概率分布来选择帧）。RL（增强学习）：通过迭代方式训练agent。&emsp;&emsp;主要贡献：将无监督方法扩展到监督版本，以利用标签；首次将RL应用到无监督视频摘要上。 Model OverviewDeep Summarization Network&emsp;&emsp;采用encoder-decoder结构，CNN选用在ImageNet上预训练好的GoogLeNet，从它倒数第二层提取出视觉特征向量x_{t}。LSTM用来捕获视频帧之间的长时间依赖性。训练中只更新decoder。 &emsp;&emsp;将BiLSTM网络的正向和反向的隐藏层输出拼接作为相应的隐状态，网络输入为视觉特征向量。全连接层结束于sigmoid函数，得出每个帧选择的概率分布，帧是否选择服从二项分布。视频摘要由这些选择的帧组成。 Diversity-Representativeness Reward Function&emsp;&emsp;训练时DSN的目的是最大化奖励函数。&emsp;&emsp;Diversity reward:通过计算选择帧之间的差异性（取平均值）来度量多样性， &emsp;&emsp;公式3忽视了序列数据时间上的关联性，事实上，时间相距较大的两个相似帧对故事线的构筑都很重要。所以设置如下， 入控制时间距离。 &emsp;&emsp;Representativeness reward:视频摘要代表性的度量是一个k-medoids问题， &emsp;&emsp;reward function使用这两个相加，训练时，保持这两个数量级一致。 Training with Policy Gradient&emsp;&emsp;这里介绍使用的强化学习的训练方法，和一些tricks。&emsp;&emsp;因为选择更多的帧也能提高reward，所以加入正则项。和防止过拟合的改进。&emsp;&emsp;这里给出更新参数的公式和最优化算法（Adam），详情见论文。 Summary Generation&emsp;&emsp;通过最大化得分选择子热点，同时控制帧数量不超过总长度15%。热点得分是通过平均化同一个热点中帧的得分来计算的。时间分割算法使用KTS。]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>视频摘要</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Video Summarization with LSTM]]></title>
    <url>%2F2019%2F09%2F15%2FVideo-Summarization-with-Long-Short-term-Memory%2F</url>
    <content type="text"><![CDATA[Abstract&emsp;&emsp;这篇文章提出一个新奇的监督学习方法用来进行视频摘要，用来自动选择关键帧或者关键子热点。将这项任务看成一个结构预测问题（structured prediction problem），主要思路是用LSTM对帧的时间依赖性进行建模。 Introduction&emsp;&emsp;视频摘要如今有两个重要的方法：关键帧选择（keyframe selection，选择一些具有代表性的帧来组成摘要）；关键子热点选择（Key subshot selection，选择一系列在短时间类连续的帧组成摘要，即选择视频中具有代表性的每个时间点，将这些时间点的帧选择）。&emsp;&emsp;非监督学习方法：通过直观标准选择帧&emsp;&emsp;监督学习方法：通过视频帧的标注训练模型，使模型自动学习选择帧的标准。&emsp;&emsp;模型输入是视频的帧序列，输出是一个二元数组（表示这些帧是否选择）。由此得到启发使用LSTM。视频帧内部的依赖性是复杂且不均匀的。&emsp;&emsp;使用LSTM从时间上建立帧的联系，比从视觉上建立联系好（比如不同帧的相似性）。时间上相近的帧，包含的信息会冗余且相似。但是相似的帧包含的信息并不一定相同，且时间不一定相近。使用LSTM来学习时间线。&emsp;&emsp;这篇文章研究如何将LSTM及其变体应用到Video Summarization中。将LSTM与DPP（determinantalpoint process）结合，等一些改进方法。 Model OverviewvsLSTM网络结构： MLP（多层感知机）：输出为标量 使用SGD更新参数，这里是监督学习的方法，使用帧级别重要性得分（连续变量）或者选择的关键帧编码（二元向量） 由于LSTM（查全率高，查准率低），DPP（查准率高，查全率低），现在将这两个结合， DPP（行列式点过程）：DPP编码了从全集中选取任意一个子集的概率 z是子集,Z为全集，L为N*N的核矩阵（记录任意连个帧之间的相似性，实对称半正定方阵），det()为行列式的值，I是N*N的单位矩阵，子集z的概率与矩阵Lz的主子式行列式的值成正比。如果子集中有两个相同的元素时，det(Lz)将等于0。Lz是z在Z中标号对应元素组成的子方阵。 关于DDP的数学证明：https://blog.csdn.net/qq_23947237/article/details/90698325 dppLSTM： MLP是由256个sigmoid隐单元、sigmoid和线性输出单元组成的单层神经网络，两个MLP（第一个计算frame-level importance,第二个计算相似性） Learning： 参数的学习使用MLE（最大似然估计），采用阶段化优化策略：首先训练MLP1和LSTM（vsLSTM）；接下来通过最大化dpp模型指定关键帧的可能性来训练所有mlp和lstm层。 具体细节见论文及增刊]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>视频摘要</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Hueman Insight-Search配置]]></title>
    <url>%2F2019%2F09%2F09%2FHexo-Hueman-Insight-Search%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[博客中的搜索功能一直无法使用，使用npm install -S hexo-generator-json-content安装插件后，仍然无法使用。 通过阅读hexo-generator-json-content的源码配置文件后得知，还需要对hexo的config文件做相应配置： jsonContent: meta: true dafts: false file: content.json keywords: undefined dateFormat: undefined pages: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: false text: true raw: false content: false author: true posts: title: true slug: true date: true updated: true comments: true path: true link: true permalink: true excerpt: true keywords: false text: true raw: false content: false author: true categories: true tags: true]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 while-else、//]]></title>
    <url>%2F2019%2F09%2F08%2FPython3-while-else%E3%80%81%2F</url>
    <content type="text"><![CDATA[在LeetCode-自除数答案中学到的几个语法和技巧， While-else: 1、在Python中，else 可以和 while 循环搭配使用，当 while 循环正常执行完的情况下，执行 else 输出； 2、如果当 while 循环中执行了跳出循环的语句，比如 break，将不执行 else 代码块的内容。 //:向下取整 class Solution: def selfDividingNumbers(self, left: int, right: int) -&gt; List[int]: ans = [] for num in range(left,right + 1): copy = num while copy &gt; 0: div, copy = copy % 10, copy // 10 if div == 0 or num % div != 0: break else: ans.append(num) # while … else 在循环条件为 false 时执行 else 语句块 return ans]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 Counter类、all()]]></title>
    <url>%2F2019%2F09%2F06%2FPython3-Counter%E7%B1%BB%E3%80%81all%2F</url>
    <content type="text"><![CDATA[Counter类(计数器) Counter类返回一个字典，统计每个元素出现次数，可以更新 import collections obj = collections.Counter([&#39;11&#39;,&#39;22&#39;]) obj.update([&#39;22&#39;,&#39;55&#39;]) print(obj) #输出：Counter({&#39;22&#39;: 2, &#39;11&#39;: 1, &#39;55&#39;: 1}) all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。 class Solution: def countCharacters(self, words: List[str], chars: str) -&gt; int: count=collections.Counter(chars) sumlen=0 for word in words: c=collections.Counter(word) #list类型作为参数 if all([count[i]&gt;=c[i] for i in word]): sumlen+=len(word) return sumlen dict.item()返回字典键值对组成的元组]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yield from简单理解]]></title>
    <url>%2F2019%2F09%2F05%2Fyield-from%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[yieldyield简单理解可以看成return，但是函数执行yield后会返回值但是不会终止。 # yield返回值, 生成器 def gen(): for x in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]: yield x for i in gen(): print(i) # a b c 在函数外部不能使用yield from（yield也不行）。 yield fromyield from用来调用生成器，可以用于递归函数中，或者调用的函数中包含yield语句 #中序遍历树 class Solution: def increasingBST(self, root): def inorder(node): if node: yield from inorder(node.left) yield node.val yield from inorder(node.right) ans = cur = TreeNode(None) for v in inorder(root): cur.right = TreeNode(v) cur = cur.right return ans.right 上例函数为生成器函数，生成器对象是一个可迭代对象，可以存储遍历结果]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-下一个更大元素1]]></title>
    <url>%2F2019%2F09%2F04%2FLeetCode-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A01%2F</url>
    <content type="text"><![CDATA[题目地址 数据结构：栈、哈希表 思路：遍历nums2，哈希表存储每个元素后第一个大于它的元素。栈为递减栈，当遇到比栈顶元素大的元素，依次弹出元素，存入哈希表。最后遍历nums1，hash[nums[i]]组成的列表即为所求。 如 nums1 = [4,1,2], nums2 = [1,3,4,2]. stack=[1] hash[1]=3 hash[3]=-1(第一次出现该元素，hash值为-1) stack=[3] hash[3]=4 hash[4]=-1 stack=[4] stack=[4,2] hash[2]=-1 class Solution(object): def nextGreaterElement(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[int] &quot;&quot;&quot; stack=[] hashmap={} for num in nums2: while len(stack)&gt;0 and stack[-1]&lt;num : hashmap[stack.pop()]=num hashmap[num]=-1 stack.append(num) return [hashmap[i] for i in nums1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-质数排列]]></title>
    <url>%2F2019%2F09%2F02%2FLeetCode-%E8%B4%A8%E6%95%B0%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[质数：质数是大于1的，且不能用小于它的两个正整数乘积表示。 首先求1-n中质数的个数 def getnum(self,n:int) -&gt;int: num=0 for i in range(2,n+1): flag=True for j in range(2,int(i**0.5)+1): if i%j==0: flag=False break if flag==True: num+=1 return num 总的方案数就是质数排列数和非质数排列数的乘积 def jiecheng(self,n:int) -&gt;int: sums=1 for i in range(1,n+1): sums*=i return sums%1000000007 def numPrimeArrangements(self, n: int) -&gt; int: if n==1 or n==2: return 1 count=self.getnum(n) #调用类中的函数要使用self. num=self.jiecheng(count)*self.jiecheng(n-count) return num%1000000007]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-回文字符串]]></title>
    <url>%2F2019%2F08%2F30%2FPython-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[filter(str.isalnum,s)**1、filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。2、Python isalnum()方法isalnum() 方法检测字符串是否由字母和数字组成。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
